<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>阿阳的博客</title>
  
  <subtitle>阿阳的博客看心情更新</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.kyangc.com/"/>
  <updated>2018-03-17T06:12:00.848Z</updated>
  <id>http://blog.kyangc.com/</id>
  
  <author>
    <name>KYANGC</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2017 年终总结</title>
    <link href="http://blog.kyangc.com/2017/12/18/2017-summary/"/>
    <id>http://blog.kyangc.com/2017/12/18/2017-summary/</id>
    <published>2017-12-18T10:00:00.000Z</published>
    <updated>2018-03-17T06:12:00.848Z</updated>
    
    <content type="html"><![CDATA[<p>站在 2017 年末回顾这一年……</p><p>感慨很多，能说的不多。不想写太多流水账，而且确实这一年也没做太多事，就稍微说两句吧：</p><ul><li>年初准备了俩月跳了个槽，算是捞了一把掉进天坑的自己，缓了一口气。</li><li>在团队里努力搬砖，拿了个最佳新人，算是对这半年的努力工作的小小鼓励。</li><li>国庆去了趟日本，算是总算圆了个出国的愿望。</li><li>前端技术层面上的进境有限，倒是在其他技术上点了好些奇奇怪怪的技能点，不过看上去用处也不多。</li><li>想要学 ML/AI，但是却一直很软弱的在推进，聊胜于无的状况。</li><li>读了几本书，培养了一些自己觉得蛮好的习惯，但是拖延症依然在线。</li><li>这一年游了不少泳，而且从年末开始重操旧业踢足球，感觉蛮好的。</li><li>点出来挺多投资相关的技能点，但都不精深，见识了币圈的疯狂，也进美股泡了泡水，终究还是没啥钱，最多也就是看看。</li><li>听到不少周围小伙伴的高收入，看看自己，还是觉得自己太弱了。</li><li>虽然刚工作一年半，但总觉得中年危机已经降临……对未来看不清，最近每天都很焦虑。</li><li>总的来讲，这一年，无论是职业层面、技术层面还是知识层面都酸算有点小收获，但是对未来却更迷茫了。</li></ul><p>所以……就这样啊，至于新的一年……就做到一件事吧：<strong>缓解拖延症</strong>。</p><p>始终觉得自己不缺方向感，只是缺动力，惯性太强，需要更强的力量让自己动起来才行。如果真的能做到的话……我觉得很多事情都能迎刃而解了吧。</p><p>以上。</p><p>祝你们新年快乐。</p>]]></content>
    
    <summary type="html">
    
      很丧啊
    
    </summary>
    
      <category term="总结" scheme="http://blog.kyangc.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结" scheme="http://blog.kyangc.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>使用 Things 3 和桌面的特别姿势</title>
    <link href="http://blog.kyangc.com/2017/11/24/good-way-to-use-things-and-desktop/"/>
    <id>http://blog.kyangc.com/2017/11/24/good-way-to-use-things-and-desktop/</id>
    <published>2017-11-24T18:04:23.000Z</published>
    <updated>2018-03-17T06:12:00.848Z</updated>
    
    <content type="html"><![CDATA[<p>Things 3 是我最近一直在用的 GTD 软件，简洁、高效、交互体验好，某宝售价五元的 Things 3，可以说比我两块五买的 Omni* 系列好用不要太多。Things 可以按 Area 区分 Task，每个 Area 下可以建立对应的 Project，每个 Task 下可以建立 SubTask，三级任务分类足以覆盖我绝大多数情况下的事务记录。并且展示方式也很棒，可以按时间线展示、按未来待办展示等等……（哎打广告的先停一停啊…… 总之就是很棒就对了！</p><p>但是使用中依然存在痛点：为了看自己的「待办清单」，我每次都会经历以下步骤：</p><ul><li>打开 alfred</li><li>输入 things</li><li>找到不知道从主屏还是副屏中弹出来的 Things 窗口</li><li>移动鼠标到窗口上</li><li>点击对应任务组的分类</li><li>查看待办清单</li></ul><p>这么多步骤对于我来讲实在是很容易浇灭使用 GTD 软件的心，于是就容易形成这样的恶性循环：</p><blockquote><p>懒得用 GTD 软件 → 生活没有规划 → 人生走向低谷 → 越来越贫困……</p></blockquote><p>可以说后果非常严重了…… 那么该怎么做呢？来自四川的贫困的小程陷入了思索：</p><blockquote><p>看 Things 内容很繁琐 → 有没有什么便捷的展示信息的方案 → 命令行 → 一行命令就可以展示所有待办任务岂不快哉？</p></blockquote><p>说干就干，Things 3 官方不提供 CLI 的话，可以看看有没有屌大的自己写，果然被我一搜就搜到了：<a href="https://github.com/AlexanderWillner/things.sh" target="_blank" rel="noopener">AlexanderWillner/things.sh</a></p><p>原来 Things 3 的 DB 是基于 sqlite 开发的，而且没加密……所以只要你愿意你自己写个命令行程序去增删改查都行……但是考虑到我使用 Things 的痛点其实不在增删改上，而且自己乱写 SQL 操作数据库风险太大经不起折腾……所以这个脚本虽然只提供了对于各种内容的查找功能，但是已经足够甚至超出了我所需要的适用范围，加上许多格式不符合我的需求，于是直接上手改吧：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -o errexit</span><br><span class="line"><span class="comment"># set -o nounset</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># default options</span></span><br><span class="line">limitBy=<span class="string">"20"</span></span><br><span class="line">waitingTag=<span class="string">"Waiting for"</span></span><br><span class="line">orderBy=<span class="string">"creationDate"</span></span><br><span class="line">area=<span class="string">""</span></span><br><span class="line">project=<span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">readonly</span> PROGNAME=$(basename <span class="variable">$0</span>)</span><br><span class="line"><span class="built_in">readonly</span> DEFAULT_DB=~/Library/Containers/com.culturedcode.ThingsMac/Data/Library/Application\ Support/Cultured\ Code/Things/Things.sqlite3</span><br><span class="line"><span class="built_in">readonly</span> THINGSDB=<span class="variable">$&#123;DB:-$DEFAULT_DB&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># table names</span></span><br><span class="line"><span class="built_in">readonly</span> TASKTABLE=<span class="string">"TMTask"</span></span><br><span class="line"><span class="built_in">readonly</span> AREATABLE=<span class="string">"TMArea"</span></span><br><span class="line"><span class="built_in">readonly</span> TAGTABLE=<span class="string">"TMTag"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># is trashed</span></span><br><span class="line"><span class="built_in">readonly</span> ISNOTTRASHED=<span class="string">"trashed = 0"</span></span><br><span class="line"><span class="built_in">readonly</span> ISTRASHED=<span class="string">"trashed = 1"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># status</span></span><br><span class="line"><span class="built_in">readonly</span> ISOPEN=<span class="string">"status = 0"</span></span><br><span class="line"><span class="built_in">readonly</span> ISCANCELLED=<span class="string">"status = 2"</span></span><br><span class="line"><span class="built_in">readonly</span> ISCOMPLETED=<span class="string">"status = 3"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># start</span></span><br><span class="line"><span class="built_in">readonly</span> ISNOTSTARTED=<span class="string">"start = 0"</span></span><br><span class="line"><span class="built_in">readonly</span> ISSTARTED=<span class="string">"start = 1"</span></span><br><span class="line"><span class="built_in">readonly</span> ISPOSTPONED=<span class="string">"start = 2"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># type</span></span><br><span class="line"><span class="built_in">readonly</span> ISTASK=<span class="string">"type = 0"</span></span><br><span class="line"><span class="built_in">readonly</span> ISPROJECT=<span class="string">"type = 1"</span></span><br><span class="line"><span class="built_in">readonly</span> ISHEADING=<span class="string">"type = 2"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># merged queries</span></span><br><span class="line"><span class="built_in">readonly</span> IS_UNCOMPLETE_VALID_TASK=<span class="string">"type = 0 AND status = 0 AND trashed = 0"</span></span><br><span class="line"><span class="built_in">readonly</span> IS_UNCOMPLETE_VALID_PROJECT=<span class="string">"type = 1 AND status = 0 AND trashed = 0"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">usage</span></span>() &#123;</span><br><span class="line">  cat &lt;&lt;-EOF</span><br><span class="line">usage: <span class="variable">$&#123;PROGNAME&#125;</span> &lt;OPTIONS&gt; [COMMAND]</span><br><span class="line"></span><br><span class="line">List to <span class="keyword">do</span> items from your Things database given a focus area.</span><br><span class="line"></span><br><span class="line">COMMAND:</span><br><span class="line">  area  (show tasks <span class="keyword">in</span> given area)</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">  -a|--area &lt;area&gt;        List tasks <span class="keyword">in</span> area</span><br><span class="line">EOF</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># utils for displaying text</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">printLineWithLevel</span></span>() &#123;</span><br><span class="line">  <span class="comment"># set \n as separator</span></span><br><span class="line">  OLD_IFS=<span class="variable">$IFS</span></span><br><span class="line">  IFS=$<span class="string">'\n'</span></span><br><span class="line"></span><br><span class="line">  array=(<span class="variable">$1</span>)</span><br><span class="line">  level=<span class="variable">$2</span></span><br><span class="line">  indicator=<span class="variable">$3</span></span><br><span class="line">  <span class="keyword">for</span> data <span class="keyword">in</span> <span class="variable">$&#123;array[@]&#125;</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    line=<span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> $( seq 1 <span class="variable">$&#123;level&#125;</span> )</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      line=<span class="string">"<span class="variable">$indicator</span><span class="variable">$line</span>"</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    line=<span class="string">"<span class="variable">$line</span> <span class="variable">$data</span>"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$line</span>"</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># fallback separator</span></span><br><span class="line">  IFS=<span class="variable">$OLD_IFS</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># utils for handling SQL result</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">printSQLResult</span></span>() &#123;</span><br><span class="line">  <span class="comment"># set \n as separator</span></span><br><span class="line">  OLD_IFS=<span class="variable">$IFS</span></span><br><span class="line">  IFS=$<span class="string">'\n'</span></span><br><span class="line"></span><br><span class="line">  array=(<span class="variable">$1</span>)</span><br><span class="line">  level=<span class="variable">$2</span></span><br><span class="line">  <span class="keyword">if</span> [ -n <span class="variable">$&#123;array&#125;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> <span class="variable">$&#123;array[@]&#125;</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      <span class="comment"># print task name</span></span><br><span class="line">      printLineWithLevel <span class="string">"<span class="variable">$item</span>"</span> <span class="variable">$level</span> <span class="string">" "</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># fallback separator</span></span><br><span class="line">  IFS=<span class="variable">$OLD_IFS</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">t</span></span>() &#123;</span><br><span class="line">  printSQLResult <span class="string">"`listAreas`"</span> 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">listAreas</span></span>() &#123;</span><br><span class="line">  sqlite3 <span class="string">"<span class="variable">$THINGSDB</span>"</span> &lt;&lt;-SQL</span><br><span class="line">SELECT title</span><br><span class="line">FROM <span class="variable">$&#123;AREATABLE&#125;</span>;</span><br><span class="line">SQL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">listProjectsInGivenArea</span></span>() &#123;</span><br><span class="line">  sqlite3 <span class="string">"<span class="variable">$THINGSDB</span>"</span> &lt;&lt;-SQL</span><br><span class="line">SELECT title</span><br><span class="line">FROM <span class="variable">$&#123;TASKTABLE&#125;</span></span><br><span class="line">WHERE <span class="variable">$&#123;IS_UNCOMPLETE_VALID_PROJECT&#125;</span> AND area=(select uuid from <span class="variable">$&#123;AREATABLE&#125;</span> <span class="built_in">where</span> title=<span class="string">"<span class="variable">$&#123;area&#125;</span>"</span>);</span><br><span class="line">SQL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">listTaskInGivenArea</span></span>() &#123;</span><br><span class="line">  sqlite3 <span class="string">"<span class="variable">$THINGSDB</span>"</span> &lt;&lt;-SQL</span><br><span class="line">SELECT title</span><br><span class="line">FROM <span class="variable">$&#123;TASKTABLE&#125;</span></span><br><span class="line">WHERE <span class="variable">$&#123;IS_UNCOMPLETE_VALID_TASK&#125;</span> AND area=(select uuid from <span class="variable">$&#123;AREATABLE&#125;</span> <span class="built_in">where</span> title=<span class="string">"<span class="variable">$&#123;area&#125;</span>"</span>) and project is NULL;</span><br><span class="line">SQL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">listTaskInGivenProject</span></span>() &#123;</span><br><span class="line">  sqlite3 <span class="string">"<span class="variable">$THINGSDB</span>"</span> &lt;&lt;-SQL</span><br><span class="line">SELECT title</span><br><span class="line">FROM <span class="variable">$&#123;TASKTABLE&#125;</span></span><br><span class="line">WHERE <span class="variable">$&#123;IS_UNCOMPLETE_VALID_TASK&#125;</span> AND project=(select uuid from <span class="variable">$&#123;TASKTABLE&#125;</span> <span class="built_in">where</span> title=<span class="string">"<span class="variable">$&#123;project&#125;</span>"</span>) and area is NULL;</span><br><span class="line">SQL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">area</span></span>() &#123;</span><br><span class="line">  <span class="comment"># print inbox items</span></span><br><span class="line">  printLineWithLevel <span class="string">"Inbox"</span> 1 <span class="string">" "</span></span><br><span class="line">  printSQLResult <span class="string">"`inbox`"</span> 5</span><br><span class="line"></span><br><span class="line">  <span class="comment"># try to get areas list</span></span><br><span class="line">  <span class="keyword">if</span> [[ -z <span class="variable">$&#123;area&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># display all areas</span></span><br><span class="line">    areas=`listAreas`</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment"># display given areas</span></span><br><span class="line">    areas=<span class="variable">$&#123;area&#125;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># loop to display all area tasks in given area list</span></span><br><span class="line">  areaArray=(<span class="variable">$&#123;areas&#125;</span>)</span><br><span class="line">  <span class="keyword">for</span> item <span class="keyword">in</span> <span class="variable">$&#123;areaArray[@]&#125;</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    <span class="comment"># list area name</span></span><br><span class="line">    printLineWithLevel <span class="string">"<span class="variable">$item</span>"</span> 1 <span class="string">" "</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># list tasks directly belongs to this area</span></span><br><span class="line">    area=<span class="variable">$&#123;item&#125;</span></span><br><span class="line">    tasks=`listTaskInGivenArea`</span><br><span class="line">    <span class="keyword">if</span> [[ -n <span class="variable">$tasks</span> ]]; <span class="keyword">then</span></span><br><span class="line">      <span class="comment"># has non-project tasks</span></span><br><span class="line">      printLineWithLevel <span class="string">"其他"</span> 3 <span class="string">" "</span></span><br><span class="line">      printSQLResult <span class="string">"`listTaskInGivenArea`"</span> 5</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># get all projects in this area</span></span><br><span class="line">    TMP_IFS=<span class="variable">$IFS</span></span><br><span class="line">    IFS=$<span class="string">'\n'</span></span><br><span class="line">    projects=`listProjectsInGivenArea`</span><br><span class="line">    projects=(<span class="variable">$&#123;projects&#125;</span>)</span><br><span class="line">    IFS=<span class="variable">$TEM_IFS</span></span><br><span class="line">    <span class="keyword">if</span> [[ -n <span class="variable">$&#123;projects&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">      <span class="comment"># has projects under area</span></span><br><span class="line">      <span class="keyword">for</span> sproject <span class="keyword">in</span> <span class="variable">$&#123;projects[@]&#125;</span></span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">        <span class="comment"># print project name</span></span><br><span class="line">        printLineWithLevel <span class="string">"<span class="variable">$sproject</span>"</span> 3 <span class="string">" "</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># find all task in project</span></span><br><span class="line">        project=<span class="variable">$&#123;sproject&#125;</span></span><br><span class="line">        printSQLResult <span class="string">"`listTaskInGivenProject`"</span> 5</span><br><span class="line">      <span class="keyword">done</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">require_sqlite3</span></span>() &#123;</span><br><span class="line">  <span class="built_in">command</span> -v sqlite3 &gt; /dev/null 2&gt;&amp;1 || &#123;</span><br><span class="line">    <span class="built_in">echo</span> &gt;&amp;2 <span class="string">"ERROR: SQLite3 is required but could not be found."</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">require_db</span></span>() &#123;</span><br><span class="line">  <span class="built_in">test</span> -r <span class="string">"<span class="variable">$THINGSDB</span>"</span> -a -f <span class="string">"<span class="variable">$THINGSDB</span>"</span> || &#123;</span><br><span class="line">    <span class="built_in">echo</span> &gt;&amp;2 <span class="string">"ERROR: Things database not found at <span class="variable">$THINGSDB</span>."</span></span><br><span class="line">    <span class="built_in">exit</span> 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">require_sqlite3</span><br><span class="line">require_db</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [[ <span class="variable">$#</span> -gt 1 ]]; <span class="keyword">do</span></span><br><span class="line">  key=<span class="string">"<span class="variable">$1</span>"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="variable">$&#123;key&#125;</span> <span class="keyword">in</span></span><br><span class="line">    -a|--area) area=<span class="string">"<span class="variable">$2</span>"</span>;<span class="built_in">shift</span> ;;</span><br><span class="line">    *) ;;</span><br><span class="line">  <span class="keyword">esac</span></span><br><span class="line">  <span class="built_in">shift</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">command</span>=<span class="variable">$&#123;1:-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ -n <span class="variable">$&#123;command&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">    area) area ;;</span><br><span class="line">    *) usage ;;</span><br><span class="line">  <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  usage;</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>使用效果就像这样：</p><p><img src="http://ojanerta1.bkt.clouddn.com/2017-11-24-1.png" alt="命令行调用结果"></p><p>OK，事情是不是到这里就结束了呢？因为懒惰而异常贫穷的小程表示还不够：</p><blockquote><p>我还是得先唤起命令行窗口 → 输入命令 → 查看结果…… 还是麻烦</p></blockquote><p>有没有更方便的做法？小程看着面前的 Dell 27’ 4K 显示器，觉得这么大个显示器，好像平时也就利用了中间这么一小部分啊…… <strong>两侧的空白</strong>能用来做什么呢？小程陷入了沉思……</p><p><strong>桥豆麻袋！</strong>说到这个「两侧的空白」啊，必须先提一下小程最近在使用窗口管理时的策略：</p><blockquote><p>4K 27’ 显示器是主屏幕，对于绝大多数情况下，只会在屏幕内摆放一个窗口，这个窗口会占据屏幕宽度的百分之 70，占据屏幕高度的百分之 90</p></blockquote><p>就像这样：（通过快捷键让所有窗口 resize 并居中）</p><p><img src="http://ojanerta1.bkt.clouddn.com/2017-11-24-2.png" alt="日常状况"></p><p>在有些时候会采取更 focus 的策略，会通过快捷键让窗口全屏：</p><p><img src="http://ojanerta1.bkt.clouddn.com/2017-11-24-3.png" alt="Focus 状况"></p><p>在需要查看当前窗口的时候会通过快捷键展示当前显示器中有哪些窗口：</p><p><img src="http://ojanerta1.bkt.clouddn.com/2017-11-24-5.png" alt="List 状况"></p><p>唔…… 以上的窗口管理是通过 <a href="https://github.com/kasper/phoenix" target="_blank" rel="noopener">Phoenix</a> 完成的，这款神器呢是以前公司的架构师 <a href="https://blog.alswl.com/about/" target="_blank" rel="noopener">DDD</a> 安利给我的<del>（当然也安利给了很多人）</del>，这里我就再继续安利出去好了~ 具体介绍请直戳链接围观，简单来讲就是个可编程的（js）、利用键盘快捷键对窗口进行管理的软件~ 如果真的感兴趣请戳以下链接围观：<a href="https://blog.alswl.com/2016/04/windows-management-for-hacker/" target="_blank" rel="noopener">windows management for hacker</a></p><p>收回来一下，其实上面就讲了一件事：<strong>我平时的工作窗口其实还有两侧的空白没有被利用起来。</strong></p><p>那我能利用这两块空白做点什么呢？</p><p>想到这里，我又想起来曾经在 Windows 7 环境下用过的「便签」小工具…… 其实这玩意在 Mac 上也有，不过被放在 Dashboard 上了，想用还得去另一块窗口，忒不方便，而且<strong>贼 jb 丑</strong>啊……</p><p>于是想到这里，贫困的小程不禁想到：<strong>有没有办法在空白屏幕上写字啊</strong>？</p><p>会这么想也是有原因的，以前在 Windows 时代我想很多人都折腾过 <a href="https://www.rainmeter.net/" target="_blank" rel="noopener">Rainmeter</a> 之类的桌面美化软件，在桌面上画个画模拟个仪表盘还不是个分分钟的事情…… 那 Mac 上该咋整咧？</p><p>Google 了一下，很快就发现了这么个有趣的小玩意：<a href="https://www.tynsoe.org/v2/geektool/" target="_blank" rel="noopener">GeekTool</a></p><p>他能干什么呢…… 简单来讲哦，这个小工具可以让你在桌面上定义一个区域，显示一段脚本的输出结果、一幅图、一个网页以及一个日志文件的输出，当然这些东西都是不可交互的。就像这样：</p><p><img src="http://ojanerta1.bkt.clouddn.com/2017-11-24-6.png" alt="GeekTool"></p><p>可以看到这里显示了我的一行命令「date」的执行结果……</p><p>这…… 就很他娘的有趣了！</p><p>结合之前的 Things CLI…… 于是空出了左边屏幕，填入脚本：</p><p>Bazinga！</p><p><img src="http://ojanerta1.bkt.clouddn.com/2017-11-24-7.jpeg" alt="最终效果"></p><p>可以看到屏幕左边空白显示了我 Things 里面所有待办的事项，右边则显示了我一个固定的 Note.md 里面的内容，我有时候会通过命令行快速记录一些东西，都会记录在这里。</p><p>这个脚本会每五秒执行一次，所以基本上你在 Things 里面操作了待办事项之后可以瞬间显示在这里~~</p><p>呼……bb 这么多，至此，我使用 Things 3 的时候遇到的痛点就都解决啦~ 并且还开发出了一个新的信息展示区域~ 开心~</p><p>这个小工具我已经使用了超过一周了，目前运行良好~ 几乎没有什么性能开销，你唯一需要做的就是：空出一块屏幕，定义一个脚本，搞定你的输出，然后 enjoy the DESKTOP！</p>]]></content>
    
    <summary type="html">
    
      来自四川山区贫困的小程为了生存改造了桌面
    
    </summary>
    
      <category term="技术" scheme="http://blog.kyangc.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="折腾" scheme="http://blog.kyangc.com/tags/%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title>用 Dayone 写日报的正确姿势</title>
    <link href="http://blog.kyangc.com/2017/11/16/write-daily-report-with-dayone/"/>
    <id>http://blog.kyangc.com/2017/11/16/write-daily-report-with-dayone/</id>
    <published>2017-11-16T12:00:00.000Z</published>
    <updated>2018-03-17T06:12:00.852Z</updated>
    
    <content type="html"><![CDATA[<p>写日报是个好习惯，管理日记的 Dayone 是个好软件，但是状态栏小工具实在不好用，而且 Dayone 不提供模板，每次写日报的时候都得自己手动写格式，实在是非常烦人。而且每天的日报光有我自己 bb，没啥别的实锤证明我自己干了些什么事， 实在是非常的不大丈夫。</p><p>就在我因为懒得开 Dayone 而中断了好多天写日报的时候，我突然发现，Dayone 居然提供 CLI 工具：<a href="http://help.dayoneapp.com/day-one-2-0/command-line-interface-cli" target="_blank" rel="noopener"> CLI for Dayone2 </a></p><p>良心啊！这可给我高兴坏了，虽然 CLI 提供功能很少（只有<strong>新增</strong>…… 没有修改查询删除啥的），但是已经够了~</p><p>工具实现了三个功能：</p><ul><li>可以用 Vim 直接在命令行里写日报啦</li><li>通过使用 Vim 的模板功能，终于可以通过模板新建日记惹（md 格式）</li><li>可以自动在日报结尾添加今天的 Git 提交记录作为一天工作的实锤啦</li></ul><p>工具设置起来稍微有些麻烦，分几个步骤：</p><p>首先需要安装 Dayone2 的 CLI：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /Applications/Day\ One.app/Contents/Resources/install_cli.sh</span><br></pre></td></tr></table></figure><p>然后需要在 .vimrc 里面设置某种文件打开时的模板，把这段话写到 .vimrc 文件的末尾：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autocmd BufNewFile <span class="variable">$YOUR_TMPLATE_FILE_NAME</span> 0r <span class="variable">$PATH_TO_YOUR_TEMPLATE_FILE</span> | autocmd! BufNewFile</span><br></pre></td></tr></table></figure><p>这段代码的意思是在你使用 Vim 打开符合 <code>YOUR_TMPLATE_FILE_NAME</code> 文件名的文件的时候会自动往里写入给定文件的内容。就是通过这个方法来完成 Vim 模板的设定的~ 你可以自己设定你自己需要的模板~~</p><p>然后接下来是打印当天 Git 提交记录的脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env sh</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># receive param as query date</span></span><br><span class="line">query=<span class="variable">$1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># make date string</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$query</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  date=<span class="variable">$query</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  date=`date +%Y-%m-%d`</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># set git workspace</span></span><br><span class="line">workspaces=<span class="variable">$PATH_TO_YOUR_WORKSPACE</span></span><br><span class="line">names=<span class="variable">$YOUR_NAME</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># recurrsively find git log.</span></span><br><span class="line"><span class="keyword">for</span> workspace <span class="keyword">in</span> <span class="variable">$workspaces</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="comment"># get all dirs</span></span><br><span class="line">  repos=`ls <span class="variable">$workspace</span>/`</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span> repoPath <span class="keyword">in</span> <span class="variable">$repos</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">cd</span> <span class="variable">$workspace</span>/<span class="variable">$repoPath</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> <span class="variable">$names</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      logs=`git <span class="built_in">log</span> --after <span class="string">"<span class="variable">$date</span> 00:00"</span> --before <span class="string">"<span class="variable">$date</span> 23:59"</span> --oneline --no-merges --author <span class="variable">$name</span>`</span><br><span class="line">      <span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$logs</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"Found logs @ <span class="variable">$repoPath</span>, commits list below:\n<span class="variable">$logs</span>\n"</span></span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>注意你需要在这个脚本里定义你的 workspace 和你的用户名哈~</p><p>接下来就是把上面的功能合在一起的 shell 脚本，注意这里我们把上面获取 Git log 的脚本命名为 <code>list_git.sh</code> 放到同一个目录下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># ask for emotion</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"今天感觉怎么样？"</span></span><br><span class="line"><span class="built_in">read</span> ANS</span><br><span class="line"> </span><br><span class="line"><span class="comment"># this file name will trigger vim to create a new file with given template</span></span><br><span class="line">vim <span class="variable">$YOUR_TMPLATE_FILE_NAME</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># get daily content</span></span><br><span class="line">CONTENT=`cat <span class="variable">$YOUR_TMPLATE_FILE_NAME</span>`</span><br><span class="line"> </span><br><span class="line"><span class="comment"># get title</span></span><br><span class="line">DATE=`date <span class="string">'+%Y/%m/%d 周%a'</span>`</span><br><span class="line">TITLE=<span class="string">"**工作日报 - <span class="variable">$DATE</span>**"</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># get daily git logs</span></span><br><span class="line">dir=`dirname <span class="variable">$0</span>`</span><br><span class="line">GITLOG=`sh <span class="variable">$dir</span>/list_git.sh`</span><br><span class="line"> </span><br><span class="line"><span class="comment"># save content to dayone2</span></span><br><span class="line">FINAL_CONTENT=<span class="string">"<span class="variable">$TITLE</span>\n&gt; 心情：<span class="variable">$ANS</span> \n\n<span class="variable">$CONTENT</span> \n"</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> -n <span class="string">"<span class="variable">$GITLOG</span>"</span>; <span class="keyword">then</span></span><br><span class="line">  FINAL_CONTENT=<span class="string">"<span class="variable">$FINAL_CONTENT</span> \n**Daily Git log** \n \`\`\`\n<span class="variable">$GITLOG</span>\n\`\`\`\n"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$FINAL_CONTENT</span>"</span> | dayone2 new</span><br><span class="line"> </span><br><span class="line"><span class="comment"># clean tmp file</span></span><br><span class="line">rm <span class="variable">$YOUR_TMPLATE_FILE_NAME</span></span><br></pre></td></tr></table></figure><p>注意这里列出来的两个脚本中均需要你自己替换 <code>$YOUR_TMPLATE_FILE_NAME</code> 为你自己设定的模板文件名哦，不然 vim 不会加载模板的~</p><p>然后就 OK 惹…… 来看看运行效果✧(≖ ◡ ≖✿)：</p><p>dr 是我的 alias，脚本一开始会让你输入今天的心情…………</p><p><img src="http://ojanerta1.bkt.clouddn.com/2017-11-16-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-15%2021.03.53.png" alt=""></p><p>然后会进入 Vim 编辑一下………………</p><p><img src="http://ojanerta1.bkt.clouddn.com/2017-11-16-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-15%2021.05.29.png" alt=""></p><p>保存，然后日报就进 Dayone 啦：</p><p><img src="http://ojanerta1.bkt.clouddn.com/2017-11-16-image2017-11-15%2021_8_50.png" alt=""></p><p>嗯！希望能治好我总忘写日报的病吧………………</p><p>科科</p>]]></content>
    
    <summary type="html">
    
      不是工具不好用，实在是人太懒呐
    
    </summary>
    
      <category term="折腾" scheme="http://blog.kyangc.com/categories/%E6%8A%98%E8%85%BE/"/>
    
    
      <category term="效率" scheme="http://blog.kyangc.com/tags/%E6%95%88%E7%8E%87/"/>
    
      <category term="工具" scheme="http://blog.kyangc.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>使用羊角符号￥的正确姿势</title>
    <link href="http://blog.kyangc.com/2017/05/09/right-way-use-yuan/"/>
    <id>http://blog.kyangc.com/2017/05/09/right-way-use-yuan/</id>
    <published>2017-05-09T23:00:00.000Z</published>
    <updated>2018-03-17T06:12:00.852Z</updated>
    
    <content type="html"><![CDATA[<p>最近写 UI 的时候遇到个蛮有意思的问题，事情是这样的：我要用 TextView 展示一段标识价格的文字，如「￥23333」，这件事本来完全不会往心里去，随手就这么写了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mTvPrice.setText(<span class="string">"￥23333"</span>);</span><br></pre></td></tr></table></figure><p>有毛病吗？没毛病，IDE 里面也显示的好好的：</p><p><img src="http://ojanerta1.bkt.clouddn.com/2017-05-09-WX20170509-230333-2x.png" alt="" title="IDE 显示"></p><p>但是到了手机上就成这个屌样子了：</p><p><img src="http://ojanerta1.bkt.clouddn.com/2017-05-09-Screenshot_2017-05-09-23-43-23-869_com.sankuai.me.png" alt="" title="奇怪的￥符"></p><p>看到没，双横线的人民币符号变成了单横线的人民币符号，喵喵喵？心态有些崩……</p><p><img src="http://ojanerta1.bkt.clouddn.com/2017-05-09-WX20170509-235737-2x.png" alt="" title="喵喵喵"></p><p>不过，喵归喵，问题既然出现了那就一定得想办法解决嗯……那么现在有这么几个问题需要查一下：</p><ol><li>单横线的人民币符号和双横线人民币符号哪个是受官方承认的？</li><li>为什么在 App 上有的地方是双横线，有的地方又是单横线？</li><li>我应该怎么安全的写出正确的双横线人民币符号？</li></ol><p>第一个问题，双横线的人民币符号是受官方承认的，wiki 里人民币的定义：</p><blockquote><p>人民币在 ISO 4217 简称为 CNY（“CN” 一般用于表示中华人民共和国；“Y” 即拼音 Yuan 的首字母，是 “Chinese Yuan” 的缩写），离岸人民币简称为 CNH，不过更常用的缩写是 RMB（Ren Min Bi）；在数字前一般加上 “¥”（取 “YUAN” 的首字母 “Y”，上面加一个 “=” 号）表示人民币的金额。</p></blockquote><p>所以，双横线的确是人民币官方符号，那么这是否代表着单横线的人民币符号有问题呢？非也，在翻阅一些资<del>(zhi)</del>料<del>(hu)</del>之后，笔者发现，单横线的羊角符号其实是一种「习惯性用法」，在国家对人民币符号做标准化之前，这两种符号因字体间差异而处于相当大程度的混用中，在很长一段时间内，各大电商网站在做人民币符号标识时都存在差异。而在国家进行标准化之后，双横线的羊角符号被推荐替代单横线的羊角符号使用。</p><p>OK，暂时线松了一口气，线上的单横线羊角符号暂时还不会导致<del>华哥被开除</del>，那么就是接下来的问题：为什么在 App 中有的时候是单横线有的时候是双横线？</p><p>这个问题在搞懂上面的问题之后就很简单了，单横线其实是全角的双横线羊角符在不同的字体下的一个形式变体——简单地说，这就是个全角的羊角符，而这个全角羊角符在手机系统中只显示一根横线。至于使用羊角符号时，是应该使用全角羊角符还是半角羊角符，知乎里面也有比较清楚地讨论：</p><blockquote><p>因为人民币符号多是与半角阿拉伯数字相邻使用而非在汉字文本流中独自出现，所以建议通常使用其半角版本，以保证货币符号与数字的空间关系及字体设计协调。</p><p>全角人民币符号「￥」只是个历史遗留字符，如今通常不会用到，它和半角人民币符号「¥」也没有语义差异。</p></blockquote><p>话说到这里，必须插一句，网上有一些意见认为，单横线的羊角符号是日元符号，其实这里是个误解，wiki 里日元的定义：</p><blockquote><p>日圆（日语：円〔圓〕／えん〔ゑん〕，日语罗马字：Yen<a href="#">1</a>），亦简作日元，全称为日本圆，货币符号为 ¥，国际标准化组织 ISO 4217 的货币代码为 JPY，是日本的官方货币。其发行制造机构为日本银行，纸币称为日本银行券。</p></blockquote><p>看到没，人民币和日元如果仅论符号，两种货币符号都是￥，他们的区分是通过羊角符之前的拉丁字母区分：CN￥/ JP￥。</p><p>所以，为了纠正 App 里面有碍观瞻的单横线羊角符号就很简单了，全局搜索全角羊角符，替换为半角羊角符即可。</p><p>OK，上面两个问题解决之后，基本整件事就很清楚了——开发者错误的使用了全角羊角符，导致在手机上某些机型的字体显示为了单横线的羊角符。那么如何去避免这件事呢？笔者大致总结了一些方案：</p><ol><li>Mac 下的搜狗输入法在中文输入环境下通过「Shift+4」会输入全角羊角符「￥」，而在英文输入场景下通过「Shift+4」会输入半角美元符「$」所以直接用快捷键输入是不会得到正确结果的。不过如果你用搜狗输入法的话，可以尝试在中文输入环境下键入「rmb」，输入法会自动提示给你正确的半角羊角符「¥」。</li><li>保存一份正确的羊角符，一个生十个，十个生百个……</li><li>定义静态的 StringFormat，把金额当参数输入，输出正确的金额 String</li></ol><p>OK 本文到这里就差不多了，罗里吧嗦的写了不少，全当记录一件蛮有意思的事了嗯</p>]]></content>
    
    <summary type="html">
    
      ￥￥￥￥￥￥￥￥￥￥￥￥
    
    </summary>
    
      <category term="技术" scheme="http://blog.kyangc.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://blog.kyangc.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>BitmapFactory.decodeResource 原来只能加载「图片格式」的资源啊……</title>
    <link href="http://blog.kyangc.com/2017/05/03/problem-in-decode-resource/"/>
    <id>http://blog.kyangc.com/2017/05/03/problem-in-decode-resource/</id>
    <published>2017-05-03T10:00:00.000Z</published>
    <updated>2018-03-17T06:12:00.852Z</updated>
    
    <content type="html"><![CDATA[<p>今天在用公司提供的网络图片加载控件进行开发的时候，因为图片上有个蒙层的需求，所以很自然的调用了这个图片加载控件的 <code>setOverlay(int resId)</code>的方法，用来加载一个事先定义在<code>.xml</code>中的方形 Shape。</p><p>代码很简单，吭哧吭哧的写好之后插电运行——啪，崩崩崩。顿时懵逼了，不至于吧，写个这么简单的数据绑定逻辑都能蹦蹦蹦？赶紧拉报错堆栈来看，唔，一个NPE的错误->一个 Bitmap 为空->传入的这个 Overlay 的 Bitmap 为空->嗯……那就是这句话得到的 Bitmap 为空咯：</p><pre><code>overlay = BitmapFactory.decodeResource(getContext().getResources(), overlayResId, options)</code></pre><p>我凭实力传入的ResId凭什么解析不出Bitmap！但是它还真的就不会返回 Bitmap，我们看看他的代码段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Synonym for opening the given resource and calling</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #decodeResourceStream&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> res   The resources object containing the image data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id The resource id of the image data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> opts null-ok; Options that control downsampling and whether the</span></span><br><span class="line"><span class="comment">     *             image should be completely decoded, or just is size returned.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The decoded bitmap, or null if the image data could not be</span></span><br><span class="line"><span class="comment">     *         decoded, or, if opts is non-null, if opts requested only the</span></span><br><span class="line"><span class="comment">     *         size be returned (in opts.outWidth and opts.outHeight)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">decodeResource</span><span class="params">(Resources res, <span class="keyword">int</span> id, Options opts)</span> </span>&#123;</span><br><span class="line">        Bitmap bm = <span class="keyword">null</span>;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> TypedValue value = <span class="keyword">new</span> TypedValue();</span><br><span class="line">            is = res.openRawResource(id, value);</span><br><span class="line"></span><br><span class="line">            bm = decodeResourceStream(res, value, is, <span class="keyword">null</span>, opts);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">/*  do nothing.</span></span><br><span class="line"><span class="comment">                If the exception happened on open, bm will be null.</span></span><br><span class="line"><span class="comment">                If it happened on close, bm is still valid.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (is != <span class="keyword">null</span>) is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bm == <span class="keyword">null</span> &amp;&amp; opts != <span class="keyword">null</span> &amp;&amp; opts.inBitmap != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Problem decoding into existing bitmap"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bm;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>确实啊，人家白纸黑字的写了，这个方法要么返回一个从原始图片文件得到的 Bitmap，否则返回 null，而且传入的 Option 参数也是对应的类似采样率这样的图片编码相关的需求——这段代码的的确确只能用来将「<strong>原始的图片文件</strong>」加载为 Bitmap，是我用错了资源类型，锅在我自己脑袋上。</p><p>但是光是找到问题还是不够的，得好好想想这个问题：为什么我会在一开始看不出这个问题——对 Bitmap 和 Drawable 概念的混淆是我没能及时定位这个问题的最大原因。Bitmap 是一个比 Drawable 更加底层的概念，它对应的是每个像素点在内存里的数据，而 Drawable 则是一个抽象的概念，他是 Bitmap 的超集，一个Drawable 对象可能来自于 xml 定义、来源于 .jpg/.png 文件、来源于 Bitmap。</p><p>但是这里最大的锅还是在平台——平台提供的<code>setOverlay(int resId)</code>方法显然并没有对于这些不同的 Res 作区分，默认其均为 .jpg/.png 文件的资源，并使用加载 Bitmap 的方法去加载这些资源，而调用者对于此一无所知，既没有方法名上的提醒，也没有文档的提醒，自然在使用时会出现问题。</p><p>这里还是总结一下两个经验教训吧：1. 对于 Bitmap 和 Drawable 的基础概念需要有明确的辨识；2. 对于 API 设计需要考虑调用者的使用情景，不能想当然的给出方法，如果确实如此，则需要给出详细的文档作参考。</p>]]></content>
    
    <summary type="html">
    
      啊，是真的
    
    </summary>
    
      <category term="技术" scheme="http://blog.kyangc.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://blog.kyangc.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>利用Travis-CI 更新博客</title>
    <link href="http://blog.kyangc.com/2017/03/16/update-blog-by-travis/"/>
    <id>http://blog.kyangc.com/2017/03/16/update-blog-by-travis/</id>
    <published>2017-03-16T15:20:16.000Z</published>
    <updated>2018-03-17T06:12:00.852Z</updated>
    
    <content type="html"><![CDATA[<p>这几天在了解travis-ci的时候偶然发现Hexo的作者正在用它更新Hexo的官方网站，仔细一想还真的很适合——大部分利用Hexo搭建的技术博客基本都依托于Github.io，而 Travis-CI 在面向 Github 上的开源项目时是免费的，而且 travis-ci 的机制也决定了它在更新博客push内容这一点上是有得天独厚的优势的……</p><p>嘛，其实整个过程都很简单，本来还打算写一写，不过又觉得其实过程真的大同小异，下面给两个链接作为记录好啦。</p><p><a href="https://zespia.tw/blog/2015/01/21/continuous-deployment-to-github-with-travis/" target="_blank" rel="noopener">用 Travis CI 自動部署網站到 GitHub - Hexo 作者 Blog</a><br><a href="https://xuanwo.org/2015/02/07/Travis-CI-Hexo-Autodeploy/" target="_blank" rel="noopener">使用Travis CI自动部署Hexo</a></p><p>嗯。本文就是本博客利用 Travis-CI 部署的第一篇博客啦。科科。</p>]]></content>
    
    <summary type="html">
    
      论 CI 在博客领域的应用……
    
    </summary>
    
      <category term="技术" scheme="http://blog.kyangc.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Travis-ci" scheme="http://blog.kyangc.com/tags/Travis-ci/"/>
    
  </entry>
  
  <entry>
    <title>新安装App启动后Home键回到桌面后再次启动App时会再次启动入口页面的Bug追踪记录</title>
    <link href="http://blog.kyangc.com/2017/01/20/launch-bug-record/"/>
    <id>http://blog.kyangc.com/2017/01/20/launch-bug-record/</id>
    <published>2017-01-20T15:00:00.000Z</published>
    <updated>2018-03-17T06:12:00.852Z</updated>
    
    <content type="html"><![CDATA[<p>测试同学近日在测试中发现了这么一个Bug，复现步骤如下：</p><ol><li>打开应用</li><li>任意开启一个页面</li><li>Home键回退到Launcher</li><li>重装应用</li><li>打开应用</li><li>任意开启一个页面</li><li>Home键回退到Launcher</li><li>点击应用图标启动应用</li><li>Bug出现了：<strong>此时应用并没有如预期般直接将Task带到前台，而是开屏页一闪而过，然后就回到了应用的主页面</strong></li></ol><p>我们知道，每次发起Intent导致新创建Task的时候，该Task会记录该Intent的信息；如果后续有一个新的Intent出现并与该Task的启动Intent完全一致（启动类，action、category等等全部一样，不可多项也不可缺少），那么该Intent并不会触发Activity的新建与启动，而只会将已经存在的Task移到前台。</p><p>那么为什么会出现如bug所述那样的问题呢？下面按照Bug浮现步骤来捋一捋：</p><blockquote><p>首先定义一下，L为Launcher，P1为开屏页，P2为主页面，P3为任意一个其他页面。不同task用|分割，相同task的页面用/分割。</p></blockquote><ol><li>打开应用：L -> L|P1|P2 -> L|P2</li><li>任意开启一个页面：L|P2/P3</li><li>Home键回退到Launcher：P2/P3|L</li><li>重装应用：L</li><li>打开应用：L -> L|P1|P2 -> L|P2</li><li>任意开启一个页面：L|P2/P3</li><li>Home键回退到Launcher：P2/P3|L</li><li>点击应用图标启动应用，Bug复现</li></ol><p>OK，这里我们看到的现象是，一个新的Task被创建了，并且新的页面立刻就销毁了，然后由于以singleTask启动主页面的时候发现已经存在了这个Task，于是把原来的Task立刻带到了前台，并出栈了所有栈顶的页面：</p><ol><li>启动：P2/P3|L -> P2/P3|L|P1</li><li>以singleTask启动新的P2，退出P1，将原有的P2/P3带到前台并将P3出栈：P2/P3|L|P1 -> L|P2</li></ol><p>回想我们之前提到过的一个很重要的一点：如果创建Task的Intent和某个期望启动应用的Intent一模一样，那么该Task会被带到前台，否则会重新创建Task。那么这里会不会是在这里出问题呢？</p><p>我仔细回想了Bug的复现步骤，发现在「5. 打开应用」这一步中遗漏了一个非常重要的细节：<strong>我们似乎是在安装完应用之后直接点击「打开应用」启动的应用</strong> —— 问题就出在这里，<strong>「打开应用」对应的Intent和Launcher中的Intent其实是不一致的</strong>——至少在某些方面是无法匹配的，那么通过这种方式启动的Task和点击Launcher图标启动的Task自然是无法相容了，出现Bug中的现象也就解释的通了。</p><p>为了验证想法的正确性，我再次重复了一次上述的步骤，只不过在第五步「5. 打开应用」中，并没有直接点击「打开应用」，而是<strong>退回到桌面，点击Launcher中应用的icon来启动应用</strong>。果然，这一次没有再发生之前的问题。</p><p>那么，我们该如何在应用中防止这种状况的发生呢？在网上寻求解答的时候发现了<a href="http://www.cnblogs.com/net168/p/5722752.html" target="_blank" rel="noopener">这篇文章</a>，他也遇到了和我一样的问题，而他的解决思路则是在开屏页另外发起一个与Launcher相同的Intent请求启动应用。这个方法是否有效以及有没有副作用这里不做探讨也没有尝试过，如果有读者（哦我的文章没有读者）感兴趣的话，可以自己试一试嗯。</p><p>这是次很神奇可能也很微妙的Bug复现及追踪记录，这个问题并不算什么大问题，但是在追踪这个问题的过程中也让我对于App的启动方式有了新的理解，所以这里稍微记录一下，留以存档。</p>]]></content>
    
    <summary type="html">
    
      这个Bug竟然需要用这么长的标题来描述
    
    </summary>
    
      <category term="技术" scheme="http://blog.kyangc.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://blog.kyangc.com/tags/Android/"/>
    
      <category term="Bug" scheme="http://blog.kyangc.com/tags/Bug/"/>
    
  </entry>
  
  <entry>
    <title>你真的会使用 Scheduler.io() 吗？</title>
    <link href="http://blog.kyangc.com/2017/01/16/scheduler-io-error/"/>
    <id>http://blog.kyangc.com/2017/01/16/scheduler-io-error/</id>
    <published>2017-01-16T10:00:00.000Z</published>
    <updated>2018-03-17T06:12:00.852Z</updated>
    
    <content type="html"><![CDATA[<p>最近堆糖6.7.0版本正在准备上线，在堆糖最近的灰度版本中我们观测到了许多不正常的OOM——来自于各种方面的OOM都有，非常奇怪。有很多代码都是没有改动过的，但是这次灰度版本中却发现因为OOM的关系FC了。不过由于在6.6.0到6.7.0两个版本中间被我改动了近3W行代码，所以顿时浑身冷汗，担心是不是在某个未知的角落的改动造成了问题。</p><p>光靠想不起作用，打开Fabric，老老实实一条条崩溃记录的检查吧。第一遍看下来，没什么头绪，发现的唯一的特征是多数OOM发生在RxJava的调用过程中——但是依然有少量OOM和RxJava毫无关联。回想了一下，这个版本似乎并没有升级过RxJava的依赖版本，问题应该不是出在RxJava本身。</p><p>继续追崩溃日志，有一个异常点突然引起了我的注意——在这些所有的崩溃记录中，线程数都异常的高：</p><p><img src="http://ojanerta1.bkt.clouddn.com/2017-01-16-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-01-16%2021.26.57.png" alt="" title="超高的线程数"></p><p>Android/Java虚拟机的线程资源是有限的，在这么高的线程数之下，这个程序基本也活不了太久了……<a href="http://jzhihui.iteye.com/blog/1271122" title="这篇文章" target="_blank" rel="noopener">这篇文章</a>大致讲述了Java虚拟机的线程资源与堆栈大小之间的关系，有兴趣的可以看一下。</p><p>OK，OOM的根源基本定位到了——超高的线程分配数是罪魁祸首——那么这些超高的线程数是怎么来的呢？我们继续研究报错堆栈。很快，在报错栈的线程列表中，我们发现了大量名为「RxIoScheduler-xx」的线程：</p><p><img src="http://ojanerta1.bkt.clouddn.com/2017-01-16-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-01-16%2021.41.14.png" alt="" title="超多的 RxIoScheduler-xx 线程"></p><p>看到这里，熟悉RxJava Scheduler的使用的同学一定联想到了线程调度符Schedulers.io()，在处理异步的IO动作时，我们正是通过这个将工作调度到IO线程中，在RxJava中的具体实现则是通过一个类似CachedThreadPoolExecutor的线程池来承载业务、分配线程，这个线程池的线程数会随需求的增减动态改变。</p><p>到这里不难看出，疯狂增长的线程数肯定与这个IO调度有关，但是为什么会出现这种状况？IO操作符的使用难道哪里出了问题？</p><p>StackOverflow一下，果然，有个哥们和我一样遇到了同样的问题，而他的解决方式则是：<strong>在完成异步操作之后，显式的调用<code>subscriber.onComplete()</code>来终结这次Subscription</strong>。经过实践，确实通过在所有耗时操作结束之后调用onComplete方法，能够有效地释放线程资源，线程数也恢复了正常。</p><p>知道怎么做是不够的，为了搞清楚这究竟是怎么一回事，我们接下来从源码部分简单的看看Scheduler究竟做了些什么：</p><p>首先我们从入口方法 subscribeOn(Scheduler scheduler) 开始：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">subscribeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> ScalarSynchronousObservable) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((ScalarSynchronousObservable&lt;T&gt;)<span class="keyword">this</span>).scalarScheduleOn(scheduler);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> create(<span class="keyword">new</span> OperatorSubscribeOn&lt;T&gt;(<span class="keyword">this</span>, scheduler));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scalarScheduleOn 部分的我们忽略，这个方法实际上是利用Scheduler对象以及原本的Observable对象，重新生成了一个Observable对象，下面看看在构造OperatorSubscribeOn的时候做了些什么事：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OperatorSubscribeOn</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">OnSubscribe</span>&lt;<span class="title">T</span>&gt;</span></span><br></pre></td></tr></table></figure><p>OperatorSubscribeOn 实现了 OnSubscribe 接口，实际上就是另一层最初的OnSubscribe的封装，我们主要看看对应的call(Subscriber subscriber)方法中做了些什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建一个worker对象</span></span><br><span class="line">    <span class="keyword">final</span> Scheduler.Worker inner = scheduler.createWorker();</span><br><span class="line"><span class="comment">//注册这个worker对象</span></span><br><span class="line">    subscriber.add(inner);</span><br><span class="line"><span class="comment">//worker对象将本操作符之前的所有操作打包，放入其所在的线程池(io)中等待执行</span></span><br><span class="line">    inner.schedule(<span class="keyword">new</span> Action0() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread t = Thread.currentThread();</span><br><span class="line"><span class="comment">//将原本的subscriber重新组装 - 在这次封装中包含了对于worker对象的取消订阅操作</span></span><br><span class="line">            Subscriber&lt;T&gt; s = <span class="keyword">new</span> Subscriber&lt;T&gt;(subscriber) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line"><span class="comment">//注意！这里只调用了onNext，并没有取消对于源的订阅！这也是为什么只调用onNext不调用onComplete或onError不会取消订阅者对于发送者的订阅的原因</span></span><br><span class="line">                    subscriber.onNext(t);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        subscriber.onError(e);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//取消了订阅</span></span><br><span class="line">                        inner.unsubscribe();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        subscriber.onCompleted();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//取消了订阅</span></span><br><span class="line">                        inner.unsubscribe();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProducer</span><span class="params">(<span class="keyword">final</span> Producer p)</span> </span>&#123;</span><br><span class="line">                    subscriber.setProducer(<span class="keyword">new</span> Producer() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">if</span> (t == Thread.currentThread()) &#123;</span><br><span class="line">                                p.request(n);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                inner.schedule(<span class="keyword">new</span> Action0() &#123;</span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                        p.request(n);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将重新组装之后的subscriber重新用源observable订阅起来</span></span><br><span class="line">            source.unsafeSubscribe(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码我们看到，在新生成的OnSubscribe对象中，当call方法被调用时，Scheduler对象会生成一个worker对象，作用是将该操作符之前的所有动作一起打包放到该worker所在的线程池中执行任务，并且worker对象也实现了subscription接口，可以用于取消本次任务订阅。</p><p>可以看到，在向worker所在的线程池发出任务的时候，实际上是重新封装了一个Subscriber，并让该Subscriber重新订阅发射源，在onNext方法中并没有将该worker对象取消订阅，只在onComplete方法和onError方法中调用了worker对象的取消订阅相关的代码——这也是为什么在使用该操作符时如果不手动处理订阅或显式调用onComplete就无法完成自动取消订阅的原因。</p><p>其实在worker对象的生成、io线程的底层CachedThreadPool实现以及worker对象的取消订阅这些方法也有很多内容，不过不属于本篇内容，这里就不做过多叙述，有兴趣的读者（我知道这文章没啥读者- -）可以自己读读源码。讲道理，RxJava的源码算是我读过的代码里面相当恶心且绕且难懂的代码了……要读下去真的需要一些耐心……</p><p>言归正传，最终我们得出了这么一个结论：</p><blockquote><p>如果不是直接使用类似于<code>just</code>、<code>from</code>、<code>zip</code>等等已经封装好的操作符，而是直接新建<code>onSubscribe</code>对象，自己处理<code>subscriber</code>的<code>onNext</code>、<code>onError</code>等操作的话，最好是能做到在正确返回数据时调用<code>onNext</code>，在错误时调用<code>onError</code>，并且保证在所有动作处理结束之后能够调用<code>onComplete</code>动作结尾。</p></blockquote>]]></content>
    
    <summary type="html">
    
      老司机还是翻车了
    
    </summary>
    
      <category term="技术" scheme="http://blog.kyangc.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://blog.kyangc.com/tags/Android/"/>
    
      <category term="RxJava" scheme="http://blog.kyangc.com/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>堆糖Android首页的列表性能优化记录</title>
    <link href="http://blog.kyangc.com/2017/01/15/list-opt/"/>
    <id>http://blog.kyangc.com/2017/01/15/list-opt/</id>
    <published>2017-01-15T10:00:00.000Z</published>
    <updated>2018-03-17T06:12:00.852Z</updated>
    
    <content type="html"><![CDATA[<p>在堆糖6.7.0版本中，首页经过了较大的改版，从原有的单页面列表页改为由8个横向滑动的页面经由ViewPager承载，每个页面都是一个包含8种cell类型的列表页。在某些cell中还包含了占据较高面积比例的图片，而且这些图片的展示对于清晰度还有需求——毕竟堆糖图片社交出身，不同于普通的新闻客户端，堆糖对于列表项中的图片精细度还是有些追求的。</p><p>小林是这次首页改版业务的开发负责人，接到任务之后很快就基本完成了页面开发——堆糖有一套通用的List页面实现，集成了状态控制、下拉刷新、上拉加载等列表页通用功能，开发者仅需要对于每个cell的view进行开发即可，效率很高。</p><p>然而，在后端数据就绪开始联调的时候却发现列表存在较为严重的卡顿状况。首页是一个应用的门脸，是用户使用频次最高、操作最频繁的部位，这种流畅度是不可接受的。于是我开始着手review小林的代码期以提高列表页面的浏览流畅度。</p><h1 id="追踪高开销的绑定操作"><a href="#追踪高开销的绑定操作" class="headerlink" title="追踪高开销的绑定操作"></a>追踪高开销的绑定操作</h1><p>列表项的创建、绑定数据操作是主要的耗时来源，review中也是从这里着手开始分析耗时操作。由于堆糖所有列表页都继承于同一个实现，因此我们可以很轻松的追踪到我们在绑定列表数据的时候究竟耗时情况是怎么样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bind data</span></span><br><span class="line"><span class="keyword">long</span> startTime = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (BuildConfig.DEBUG) &#123;</span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">&#125;</span><br><span class="line">setupItem(holder.itemView, ((ItemVH) holder).type, position, data);</span><br><span class="line"><span class="keyword">if</span> (BuildConfig.DEBUG) &#123;</span><br><span class="line">    P.d(String.format(Locale.getDefault(), <span class="string">"Bind data cost %d ms, Holder type= %d"</span>,(System.currentTimeMillis() - startTime), ((ItemVH) holder).getItemType()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里setupItem是一个抽象类，是所有item绑定数据的入口方法，通过这段代码，我们在Logcat中立刻就定位到了耗时非常严重的几个item类型。</p><h1 id="工作线程提前处理数据，避免主线程重复操作数据"><a href="#工作线程提前处理数据，避免主线程重复操作数据" class="headerlink" title="工作线程提前处理数据，避免主线程重复操作数据"></a>工作线程提前处理数据，避免主线程重复操作数据</h1><p>我们首先定位到了这么一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (view <span class="keyword">instanceof</span> CommonAdItemView) &#123;</span><br><span class="line">    CommonAdItemView commonAdItemView = (CommonAdItemView) view;</span><br><span class="line">    commonAdItemView.setData(GsonUtil.parseJson(data.getEntity(),</span><br><span class="line">HomeItemModel.NormalAdModel.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后端在返回的数据实体里针对不同的数据类型返回了不同类型的真实数据实体entity，客户端需要本地根据数据实体提供的类型参数二次解析为特定的可用的数据实体绑定进item。</p><p>但是在这段代码中我们看到，每一次绑定操作都调用了一次Gson的反序列化操作以生成数据实体——Json的解析与对象的拼装是一件非常耗时的事情，涉及到的IO、反射都是重性能开销操作，这里不仅错误的在主线程绑定数据时进行Json解析，而且没有做任何缓存处理，同一段数据会被不断地反序列化——哪怕这段数据实体已经被反序列化过了。</p><p>正确的做法应该是在网络框架返回数据之后，在工作线程将数据实体按照对应的规则解析并保存到相应的对象中返回，在使用的过程中无需再做任何的反序列化操作了。</p><p>处理完这一点之后，发现确实列表在加载时的卡顿感减轻了不少，但是在快速滑动列表的时候依然会出现丢帧、跳页的现象，没关系，我们的优化才刚刚开始。  </p><h1 id="谨慎分配高占用对象"><a href="#谨慎分配高占用对象" class="headerlink" title="谨慎分配高占用对象"></a>谨慎分配高占用对象</h1><p>在代码中我们发现了这么一段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (blogModels.size() &gt;= <span class="number">3</span> ? <span class="number">3</span> : blogModels.size()); i++) &#123;</span><br><span class="line">    ……</span><br><span class="line">    AlbumImageView imageView = <span class="keyword">new</span> AlbumImageView(getContext());</span><br><span class="line">    imageView.loadImageWithDp(blogModels.get(i).getPhotoUrl(), <span class="number">112</span>, <span class="number">112</span>);</span><br><span class="line">    binding.layoutImgs.addView(imageView);</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的原意是，在一个线性布局容器中根据返回图片数量的多少将图片控件生成并添加到线性布局中。这段代码如果不是在列表项中，是没有任何问题的，很灵活也很高效，但是在列表项中这样的做法就存在很严重的问题了——在每一次绑定数据的时候都经历了：清空线性布局中的图片控件、新建若干图片控件、部署若干图片控件、图片控件载入图片若干步步骤，其中清空布局并重新部署控件会引起控件的重新绘制，这是性能开销其一；其二，每次都新建图片控件并在其上载入图片，既付出了额外的性能时间消耗，更大大加重了内存负担——内存占用飙升、GC被频繁触发——所以，在item的数据绑定过程中，大对象的分配、布局的更新重绘等操作一定要谨慎，能够重用的一定要重用，不需要刷新布局的情况下尽可能低性能开销的数据绑定方式。</p><h1 id="优化列表项的布局层级"><a href="#优化列表项的布局层级" class="headerlink" title="优化列表项的布局层级"></a>优化列表项的布局层级</h1><p>绑定数据部分的问题基本被排查完毕之后，似乎setData部分已经从逻辑上没什么问题了，列表的加载现在的确相对之前顺滑了一些，渲染时间直方图也没那么吓人了，但从主观使用角度上看，还是显得有些卡顿，从客观的渲染时间直方图上看来，主线程上的渲染耗时还是存在优化的空间，于是此时我们开始检查View的渲染层级问题。</p><p>果然，在自定义View的时候，代码中采用的是组合式的定义方法，继承自一些ViewGroup，将定义好的xml文件inflate进该布局。但是在布局文件的定义中并没有使用merge标签，这也导致了在所有的item上都存在一层多余的布局。</p><p>与此同时，代码中多次使用了线性布局的嵌套来完成一些复杂控件的布局，然而实际上这些布局并没有那么高的灵活度需求，直接使用相对布局完成控件平铺摆放实际上已经达到了设计要求。</p><p>针对以上两点，我们也针对性的对布局文件进行了调整，很多item缩减了至少两层视图层级，这无疑也提升了view的渲染速度。</p><h1 id="检查错误的图片加载操作"><a href="#检查错误的图片加载操作" class="headerlink" title="检查错误的图片加载操作"></a>检查错误的图片加载操作</h1><p>处理完这上述几点之后，列表的滑动卡顿感得到了一定程度的缓解，但是我们依然在列表加载大量图片的时候感受到了深深地卡顿感，于是我们将矛头转向了图片加载相关的处理实现上去寻求解决方案。</p><p>堆糖在加载网络图片的时候，CDN会根据请求末尾附的图片缩略/裁切规则返回最适合当前控件尺寸的图片，因此，在编写加载网络图片的代码时有一项约定，即开发者必须将待加载图片的控件实际宽高像素值传入图片加载方法作为方法参数，以此加载到最适合当前控件的图片，避免了图片过大带来的内存问题。</p><p>这里我们插一句题外话——为什么要显式的对加载图片的宽高进行设定？让图片控件自己获知其宽高难道不行吗？毕竟在每个地方都传入参数还是很烦人的，我只需要传入一条图片的原始url就能正确的加载出图片难道不是美滋滋？</p><p>这个问题我们也曾经认真的思考过、试验过，但是最终还是放弃了，原因有以下两点：</p><p>首先，自动获取控件的大小不是做不到，有很多方法可以完成，但是要么需要通过在消息队列队尾postRunnable来实现，要么需要手动设置ViewTreeObserver监听并手动取消监听来实现——前一种方法会造成图片加载在刚开始的时候有延迟，后一种方案在某些机型上会产生无限循环调用该方法的问题，所以最终都没有采纳。</p><p>第二，即便我们能正确、快速、无性能消耗的获取到控件的大小——这种方式依然有一个最致命的缺陷摆在我们面前：我们永远只有在获取到图片控件实际大小之后才能发出load图片的请求——实际上load图片和图片控件渲染到屏幕上是两个并行的过程，我完全可以向图片框架发出加载图片的请求的同时将图片控件布局到屏幕中，并在图片控件布局到屏幕上之后将根据图片加载框架的图片返回情况将图片内容渲染上去，也就是说，如果我们采用自动获取图片控件大小的方式加载图片，我们永远只能将「获取图片控件宽高」和「加载图片」这两个步骤串行执行，这是绝对无法接受的。</p><p>事实上，开发者在完成加载图片的代码写作的时候，在绝大多数情况下对于图片控件的大小都是可知的，无论是像素值还是DP值，都可以通过简单的计算得到。在开发过程中增加这种并不会为开发者带来太大负担的约定，对于整个应用的图片加载性能的提升却是显著的。</p><p>OK，话说回正题，在检查图片是否加载正确这一点时，我首先利用mitmproxy抓取了加载这个列表时加载的图片url，在分析图片url的时候，发现某些图片url返回的图片尺寸出奇的高，这是很不正常的一件事，首页列表项中的图片大小实际上只有300*300左右的大小，但是竟然有些url返回的图片大小超过了1000*1000像素。于是我开始检查加载图片的相关代码，果然，在应该传入控件px值的地方，我们错误的调用了应该传入dp值的方法，于是加载的实际大小尺寸几乎是原本尺寸的三倍。</p><p>将这些方法修正之后，首页的卡顿得到了巨大的缓解，抖动的内存终于平复了下来。</p><h1 id="在肉眼可接受范围内降低加载图片的精度"><a href="#在肉眼可接受范围内降低加载图片的精度" class="headerlink" title="在肉眼可接受范围内降低加载图片的精度"></a>在肉眼可接受范围内降低加载图片的精度</h1><p>俗话说得好，开发是很简单的，优化是无止境的，难道首页的体验优化就到此为止了吗？当然不。实际上，在完成上述多个地方的优化之后，首页的卡顿感已经减轻了许多了，只是在一些相对低端的手机上，列表的滑动体验依然有继续优化的空间。</p><p>我们相继研究了今日头条、网易新闻、腾讯新闻等等类似的客户端的列表滑动表现，其中今日头条的列表性能表现令我们深感意外——在有许多图片的情况下依然保持着相当高的顺滑度，那么他们是怎么做到的呢？在注意到头条新闻配图似乎都有那么一点点糊的这一点之后，我们对今日头条列表加载时载入的图片进行了分析。果然，头条在载入图片的时候并没有完全按照控件大小去一比一的加载对应分辨率的图片，而是选择加载相同比例，但是对于分辨率进行缩减之后的图片。什么意思呢？就是说，一个空间大小为300*300像素的图片控件，只对应的请求120*120的图片。</p><p>这样做的好处是显而易见的，首先，小图片传输速率快，能够更快的从服务器获取到本地；其次，小图片在解码效率、渲染时间、内存占用上也相对于一比一的大图更加高效；最后，适度的降尺寸加载图片实际上并不会影响到用户对于图片的观感。因此，在产品认可的情况下，适度的降低列表项图片的显示质量，既可以提升图片加载速度，又可以降低CDN的流量消耗，是个很不错的优化思路。</p><h1 id="试试看滑动的时候不加载图片呢？"><a href="#试试看滑动的时候不加载图片呢？" class="headerlink" title="试试看滑动的时候不加载图片呢？"></a>试试看滑动的时候不加载图片呢？</h1><p>在降低图片精度的同时，我们也尝试了与微博相似的做法——在列表滑动的时候不载如图片。在fresco框架中实现这一点并不难，我们只需要在 Recycler的ViewOnScrollListener中做如下控制即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScrollStateChanged</span><span class="params">(RecyclerView recyclerView, <span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onScrollStateChanged(recyclerView, newState);</span><br><span class="line">    <span class="keyword">if</span> (newState == RecyclerView.SCROLL_STATE_SETTLING</span><br><span class="line">            || newState == RecyclerView.SCROLL_STATE_DRAGGING) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Fresco.getImagePipeline().isPaused()) &#123;</span><br><span class="line">            Fresco.getImagePipeline().pause();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Fresco.getImagePipeline().isPaused()) &#123;</span><br><span class="line">            Fresco.getImagePipeline().resume();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做确实能够让列表如飞一般的滑动，但是有个很重要的问题也同时存在：当列表停止滑动之后需要等一小段时间图片才会慢慢地加载出来，这一点在跟产品聊过之后被很强硬的否定了——其实也可以理解，堆糖毕竟不是一个真正的「信息流」应用，用户在使用内容流列表的时候，对于内容的呈现质量的要求其实并不算低。太长时间的等待加载图片对于用户的体验其实是种损害。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，基本上首页的列表相关的优化已经结束了，从一开始的卡到飞起，到现阶段基本稳定在16ms的渲染延时基线下，堆糖的首页优化也暂时告一段落。本文中提到的若干列表优化的方法和思路是今后进行列表项开发时必须时时刻刻牢记在脑海中的principle，本文也作为一次我在列表性能优化方面的体会的总结。</p>]]></content>
    
    <summary type="html">
    
      老生常谈的列表性能优化，这里是一次来自堆糖的实践
    
    </summary>
    
      <category term="技术" scheme="http://blog.kyangc.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://blog.kyangc.com/tags/Android/"/>
    
      <category term="List" scheme="http://blog.kyangc.com/tags/List/"/>
    
      <category term="性能" scheme="http://blog.kyangc.com/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>使用RxJava.combineLatest时犯的错误总结</title>
    <link href="http://blog.kyangc.com/2017/01/14/rxjava-combinelatest/"/>
    <id>http://blog.kyangc.com/2017/01/14/rxjava-combinelatest/</id>
    <published>2017-01-14T23:00:00.000Z</published>
    <updated>2018-03-17T06:12:00.852Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做页面开发的时候遇到这么个问题：我在一个页面同时请求了3条API，通过CombineLatest进行组装，返回一个合成之后的结果用于UI展示。但是在实际使用过程中，我们发现，API正常的返回了数据，但是List的数据绑定发生了两次。经过排查，发现问题出来对于CombineLatest操作符的理解错误上：我错误的认为「CombineLatest会将所有传入的Observable通过FunN组合后返回一个结果」。实际是怎样的呢？我们来看看官方文档中的描述：</p><blockquote><p>Combines a list of source Observables by emitting an item that aggregates the latest values of each of the source Observables each time an item is received from any of the source Observables, where this aggregation is defined by a specified function.</p></blockquote><p>以及官方文档里面的流图：</p><p><img src="http://ojanerta1.bkt.clouddn.com/2017-01-14-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-01-15%2000.15.53.png" alt="" title="CombineLatest 操作符"></p><p>所以不管是流图还是文档描述中，都强调了「每次接收都会根据前次source合并出一个结果」，所以其本质上是「把一系列的输入先后合并然后输出合并之后的结果」，而不是我最早理解的「将所有输入源的发射内容一起合并之后返回」。如果要实现我所需求的效果——将多个观测源的输出结果合并之后输出——还是应该老老实实用zip操作符。</p><p>OK，其实如果我在用之前有认真读过这些说明和流图之后应该就不会犯这个错误了，但是这个操作符接受多个Source的重载方法确实很具有迷惑性。</p><p>所以今后在使用一些新的方法、尝试一些新的内容的时候，第一点需要认真的读一下这些方法的文档，大多数成熟稳定技术的文档还是很健全的。第二点是，在使用过程中需要好好地检查输出结果是否符合预期——实际上在两个输入源的状况下，combineLatest的行为是符合我们预期的，但是在多个输入源的状况下，问题就凸显出来了。这个时候就需要我们能够准确的发现问题，然后解决这些问题。</p>]]></content>
    
    <summary type="html">
    
      好好读文档啊少年
    
    </summary>
    
      <category term="技术" scheme="http://blog.kyangc.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://blog.kyangc.com/tags/Android/"/>
    
      <category term="RxJava" scheme="http://blog.kyangc.com/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>几行伪代码解决大多数 View 触摸事件传递的问题</title>
    <link href="http://blog.kyangc.com/2017/01/13/view-touch-event/"/>
    <id>http://blog.kyangc.com/2017/01/13/view-touch-event/</id>
    <published>2017-01-13T10:00:00.000Z</published>
    <updated>2018-03-17T06:12:00.852Z</updated>
    
    <content type="html"><![CDATA[<p>看书的时候总结了一下View触摸事件的传递逻辑。这里用伪代码写写看。</p><p>Activity / Window / ViewGroup 处理触摸事件的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!dispatchTouchEvent(e))&#123;</span><br><span class="line">onTouchEvent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>View 中 dispatchTouchEvent 的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent e)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> onTouch(e) || onTouchEvent(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ViewGroup 中 dispatchTouchEvent 的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent e)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(onInterceptTouchEvent(e))&#123;</span><br><span class="line"><span class="keyword">return</span> onTouch(e) || onTouchEvent(e);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> child.dispatchTouchEvent(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然里面还有各种问题，但是把握好主干总是会让我们在学习这部分知识的时候更加有针对性。</p>]]></content>
    
    <summary type="html">
    
      先抓住主干，再研究细节
    
    </summary>
    
      <category term="技术" scheme="http://blog.kyangc.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://blog.kyangc.com/tags/Android/"/>
    
      <category term="View" scheme="http://blog.kyangc.com/tags/View/"/>
    
  </entry>
  
  <entry>
    <title>Android 热修复技术学习笔记</title>
    <link href="http://blog.kyangc.com/2017/01/08/android-hotfix-note/"/>
    <id>http://blog.kyangc.com/2017/01/08/android-hotfix-note/</id>
    <published>2017-01-08T23:00:00.000Z</published>
    <updated>2018-03-17T06:12:00.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>对于热修复技术的了解、认识从很久之前就开始了。但是因为没有业务上的驱动力，对于许多业内很火热的框架技术只是浅尝辄止的了解了一下，并没有更加深入去了解这些技术。下季度堆糖不出意外会引入热修复框架，这也为我提供了一次去了解、学习热修复相关技术的一次机会。</p><p>这篇文章可能更多的是倾向于「学习笔记」，只是起一个拾遗、拾忆的作用，不会太过深入代码，也不会针对一些具体实现纠结过多，所以有不详细、不确切、含糊不明的地方，还请各位看官（如果有的话- -）拿起手中的 Google 自己去探究吧科科。</p><p>文末附有本文所有参考借鉴过的文章的链接，感谢这些厉害的程序员在这一领域中做出的杰出贡献。</p><h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p>本文不对热修复的概念做过多探讨，简单来讲，不发布新版本即完成对线上应用运行的代码进行更新的操作都能被算作热修复，所以像ReactNative/Weex这些从网页技术衍生来的混合开发技术其实也是一种热修复，只不过这些技术更加倾向于「业务更新」而不是「错误修复」，因此并不在本文的讨论范畴中。</p><p>按照主流的分类方法，Android生态内的热修复方案主要分为两个「流派」，每个流派又有不同的处理问题的思路：</p><ul><li>Native<ul><li>Xpose/AOP - Dexposed</li><li>Native method hook - AndFix</li></ul></li><li>Java<ul><li>Classloader - Qzone/Nuwa/RoocoFix..</li><li>Byte Code Injection - Robust/Instant Run-冷插拔</li><li>Dex replace - Tinker/Instant Run-热插拔</li></ul></li></ul><p>下面我们会对每个「流派」比较有代表性的技术及其背景进行介绍和比较，我们在选择热修复技术的时候主要针对以下几个方面进行比较。</p><h1 id="Native-部分"><a href="#Native-部分" class="headerlink" title="Native 部分"></a>Native 部分</h1><p>主流的Base Native 的热修复方案除了AndFix还活跃在主流的热修复框架中，其余的框架基本都处于欠维护状态。下面我们挑选两个比较有代表性的框架进行简单的介绍和比较：</p><h2 id="Dexposed"><a href="#Dexposed" class="headerlink" title="Dexposed"></a>Dexposed</h2><p>基于Xposed开发的AOP框架，方法级细粒度，来自手淘团队。Xposed需要Root权限，但是对于单个应用而言并不需要Root。其利用 Xposed 框架修改Android Dalvik运行时的Zygote进程，并利用Xposed Bridge hook方法并注入自己的热修复代码，以达到非侵入的runtime修改。</p><p>应用启动时会fork zygote 进程，装载各种class 和invoke各种初始化方法，xposed框架就在这个时候替换了app_process，hook了各种入口级方法，从而实现之后的各种方法前后的拦截。Dexposed的hook并不限制于应用本身的业务代码，任何应用运行时执行的方法都可以进行hook，在绕过一些Android系统本身的Bug这种普通方式很难完成的事情上有着得天独厚的优势。</p><p>不过Dexposed框架因为无法支持ART虚拟机（Xposed不支持ART虚拟机），在ART渐渐成为Android主流虚拟机的现在显然已经不能满足需求，并且该项目目前已经停止维护了。</p><p><img src="http://ojanerta1.bkt.clouddn.com/2017-01-05-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-01-05%2016.20.31.png" alt="" title="Dexposed 支持的系统"></p><h2 id="AndFix"><a href="#AndFix" class="headerlink" title="AndFix"></a>AndFix</h2><p>AndFix是来自Alibaba团队的另一个热修复框架作品，阿里百川的 Hotfix方案就是基于该方案统一工具链修改而来。该框架的原理和Xposed在大范围内对native方法进行hook不同，AndFix只对需要修复的方法进行hook。hook的原理很有意思：</p><p>开发人员对线上问题进行修改，修改完后通过工具检查新代码和问题代码之间的方法差异，并将这些差异信息写入smali文件，并在每个方法前增加注解标注，然后将所有差异信息打包生成dex文件，连同许多安全校验信息一起打包下发到问题客户端。客户端得到补丁信息之后开始在程序开始的时候载入带有修复方法的dex，然后根据dex中注解提供的参数遍历并找到原有dex中需要替换的方法，找到方法之后首先修改需要替换的方法为native方法，然后在native层对这个方法的调用进行hook，将其指向补丁包中的对应方法地址，以此完成对于方法的替换。</p><p><img src="http://ojanerta1.bkt.clouddn.com/2017-01-05-principle.png" alt="" title="AndFix原理"></p><p>具体的代码这里就不贴了，有兴趣的可以点击文末的链接进去仔细阅读。这个方法最大的优点是足够动态，理论上可以不用重启替换所有的方法，修改基本是即时生效的。而缺点也很明显，该方法不能动态的增减类中的字段，对部分机型不支持，修改之后的方法参数类型也有限制，而且同一个方法不能进行多次patch。</p><p>所以AndFix最适用的场景可能还是对于线上突发问题的修复，替换部分问题方法，让用户免于崩溃，至于说新增业务，资源替换，或者是较大规模的修改，可能比较力不从心。不过AndFix的思路真的很有意思，值得学习借鉴。</p><h1 id="Java-部分"><a href="#Java-部分" class="headerlink" title="Java 部分"></a>Java 部分</h1><p>从上面的叙述中我们不难看出，Native层面上的Hotfix其主要的思路还是寻找Java调用与Native调用的结合点，在这种情况下，新增方法、修改资源等难以与Native结合的问题点相对而言就比较无能为力了。在这种状况下，一些Java世界中的热更新框架也渐渐出现在开发者面前。</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>在进行框架介绍之前，可能有一些前置知识需要简单的介绍一下，否则后面的内容将难以理解。</p><h3 id="一个应用是怎样从代码变成手机上运行的程序的？"><a href="#一个应用是怎样从代码变成手机上运行的程序的？" class="headerlink" title="一个应用是怎样从代码变成手机上运行的程序的？"></a>一个应用是怎样从代码变成手机上运行的程序的？</h3><p>分开讲吧，我们先来看看一个可以安装到手机上的.apk文件是怎样构建出来的吧：</p><ol><li>使用aapt打包资源文件，生成 R.java 文件<ul><li>清单文件、资源文件都会被编译，生成唯一ID放入R.java</li></ul></li><li>处理AIDL文件，声称对应的.java文件</li><li>使用Javac编译器编译所有的源代码.java文件，生成JVM使用的.class文件<ul><li>在这一步中如果配置有混淆，那么将使用ProGuard将.class文件中的字节码进行混淆处理。</li></ul></li><li>使用dx将.class文件生成Dalvik虚拟机可执行的classes.dex文件<ul><li>该过程可以将java字节码转换成dalvik字节码，并压缩常量池、消除冗余信息。</li><li>每个dex文件最大方法数为64k，如果应用方法数超过该限制，在应用multidex的应用中，该步骤会生成多个dex</li></ul></li><li>使用apkbuilder把没有编译的资源、编译过得资源、.dex文件打包为一个.apk文件。</li><li>签名</li><li>使用zipalign进行对齐处理，提升访问速度。</li></ol><p>OK，到这里我们就得到了一个可以运行在Android设备上的apk程序包了。众所周知，Android 系统中的应用不同于普通的Java应用运行在JVM上，Android应用程序均运行在Android系统提供的ART/Dalvik虚拟机上，我们在上一步中通过dx生成的dex文件就是dalvik虚拟机接收的字节码文件格式。</p><p>讲到这里我们稍微插入一小段知识：</p><blockquote><p>Dalvik/ART虚拟机和普通的Java虚拟机的差异在哪里？</p><ul><li><p>核心差异：JVM架构是Stack-Based，基于栈的架构，Dalvik虚拟机的架构为Reg-Based，基于寄存器的架构。JVM之所以采用基于栈的架构，是为了更好的适应所有的底层系统，不对处理器的reg数做假设，成为一个真正的「可移植」虚拟机；Dalvik虚拟机基于寄存器的架构执行效率更高，更加适合提前优化，加上手机处理器多为多reg的ARM系统本身也更加适合这种reg-based的虚拟机。</p></li><li><p>由于核心架构的差异，.dex文件的字节码和.class文件的字节码是不一样的，下图可以比较清晰的说明这一点。</p><p><img src="http://ojanerta1.bkt.clouddn.com/2017-01-05-102038a756f731212ebfcec193217c37_b%20-1-.jpg" alt="" title="Dalvik JVM 虚拟机字节码文件差异"></p></li><li><p>JVM中通常会在同一个虚拟机中运行许多程序，而在Dalvik中，则采用了Zygote模式：在Android系统中，应用程序进程都是由Zygote进程孵化出来的，而Zygote进程是由Init进程启动的。Zygote进程在启动时会创建一个Dalvik虚拟机实例，每当它孵化一个新的应用程序进程时，都会将这个Dalvik虚拟机实例复制到新的应用程序进程里面去，从而使得每一个应用程序进程都有一个独立的Dalvik虚拟机实例。Zygote进程在启动的过程中，除了会创建一个Dalvik虚拟机实例之外，还会将Java运行时库加载到进程中来，以及注册一些Android核心类的JNI方法来前面创建的Dalvik虚拟机实例中去。注意，一个应用程序进程被Zygote进程孵化出来的时候，不仅会获得Zygote进程中的Dalvik虚拟机实例拷贝，还会与Zygote一起共享Java运行时库，这完全得益于Linux内核的进程创建机制（fork）。这种Zygote孵化机制的优点是不仅可以快速地启动一个应用程序进程，还可以节省整体的内存消耗，缺点是会影响开机速度，毕竟Zygote是在开机过程中启动的。</p><p><img src="http://ojanerta1.bkt.clouddn.com/2017-01-05-dea144e77ac583b16d7a866ed8d5e891_b.jpg" alt="" title="Zygote模式"></p></li><li><p>也即是说，在Android系统中，有多少个应用在运行，那么就有多少个虚拟机正在运行，而这与JVM单虚拟机多程序的架构相去甚远，但这也是移动设备为了适应小内存、低性能所采取的非常有意义的改变。</p></li><li><p>除了指令集和类文件格式不同，Dalvik虚拟机与Java虚拟机共享有差不多的特性，它们都是解释执行，并且支持即时编译（JIT）、垃圾收集（GC）、Java本地方法调用（JNI）和Java远程调试协议（JDWP）等</p></li></ul></blockquote><p>好，现在我们已经准备好了安装包，接下来，.apk文件是如何安装在Dalvik/ART虚拟机上的？他们又是如何运行的呢？</p><p>首先我们来看安装：当我们安装应用的时候，Dalvik和ART会采取不同的方式去优化加载到本地的dex文件：</p><ul><li>Dalvik 环境下，安装服务PackageManagerService会通过守护进程installd调用一个工具dexopt对打包在APK里面包含有Dex字节码的classes.dex进行优化，优化得到的文件保存在/data/dalvik-cache目录中，并且以.odex为后缀名，表示这是一个优化过的Dex文件。</li><li>ART 环境下同样安装服务PackageManagerService会通过守护进程installd调用另外一个工具dex2oat对打包在APK里面包含有Dex字节码进翻译。这个翻译器实际上就是基于LLVM架构实现的一个编译器，它的前端是一个Dex语法分析器。翻译后得到的是一个ELF格式的oat文件，这个oat文件同样是以.odex后缀结束，并且也是保存在/data/dalvik-cache目录中。<br>无论是Dalvik VM环境下的.odex文件，还是ART环境下的.odex文件，最终在运行程序时都需要将DEX文件载入进虚拟机，只不过DVM状态下，可能会通过Interpreter（解释器）或者JIT去把字节码转换成机器码最终执行，而在ART状态下，这些字节码会在安装时被AOT的转换成机器码存在同样以.odex为后缀的OAT文件中，使用时就不再在运行时去解释了。在程序运行时，程序依赖的系统代码会连同程序的代码一起生成一个OAT文件加载进虚拟机，所以一个OAT文件内部其实可能会含有多个DEX文件的。如果运行时有加载额外的dex文件，其同样会以该方式生成oat文件加载进ART虚拟机。</li><li>在AndroidN中，ART采取了一种更加「聪明」的方式去处理——混合编译，简单来讲，就是JIT、解释、AOP三种方式共存，其中的策略、优劣势、对于热修复有什么影响，请继续阅读文末给出的链接。</li></ul><p>OK，说了这么多，似乎有点偏题，净是在说什么虚拟机啊dex啊的，这和我们讨论热修复的主题有何关系？当然有关系，让我们把目光往上挪一层，我们之前了解了在安装应用时是怎么把应用代码本地化到系统中的，DVM生成了.odex文件、ART生成了OAT文件缓存在了本地，那么，这些DEX文件又是怎么在虚拟机启动过程中被加载到JavaHeap里作为一个个Class对象供以使用的呢？这里必须要讲到Android的类加载机制了。</p><h3 id="Android-的类加载机制"><a href="#Android-的类加载机制" class="headerlink" title="Android 的类加载机制"></a>Android 的类加载机制</h3><p>首先我们花几分钟时间来简单的回顾一下Java世界中的ClassLoader机制：</p><blockquote><p>双亲委托模型：源ClassLoader收到加载类或资源请求时，首先委托父ClassLoader进行加载，如果已经加载则直接返回，否则继续向上委托直到遍历到始祖类加载器。若始祖类加载器依然没有对应的类或资源，则从始祖类加载器开始，尝试从当前类加载器对应的类路径下寻找class字节码并载入，如果成功则返回class，如果失败则将加载请求委托给子加载器，一直遍历到源ClassLoader直到成功载入该class，否则抛出异常。</p></blockquote><p>从前文我们知道，Android虚拟机标准和普通的JVM不一样，它们没有.class文件，而是在编译之后将所有.class文件封装成了.dex文件，在安装时又被优化成了.odex文件，那这些.odex文件的类加载又会有什么不同呢？让我们接着往下看：</p><p>在Android世界中，同样有ClassLoader类，该类为一个抽象类，其子类由以下部分组成：</p><ul><li>ClassLoader<ul><li>SecureClassLoader<ul><li>URLClassLoader - 加载 jar 文件，在Android上无法使用</li></ul></li><li>BaseDexClassLoader<ul><li>PathClassLoader - 在应用启动时创建，从应用目录下加载 apk 文件，只能加载已经安装的 dex或apk文件。</li><li>DexClassLoader - 类似于PathClassLoader，不过它能够加载来自于其他外部路径的Dex文件 —— 这也是许多热修复的基础，在不需要安装应用的情况下，完成需要的Dex的加载。</li></ul></li></ul></li></ul><p>无论是PathClassLoader还是DexClassLoader，都只是BaseDexClassLoader的封装，具体的类加载过程都在BaseClassLoader中完成的，下面我们来看它究竟做了什么事情：</p><ul><li>在外部通过<code>loadClass(String className)</code>并遍历双亲得到 class 实例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">return</span> loadClass(className, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String className, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = findLoadedClass(className);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ClassNotFoundException suppressed = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz = parent.loadClass(className, <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            suppressed = e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clazz = findClass(className);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                e.addSuppressed(suppressed);</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>loadClass</code>方法调用了<code>findClass</code>方法，BaseDexClassLoader重载了这个方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    Class clazz = pathList.findClass(name);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结果还是调用了 DexPathList的findClass</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">findClass</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Element element : dexElements) &#123;</span><br><span class="line">        DexFile dex = element.dexFile;</span><br><span class="line">        <span class="keyword">if</span> (dex != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Class clazz = dex.loadClassBinaryName(name, definingContext);</span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>DexPathList中的dexElements通过下面方法得到</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Element[] makePathElements(List&lt;File&gt; files, File optimizedDirectory,</span><br><span class="line">        List&lt;IOException&gt; suppressedExceptions) &#123;</span><br><span class="line">    List&lt;Element&gt; elements = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 遍历所有的包含 dex 的文件</span></span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">        File zip = <span class="keyword">null</span>;</span><br><span class="line">        File dir = <span class="keyword">new</span> File(<span class="string">""</span>);</span><br><span class="line">        DexFile dex = <span class="keyword">null</span>;</span><br><span class="line">        String path = file.getPath();</span><br><span class="line">        String name = file.getName();</span><br><span class="line">        <span class="comment">// 判断是不是 zip 类型</span></span><br><span class="line">        <span class="keyword">if</span> (path.contains(zipSeparator)) &#123;</span><br><span class="line">            String split[] = path.split(zipSeparator, <span class="number">2</span>);</span><br><span class="line">            zip = <span class="keyword">new</span> File(split[<span class="number">0</span>]);</span><br><span class="line">            dir = <span class="keyword">new</span> File(split[<span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">            <span class="comment">// 如果是文件夹,则直接添加 Element,这个一般是用来处理 native 库和资源文件</span></span><br><span class="line">            elements.add(<span class="keyword">new</span> Element(file, <span class="keyword">true</span>, <span class="keyword">null</span>, <span class="keyword">null</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">            <span class="comment">// 直接是 .dex 文件,而不是 zip/jar 文件(apk 归为 zip),则直接加载 dex 文件</span></span><br><span class="line">            <span class="keyword">if</span> (name.endsWith(DEX_SUFFIX)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    dex = loadDexFile(file, optimizedDirectory);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                    System.logE(<span class="string">"Unable to load dex file: "</span> + file, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果是 zip/jar 文件(apk 归为 zip),则将 file 值赋给 zip 字段,再加载 dex 文件</span></span><br><span class="line">                zip = file;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    dex = loadDexFile(file, optimizedDirectory);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException suppressed) &#123;</span><br><span class="line">                    suppressedExceptions.add(suppressed);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.logW(<span class="string">"ClassLoader referenced unknown path: "</span> + file);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((zip != <span class="keyword">null</span>) || (dex != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            elements.add(<span class="keyword">new</span> Element(dir, <span class="keyword">false</span>, zip, dex));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// list 转为数组</span></span><br><span class="line">    <span class="keyword">return</span> elements.toArray(<span class="keyword">new</span> Element[elements.size()]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其中<code>loadDexFile()</code>方法最终会调用JNI方法载入dex对象，这里我们不再深入的去涉及了。</li><li>得到dex文件后通过调用<code>loadClassBinaryName</code>得到最终的class对象。这里在<code>loadClassBinaryName</code>方法中，其实最终调用的依然是Native的<code>defineClass</code>方法，这与JVM中<code>loadClass</code>的方法名一致，不知道是故意还是巧合。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">loadClassBinaryName</span><span class="params">(String name, ClassLoader loader)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> defineClass(name, loader, mCookie);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> Class <span class="title">defineClass</span><span class="params">(String name, ClassLoader loader, <span class="keyword">int</span> cookie)</span></span>;</span><br></pre></td></tr></table></figure><p>OK，到这里我们基本大概对Android虚拟机使用的字节码文件有了初步了解，对Android系统中的类加载机制也有了初步的认识，知道了Android虚拟机中的类对象究竟是怎么从.dex文件加载进虚拟机的。这也为我们接下来真正进入Java世界中热修复框架原理打下了基础。</p><h2 id="基于ClassLoader的热修复原理"><a href="#基于ClassLoader的热修复原理" class="headerlink" title="基于ClassLoader的热修复原理"></a>基于ClassLoader的热修复原理</h2><p>经过以上啰啰嗦嗦杂七杂八的前置知识铺垫之后，我们终于进入了正题，趁热打铁，我们首先来看一下最经典的基于ClassLoader的热修复方案：</p><p>如前所述，我们在载入Class的时候，会调用DexPathList对象中的findClass方法，findClass方法则会遍历dexElements数组，当发现首个dex对象的时候则直接返回。若我们在此处将修复了问题之后的dex插入到这个dexElements数组的最前方，那么不就可以直接加载到打完补丁之后修复好的类了吗？那么热修复也就完成了。</p><p>原理很简单，实现也不难，但是这里面有一个很重要的问题需要解决：<code>CLASS_ISPREVERIFIED</code></p><p>这是个Class内部的标示，在应用安装时，系统通过dexopt或dex2oat进行dex优化时进行设置。当该标示位为真，则表示这个类直接引用到的类与该类都在同一个dex中。那么事情就变成了这个样子：假设类A直接引用了类B，类A与类B在安装之初经过校验发现在同一个Dex中，<code>CLASS_ISPREVERIFIED</code>被置为真。</p><p>此时类B出错，使用类B’代替，当类A中再次调用类B(类B’)，虚拟机因为<code>CLASS_ISPREVERIFIED</code>标示缘故对类A与类B’的Dex来源进行校验，此时因为类B’来自下发的补丁包，校验不通过，虚拟机崩溃退出。</p><p>OK，为了解决这个问题，开发人员从<code>CLASS_ISPREVERIFIED</code>的置空条件入手：若类A中引用了一个在同一Dex种的类B，同时也引用了不在同一Dex中的类C，那么包括类A类B类C都不会被打上<code>CLASS_ISPREVERIFIED</code>标签。于是开发人员只要保证在所有类的构造函数中调用一个第三方Dex提供的类X，就可以保证所有类均不会被打上<code>CLASS_ISPREVERIFIED</code>标签。</p><p>但是这个方案不是没有问题，在DVM中，因为所有类都是非preverify的状态，这导致verify与optimize操作会在加载类时触发。单次的verify+optimize耗时并不长，而且这个过程只有一次，但是当应用启动时，会一次性载入数量庞大的类，这时的性能影响就不容忽视了。</p><p><img src="http://ojanerta1.bkt.clouddn.com/2017-01-05-qzone-dalvik.png" alt="" title="Dalvik 类加载时优化"></p><p>而在ART中，由于ART采取了新的方式，这种处理对代码的执行效率没有太大影响，但是如果不定的类中出现修改类变量或者方法的情况，则会导致出现内存错乱的问题——因为在安装应用时，dex2oat已经将能够确定的各个地址全部写死为机器码，如果运行时补丁包的地址出现改变，原始类去调用时就会出现地址错乱。为了解决这个问题我们需要将修改了变量、方法以及接口的类的父类以及调用这个类的所有类都加入到补丁包中。这可能会带来补丁包大小的急剧增加。</p><p><img src="http://ojanerta1.bkt.clouddn.com/2017-01-05-qzone-art%20-2-.png" alt="" title="ART 环境下的变量错乱"></p><p>总的来说，ClassLoader方案好处在于开发透明，简单，这一套方案目前的应用成功率也是最高的，但在补丁包大小与性能损耗上有一定的局限性。</p><h2 id="Instant-Run"><a href="#Instant-Run" class="headerlink" title="Instant Run"></a>Instant Run</h2><p>在我们继续接下来的叙述之前，我觉得需要用一个独立的章节来叙述Google官方推出的「热更新」框架——Instant Run。</p><p>它是去年AndroidStudio2.0发布的时候Google引入的一项用于提升开发效率的新的IDE特性，这项技术能够让我们在初次构建并部署应用到手机后，后续修改能够在不经过重新安装应用即可完成部署——这不就是一种热更新吗？</p><p>虽然Instant Run由于只能运行在IDE环境下、Android系统版本要求也在5.0以上等原因无法作为一个真正的热更新框架，但是其内部的原理、思路为真正的热修复框架提供了思路：</p><p>Instant Run的热更新分为三个层次，热插拔、温插拔、冷插拔。热插拔情况下的修复，应用无须作任何操作即可更新方法的实现。温插拔则是在热插拔的基础上增加了对资源的更新，开发者只需要重启Activity即可完成更新。冷插拔则是应对更加大范围的修改，如类结构变更、方法名变更等等问题，这时开发者需要重启应用以完成更新。</p><p>Instant Run的核心设计有以下几点：</p><ul><li><strong>编译期注入字节码</strong></li></ul><p>我们在通过Instant Run构建应用的时候，Instant Run通过Gradle的<a href="http://tools.android.com/tech-docs/new-build-system/transform-api" title="Trasform api" target="_blank" rel="noopener">Trasform api</a>处理了Javac生成的所有.class文件，为每个类都提供了一个字段change，该字段实例实现了IncrementalChange接口，并且在每个方法最前方插入了一段代码来判断是否需要调用一段插入的代码以作为修复之后的调用。话说起来可能比较抽象，看看图吧，原理其实很简单：</p><p><img src="http://ojanerta1.bkt.clouddn.com/2017-01-06-1480489905685.png" alt="" title="Instant Run 原理"></p><p>与此同时，在生成.class文件的时候，Instant Run同时也修改了Manifest文件，生成代码注入了一个BoostrapApplication作为原来Application类的代理，以实现修改后补丁文件的监听和ClassLoader的注入。</p><ul><li><strong>多ClassLoader机制</strong></li></ul><p>在BootstrapApplication里，Instant Run利用ClassLoader的双亲代理机制，在原有的PathClassLoader之上注入了一个IncrementalClassLoader用于生成所有修改后的补丁类，同时也由于双亲委托机制的存在，IncrementalClassLoader也成为了所有类的加载器，拦截了程序中所有的类加载请求。在IncrementalClassLoader中，每个热补丁类都是由不同的ClassLoader实例创建的，这一点是整个Instant Run的核心所在，因为修改后的类实际上和修改前的类是同一个类，如果使用同一个ClassLoader是无法完成类加载的。</p><ul><li><strong>全量资源替换</strong></li></ul><p>在Instant Run中，在替换Application的同时，也会对资源相关对象进行替换，将资源目录指向另一个位置。此时，如果发生了资源的修改，那么温插拔会被触发，Gradle会自动将所有资源重新打包并替换掉该资源目录下的资源，同时重启Activity完成资源更新。</p><ul><li><strong>Dex分片（Dex-Slice）</strong></li></ul><p>在应用构建的时候，Instant Run会通过Gradle插件对Dex文件按照包名进行分片（也可以叫分包），最多把Dex分为10片部署到手机上。在开发者做出代码上的修改之后，Instant Run会判断修改的内容，如果改动无法通过热插拔完成，那么会对修改类所在的Dex进行全量构建并下发替换原有的Dex片，在这种状况下，实际上新的Dex是通过PathClassLoader加载进来的，因此必须通过重启应用触发类加载来完成载入。</p><p>以上就是Instant Run比较核心的一些设计，我们可以看到，从注入代理Application拦截原生ClassLoader、修改资源路径完成资源替换、注入字节码实现热修复到覆写分片Dex完成全量更新，Instant Run在针对不同的状况采取了不同的措施，逻辑清晰、步步为营，非常值得我们学习。</p><p>从Instant Run热插拔的思路出发，美团团队利用相似的原理开发出了热修复框架Rubost；从Instant Run冷启动的思路出发，微信团队则开发出了热修复框架Tinker。Rubost框架原理这里不需要过多的细讲，和热插拔类似，只是针对方法数、分包等问题进行了优化。下面我们仔细看看Tinker的思路：</p><h2 id="基于Dex全量替换的热修复框架-Tinker"><a href="#基于Dex全量替换的热修复框架-Tinker" class="headerlink" title="基于Dex全量替换的热修复框架 - Tinker"></a>基于Dex全量替换的热修复框架 - Tinker</h2><p>Tinker的思路很简单——全量替换Dex。是不是有一种暴力美学的意味在里面？但是为了实现这个目标，却不得不放下手中的加特林，拿起绣花针把里面一个一个的坑都给踩平。</p><p>全量更新包的大小问题首先就摆在了面前——我当然可以下发一整个Dex给你替换，但是全量下发动辄十几兆的Dex文件真的大丈夫？这里Tinker采取了自研DexDiff算法，通过下发差异文件，在客户端本地合成新的Dex文件作为更新后的Dex文件。这件事听起来也很直接，但是为了最大程度的压缩差量包、最快的生成更新后的Dex文件，Tinker团队必须对Dex文件格式、Dex文件生成过程了如指掌、必须对算法的性能有最高的要求，用shwenzhang自己的话来说：</p><blockquote><p>这不仅要求我们需要研究透Dex的格式，也要把dex2opt与dex2oat的代码全部研究透。现在回想起来，这的确是一条跪着走完的路。与研究Dalvik与Art执行一致，这是经历一次次翻看源码，一次次编Rom查看日志，一次次dump内存结构换来的结果。</p></blockquote><p>Tinker做到的事情当然不止这么多，ART/Dalvik差异化执行、AndroidN混合编译的支持等等天坑都被他们填了过去，具体的技术细节这里就不分析了，这里附一张图看看Tinker都能做到些什么吧：</p><p><img src="http://ojanerta1.bkt.clouddn.com/2017-01-08-0.jpeg" alt="" title="Tinker与各种热修复框架技术对比"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>断断续续的写了两三天，终于把这篇笔记完成了……回过头去再读了一遍全文，感慨良多。就热修复技术而言，确实是一门太需要持续投入时间的技术了，技术做出来很容易，但是做得好真的太难。就用shwenzhang的一句话为本文做结吧：</p><blockquote><p>热补丁不是请客吃饭</p></blockquote><p>向那些在某些领域内深耕不辍的工程师致敬，有朝一日希望我也能成为他们那样优秀的人。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>综述<ul><li><a href="http://blog.zhaiyifan.cn/2015/11/20/HotPatchCompare/" target="_blank" rel="noopener">各大热补丁方案分析和比较 - markzhai</a></li><li><a href="http://www.jianshu.com/p/1683c4e6f36d" title="[Android热修复] 技术方案的选型与验证" target="_blank" rel="noopener">[Android热修复] 技术方案的选型与验证</a></li><li><a href="http://jaeger.itscoder.com/android/2016/08/28/android-hot-fix.html" target="_blank" rel="noopener">Android 热修复方案对比 - itscoder</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&amp;mid=400118620&amp;idx=1&amp;sn=b4fdd5055731290eef12ad0d17f39d4a" target="_blank" rel="noopener">安卓App热补丁动态修复技术介绍 - QZone</a></li></ul></li><li>虚拟机<ul><li><a href="http://blog.csdn.net/luoshengyang/article/details/39256813" title="Android运行时ART简要介绍和学习计划" target="_blank" rel="noopener">Android运行时ART简要介绍和学习计划 - 老罗</a></li><li><a href="http://blog.csdn.net/luoshengyang/article/details/8852432" target="_blank" rel="noopener">Dalvik虚拟机简要介绍和学习计划 - 老罗</a></li></ul></li><li>ClassLoader<ul><li><a href="http://jaeger.itscoder.com/android/2016/08/27/android-classloader.html" target="_blank" rel="noopener">热修复入门：Android 中的 ClassLoader</a></li><li><a href="http://blog.csdn.net/nanzhiwen666/article/details/50515895" target="_blank" rel="noopener">从源码分析 Android dexClassLoader 加载机制原理</a></li><li><a href="https://segmentfault.com/a/1190000004062880" target="_blank" rel="noopener">Android动态加载基础 ClassLoader工作机制</a></li><li><a href="http://www.jianshu.com/p/3afa47e9112e" target="_blank" rel="noopener">Android类加载机制的细枝末节</a></li></ul></li><li>Instant Run<ul><li><a href="https://medium.com/google-developers/instant-run-how-does-it-work-294a1633367f#.luxanx6cm" title="Instant Run: How Does it Work?!" target="_blank" rel="noopener">Instant Run: How Does it Work?! - Google</a></li><li><a href="http://w4lle.github.io/2016/05/02/%E4%BB%8EInstant%20run%E8%B0%88Android%E6%9B%BF%E6%8D%A2Application%E5%92%8C%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" title="从Instant run谈Android替换Application和动态加载机制" target="_blank" rel="noopener">从Instant run谈Android替换Application和动态加载机制 - w4lle</a></li><li><a href="http://www.cnblogs.com/coding-way/p/5443718.html" title="Android Studio的Instant Run(即时安装)原理分析和源码浅析" target="_blank" rel="noopener">Android Studio的Instant Run(即时安装)原理分析和源码浅析 - coding-way</a></li><li><a href="https://gold.xitu.io/entry/5731f50ef38c840067dcce48" target="_blank" rel="noopener"> 从Instant-Run出发，谈谈Android上的热修复 - zjutkz</a></li></ul></li><li>Tinker<ul><li><a href="https://github.com/WeMobileDev/article/blob/master/final-%E5%BE%AE%E4%BF%A1%E7%83%AD%E8%A1%A5%E4%B8%81%E5%AE%9E%E8%B7%B5%E6%BC%94%E8%BF%9B%E4%B9%8B%E8%B7%AF-v2016-9-24.pdf" target="_blank" rel="noopener">微信热补丁实践演进之路 - PPT</a></li><li><a href="https://github.com/WeMobileDev/article/blob/master/%E5%BE%AE%E4%BF%A1Tinker%E7%9A%84%E4%B8%80%E5%88%87%E9%83%BD%E5%9C%A8%E8%BF%99%E9%87%8C%EF%BC%8C%E5%8C%85%E6%8B%AC%E6%BA%90%E7%A0%81(%E4%B8%80" target="_blank" rel="noopener">微信Tinker的一切都在这里，包括源码</a>.md)</li><li><a href="https://github.com/WeMobileDev/article/blob/master/Android_N%E6%B7%B7%E5%90%88%E7%BC%96%E8%AF%91%E4%B8%8E%E5%AF%B9%E7%83%AD%E8%A1%A5%E4%B8%81%E5%BD%B1%E5%93%8D%E8%A7%A3%E6%9E%90.md" target="_blank" rel="noopener">Android N混合编译与对热补丁影响深度解析</a></li><li><a href="https://github.com/WeMobileDev/article/blob/master/ART%E4%B8%8B%E7%9A%84%E6%96%B9%E6%B3%95%E5%86%85%E8%81%94%E7%AD%96%E7%95%A5%E5%8F%8A%E5%85%B6%E5%AF%B9Android%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%E7%9A%84%E5%BD%B1%E5%93%8D%E5%88%86%E6%9E%90.md" target="_blank" rel="noopener">ART下的方法内联策略及其对Android热修复方案的影响分析</a></li><li><a href="https://www.zybuluo.com/dodola/note/554061" title="Tinker DexDiff" target="_blank" rel="noopener">Tinker DexDiff</a></li></ul></li><li>Rubost<ul><li><a href="http://tech.meituan.com/android_robust.html" title="Android热更新方案Robust" target="_blank" rel="noopener">Android热更新方案Robust</a></li><li><a href="http://www.wjdiankong.cn/android%E4%B8%AD%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%A1%86%E6%9E%B6robust%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E5%B9%B6%E5%B0%86%E6%A1%86%E6%9E%B6%E4%BB%A3%E7%A0%81%E4%BB%8E%E9%97%AD%E6%BA%90%E5%8F%98/" target="_blank" rel="noopener">Android中热修复框架Robust原理解析+并将框架代码从”闭源”变成”开源”(上篇)</a></li><li><a href="http://www.wjdiankong.cn/android%E4%B8%AD%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%A1%86%E6%9E%B6robust%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E5%B9%B6%E5%B0%86%E6%A1%86%E6%9E%B6%E4%BB%A3%E7%A0%81%E4%BB%8E%E9%97%AD%E6%BA%90%E5%8F%98-2/" target="_blank" rel="noopener">Android中热修复框架Robust原理解析+并将框架代码从”闭源”变成”开源”(下篇)</a></li></ul></li><li>AndFix<ul><li><a href="https://github.com/alibaba/AndFix" target="_blank" rel="noopener">AndFix - Github</a></li><li><a href="http://w4lle.github.io/2016/03/03/Android%E7%83%AD%E8%A1%A5%E4%B8%81%E4%B9%8BAndFix%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" title="Android热补丁之AndFix原理解析" target="_blank" rel="noopener">Android热补丁之AndFix原理解析</a></li></ul></li><li>Freeline<ul><li><a href="https://yq.aliyun.com/articles/59122" target="_blank" rel="noopener">Freeline - Android平台上的秒级编译方案</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      热补丁不是请客吃饭
    
    </summary>
    
      <category term="技术" scheme="http://blog.kyangc.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://blog.kyangc.com/tags/Android/"/>
    
      <category term="热修复" scheme="http://blog.kyangc.com/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
  </entry>
  
  <entry>
    <title>Jekins+Bitbucket+Fir.im 自动构建部署最新测试包</title>
    <link href="http://blog.kyangc.com/2017/01/04/jekins-bitbucket-auto-build/"/>
    <id>http://blog.kyangc.com/2017/01/04/jekins-bitbucket-auto-build/</id>
    <published>2017-01-04T10:00:00.000Z</published>
    <updated>2018-03-17T06:12:00.852Z</updated>
    
    <content type="html"><![CDATA[<p>在日常开发中，我们的流程通常是：</p><blockquote><p>开发->自测->提交测试->测试反馈->开发->……</p></blockquote><p>很多有着成熟流程的公司在其中很多步骤上都能做到充分的解耦和自动化，开发无需关心应用的构建，只需要向特定分支提交符合标准的代码即可，测试也不需要关心开发是否开发完成、构建是否成功等等问题，只需要关注推送通知得知「有一个最新的测试包就绪，它相对于前次版本更新了xxxx」，并且能够很便捷的获取到应用，进行测试之后也能够把出现的问题对应到对应的版本反馈给开发。</p><p>堆糖的CI一直一来使用的都Jekins，前代开发已经在上面建立了众多的Project以用于构建各种版本的堆糖应用，但是可能是因为理解的偏差，只是把Jekins当做了一个「重复性任务执行脚本列表」来使用，只是让Jekins代替执行自己手写的Shell脚本，既没有利用到Jekins对于源代码的管理功能，也没有很好的利用Jekins提供的丰富的自动化插件，开发需要不定期告诉测试我们往xx分支提交了有xx feature的代码，测试则需要不定期去内部CI网站上配置构建工程，并等待构建结果生成——这样的状况无论是对于开发还是测试都是极大的生产力浪费，很多事情其实都是不需要这么做的。</p><p>最近业务压力稍小，就花了一下午时间开发并调试了一下Jekins，利用Bitbucket的WebHook功能，当某条分支上推送了最新代码时，自动触发Jekins的构建，构建完毕自动上传到公司内部的Fir.im，并通过BearyChat推送一条通知，告知测试最新的测试包已经构建完毕，以及本次构件包含的内容。整个流程无需人为干预，无论是测试还是开发都不需要关心CI的细节，只需要关心自己职责范围内的工作即可。<br>下面记录下都做了些什么事吧：</p><ul><li>升级Jekins（内部服务器上的Jekins版本低的令人发指），安装BitBucket插件</li></ul><p><img src="http://ojanerta1.bkt.clouddn.com/2017-01-09-install-bitbucket-plugin.png" alt="" title="安装 Jekins Bitbucket 插件"></p><ul><li>在Bitbucket中配置WebHook，填入Jekins实例的地址</li></ul><p><img src="http://ojanerta1.bkt.clouddn.com/2017-01-09-bitbucket-hook.png" alt="" title="Bitbucket 中配置"></p><ul><li>填入需要触发构建的分支名，这里我们随便填个 Dev看看</li></ul><p><img src="http://ojanerta1.bkt.clouddn.com/2017-01-09-bitbucket-config.png" alt="" title="Bitbucket 配置触发条件"></p><ul><li>Bitbucket上的配置已经完成啦，这里我们回到jekins上，我们新创建一个Project好了，在源码管理部分填入项目地址、构建分支、访问凭证等等东西</li></ul><p><img src="http://ojanerta1.bkt.clouddn.com/2017-01-09-jks-git.png" alt="" title="Jekins 配置源代码管理"></p><ul><li>在触发器上钩选 <code>Build when a change pushed to Bitbucket</code></li></ul><p><img src="http://ojanerta1.bkt.clouddn.com/2017-01-09-jks-trigger.png" alt="" title="Bitbucket 触发 Jekins 构建"></p><ul><li><p>新增Execute shell 部分，在里面写好构建应用的脚本代码。这里算是整个部分最核心的地方了，清理构建环境、升级SDK、更新Build号等等事情，不过这里就不附图了，代码比较敏感。</p></li><li><p>配置Fir.im的上传插件</p></li></ul><p><img src="http://ojanerta1.bkt.clouddn.com/2017-01-09-jks-firim.png" alt="" title="Jekins 自动将构建好的安装包上传到 Fir.im 上"></p><ul><li>配置BearyChat机器人，通知事件。这里只通知构建成功，失败了的话就让他去吧……</li></ul><p><img src="http://ojanerta1.bkt.clouddn.com/2017-01-09-jks-bc.png" alt="" title="BearyChat 通知构建成功"></p><ul><li>构建完毕，收到通知，测试现在可以看到这次构建发生了什么变化，以及能够直接访问公司固定的Fir.im链接下载最新的安装包了。</li></ul><p><img src="http://ojanerta1.bkt.clouddn.com/2017-01-09-bearychat-noti.png" alt="" title="BearyChat 接收通知"></p><p>至此基本所有的流程都走通了，整个过程虽然看上去简单，但是其中总会在某些不知名的角落卡住……比如Bitbucket和Jekins无法互相访问，这个只能联系公司运维解决；比如Jekins的工作环境总是会出一些各种各样的问题……这里也不细讲了，案例都比较个例。</p><p>可能这个案例本身并没有特别厉害的技术含量在里面，但这种对于任何低效保持「不妥协」的态度却是值得记录的。程序员要成长要提高，执着于「业务」开发是永远没办法达到很高的高度的，<strong>只有保持对于「低效」「不适」的不满并且不断努力去解决这些痛点</strong>——可能是流程上的繁琐，可能是框架代码的不合理，可能是开发效率的底下，可能是不愿意写很多模板代码——发现他们，解决他们，才能真正的让程序员不断的进步下去。</p>]]></content>
    
    <summary type="html">
    
      对低效说不要不要啦
    
    </summary>
    
      <category term="技术" scheme="http://blog.kyangc.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://blog.kyangc.com/tags/Android/"/>
    
      <category term="技术" scheme="http://blog.kyangc.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>2016 年度总结与展望</title>
    <link href="http://blog.kyangc.com/2017/01/02/2016-summary/"/>
    <id>http://blog.kyangc.com/2017/01/02/2016-summary/</id>
    <published>2017-01-02T10:00:00.000Z</published>
    <updated>2018-03-17T06:12:00.848Z</updated>
    
    <content type="html"><![CDATA[<p>元旦三天昏昏沉沉的不知道做了些什么，莫名其妙的在家宅着断断续续的竟然写了两天代码……说是写了两天代码没错，但是总觉得回过头来看又觉得自己也没写什么东西，兴冲冲的构思了一个架构，实现的时候写写删删的也没有最终达到我期望的样子，哎，头疼，先不搞了，来把这篇总结怼出来再说。</p><h1 id="年末"><a href="#年末" class="headerlink" title="年末"></a>年末</h1><p>好快呀……2016年就这么过去了，不过说快也不算快，今年还真的算是经历了蛮多事情的呐，用几个关键词总结一下吧。</p><h1 id="毕业"><a href="#毕业" class="headerlink" title="毕业"></a>毕业</h1><p>年初在家安逸的过完了最后一个寒假，然后回学校毕业去，很舒服的度过了最后一段在学校的时光，该玩玩，该睡睡，然后就这么的被小破邮扫地出门，就这么的跟同学们分道扬镳各自启程。</p><p>关于毕业其实没有太多感触，唯一的不舍可能还是来自于曾经低头不见抬头见的各位和学校从此不再能够经常从你的生命里路过，不过好在交通、信息发达，实际上也不会有太大的区别。有心的人终究会再遇见，年末之际，愿你们新的一年一切都变得更好。</p><h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>其实从14年底开始基本就算是一直在校外全职的工作了，朝夕、漫漫、支付宝到现在的堆糖。虽然有的工作因为没有毕业，名义上算不上全职，但是从工作的实质上讲，基本都是处于全职工作的状态中。所以有时候也会想，竟然就这么默默的成为了一个职场人士，感觉略有些奇怪。</p><p>说回工作，毕业之后没有多做其他考虑的加入了堆糖，之所以没有去更大的公司，一是决定来上海的决定很匆忙，没时间去找更棒的工作了；二是个人对于小型团队存在某种偏好，小宇这个team-mate给我的感觉也蛮好的，15年合作的很愉快；三嘛，是因为是懒。确实身边也有人对我的选择表示不理解，可能我自己如果回到15年9月的时候我也不会做相同的选择，但是人嘛，都得学会向前看，把握当下、追逐未来才是正途，对吧？</p><p>所以，16年从年末往年初回顾，我个人觉得是我职业生涯中成长收获蛮丰富的一年，也是有很多遗憾的一年。写出来并解决了很多bug，遇到了来自各个方面的很多问题也解决了很多问题，尝试了很多新的东西也对很多老东西有了新的认识，读了很多源码，重写了很多代码，和很多人打了交道，也和很多人交了朋友。遗憾的话，没能好好的学学前端，没能用上Kotlin，没能贡献几个好用的开源库，还有好几本书放在家里吃灰没时间看，还有好几个想要研究的开源框架源码没读……</p><p>如果让我自己给今年的自己在工作、事业上打个分的话，给自己75分吧，勉强及格，还需努力。</p><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>16年成功的没有发福，年底猛吃了一波之后陷入了对于中国传统美食免疫的状态，每天胃肠翻腾，恨不得每天喝粥。年底也是各种账单机票集中冒出来的时候，穷的快疯了……</p><p>16年4月的时候也终于从破的鸟不拉屎早上地铁都挤不上的鹤沙航城搬来了虹桥路，终于感受到了「上海」，对于当时的决定感到无比庆幸。不过搬来之后就再也没有自己做饭的想法了，都怪外卖太发达……</p><p>和潇哥的生活也并不平淡的过着，吃吃喝喝也有，到处疯玩也有，穿成个绒毛熊在家宅着你写报告我写代码也有。生活必然是不平淡的，毕竟两个人都有小本本，说不定哪天就翻出旧账记你一笔然后互怼一波……</p><p>今年有个最重要的决定就是终于在成都买了房，虽然是个小房子，但是位置还不错，最近几年肯定也不会回去住，买下来抵抗下通胀，租出去收点租子也不错呀哈哈。</p><p>总的来说，生活在16年里也是不平不淡的过着，最重要的是，有潇哥在身边。😘。</p><h1 id="2017"><a href="#2017" class="headerlink" title="2017"></a>2017</h1><p>呐，展望一下吧。<strong>目标很少，做到就好。</strong></p><ul><li>工作<ul><li>拓展技术栈</li><li>无论什么领域，多做尝试</li></ul></li><li>生活<ul><li>少宅，多运动</li></ul></li></ul><p>唔。新年快乐。</p>]]></content>
    
    <summary type="html">
    
      目标很小，做到就好
    
    </summary>
    
      <category term="总结" scheme="http://blog.kyangc.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结" scheme="http://blog.kyangc.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>自动在博客的中英文单词中间加上空格</title>
    <link href="http://blog.kyangc.com/2016/12/28/auto-space/"/>
    <id>http://blog.kyangc.com/2016/12/28/auto-space/</id>
    <published>2016-12-28T10:00:00.000Z</published>
    <updated>2018-03-17T06:12:00.848Z</updated>
    
    <content type="html"><![CDATA[<p>偶然间在逛<a href="http://kaedea.com/2016/06/26/front-auto-space/" target="_blank" rel="noopener">Kaedea</a>博客的时候发现了这个玩意：<a href="https://github.com/vinta/pangu.js" target="_blank" rel="noopener">pangu.js</a>，很好很强势，终于可以解放老夫的空格键了，强迫症伤不起。</p><p>嘛，Github上pangu.js介绍的这段话也很有意思：</p><blockquote><p>漢學家稱這個空白字元為「盤古之白」，因為它劈開了全形字和半形字之間的混沌。另有研究顯示，打字的時候不喜歡在中文和英文之間加空格的人，感情路都走得很辛苦，有七成的比例會在 34 歲的時候跟自己不愛的人結婚，而其餘三成的人最後只能把遺產留給自己的貓。畢竟愛情跟書寫都需要適時地留白。</p></blockquote><p>嗯，记录下在<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">Next</a>主题下是怎么实现的吧：</p><ul><li>在这里找到模板文件：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim path_to_hexo/themes/next/layout/_layout.swig</span><br></pre></td></tr></table></figure><ul><li>在head块中声明JS：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/pangu/3.3.0/pangu.min.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>在body块的末尾调用一下就好辣</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;pangu.spacingPage();&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      强迫症患者的福音-_,-
    
    </summary>
    
      <category term="技术" scheme="http://blog.kyangc.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="折腾" scheme="http://blog.kyangc.com/tags/%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title>Android Nested Scrolling 学习笔记</title>
    <link href="http://blog.kyangc.com/2016/05/09/nestedscrolling-summary/"/>
    <id>http://blog.kyangc.com/2016/05/09/nestedscrolling-summary/</id>
    <published>2016-05-09T22:00:00.000Z</published>
    <updated>2018-03-17T06:12:00.852Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，在Android中，触摸事件的处理流程是通过<code>dispatchTouchEvent</code>分发触摸事件，通过自下而上的拦截事件(<code>onInterceptTouchEvent</code>)以及自上而下的处理事件(<code>onTouchEvent</code>/<code>onTouch</code>)完成事件的分发，如果想要完成子控件与父控件同时对某一事件的处理的话，需要自己额外实现较多代码，非常繁琐而且容易出错，而<code>NestedScroll</code>接口的出现正是为了应对这种情况。</p><p>该接口已经在Android官方控件中广泛的得到了使用，包括在<em>Android Design</em>包中引入的<code>CoordinateLayout</code>、<code>FabIcon</code>以及之前的<code>RecyclerView</code>、<code>SwipereFreshLayout</code>等等常用控件现在均已实现了该接口，都可以作为嵌套滑动的子容器或父容器使用。然而令人非常遗憾的是，<code>ViewPager</code>作为一个使用频次非常高、使用场景中非常容易出现嵌套滑动场景的控件，官方并没有提供任何相关的支持，甚至在<code>ViewPager</code>的源码文档开头依然宣称该控件依然停留在一个非常早期的开发阶段（This class is currently under early design and development），令人唏嘘不已。 </p><p><code>NestedScroll</code>系列接口包括以下四个部分：</p><pre><code>NestedScrollingChild//实现嵌套滑动的子控件需要实现的接口NestedScrollingParent//实现嵌套滑动的父容器需要实现的接口NestedScrollingChildHelper//在需要嵌套滑动的子控件中一个用于辅助进行嵌套滑动的HelperNestedScrollingParentHelper//在需要嵌套滑动的父容器中一个用于辅助进行嵌套滑动的Helper</code></pre><p>为了实现父容器和子控件之间的嵌套滑动，首先我们需要选定父子容器，明确是哪个父容器需要配合子容器进行嵌套滑动，这里需要注意的是，嵌套滑动只能发生在父容器与子控件之间，并且滑动的发起者是子控件，父容器是被动的接受子控件发出的嵌套滑动请求并作出响应的一方。</p><p>当选定好我们需要进行嵌套滑动的控件双方时，我们首先需要在子控件中实现<code>NestedScrollingChild</code>接口，然后在子控件的构造函数中生成一个<code>NestedScrollingChildHelper</code>对象，并将接口中所有方法委托给helper对象。同样的，我们类似的处理父容器——实现接口、委托方法，然后准备工作就完成了。</p><p>可以看到，我们仅仅是把接口代理给了一个helper，仅仅依靠这个是怎么完成嵌套滑动呢？这些方法又应该在哪里调用呢？又有什么意义呢？我们继续往下看。</p><p>我们首先分析下主要的嵌套滑动发起者<code>NestedScrollingChild</code>中的方法，由于所有方法均被代理给了helper类，因此我们直接看helper中的对应方法就好了：</p><ol><li><p><code>setNestedScrollingEnabled</code>，该方法开启/关闭嵌套滑动</p><pre><code>public void setNestedScrollingEnabled(boolean enabled) {    if (mIsNestedScrollingEnabled) {        //如果正在嵌套滑动，那么通知父容器停止嵌套滑动        ViewCompat.stopNestedScroll(mView);    }    mIsNestedScrollingEnabled = enabled;}</code></pre></li><li><p><code>isNestedScrollingEnabled</code>，该方法用于检查是不是能够嵌套滑动</p><pre><code>public boolean isNestedScrollingEnabled() {    return mIsNestedScrollingEnabled;}</code></pre></li></ol><ol><li><p><code>hasNestedScrollingParent</code>，该方法用于检查是否关联有父容器用来接收嵌套滑动过程事件</p><pre><code>public boolean hasNestedScrollingParent() {    return mNestedScrollingParent != null;}</code></pre></li><li><p><code>startNestedScroll</code>，该方法用于开启一个嵌套滑动的过程，返回true表示可以开启嵌套滑动，返回false表示无法开启嵌套滑动。</p><pre><code>public boolean startNestedScroll(int axes) {    if (hasNestedScrollingParent()) {        //如果已经有了一个嵌套滑动的父容器对象，那么直接返回true        return true;    }    //首先检查嵌套滑动是不是开启了    if (isNestedScrollingEnabled()) {        ViewParent p = mView.getParent();        View child = mView;        //遍历从该子控件开始往上的所有父容器，尝试去调用这些父容器的onStartNestedScroll方法，        //如果成功，那么将该父容器作为嵌套滑动的对象，并调用父容器的onNestedScrollAccepted方法。        while (p != null) {            if (ViewParentCompat.onStartNestedScroll(p, child, mView, axes)) {                mNestedScrollingParent = p;                ViewParentCompat.onNestedScrollAccepted(p, child, mView, axes);                return true;            }            //如果父容器无法开始嵌套滑动，那么将子控件和父容器都向上遍历一级，继续这个过程，直到父容器为空。            if (p instanceof View) {                child = (View) p;            }            p = p.getParent();        }    }    return false;}</code></pre></li></ol><p>我们可以看到，在这个过程中，helper类会不断的从子控件开始向上遍历可以作为嵌套滑动对象的父容器，直到找到第一个可以作为嵌套滑动对象的父容器返回。这个机制也保证了我们不用强制子控件的直接父容器必须实现该接口，只要保证目标父容器实现了这个接口即可。</p><ol><li><p><code>dispatchNestedPreScroll</code>，该方法用于在子控件消费滑动事件之前去向父容器分发滑动事件，并允许父容器预先消费一部分滑动距离，该被消费的距离会通过数组<code>int[] consumed</code>来传递，并且如果子控件的绝对位置在父容器消耗距离的过程中发生了改变，那么这个改变的值会通过数组<code>int[] offsetInWindow</code>回传过来:</p><pre><code>public boolean dispatchNestedPreScroll(int dx, int dy, int[] consumed, int[] offsetInWindow) {    //只有在可以嵌套滑动的时候才分发事件    if (isNestedScrollingEnabled() &amp;&amp; mNestedScrollingParent != null) {        //只要滑动的距离在xy轴上任意不为0，那么开始分发事件        if (dx != 0 || dy != 0) {            //初始化起始位置            int startX = 0;            int startY = 0;            //初始化子控件在屏幕上的相对位置            if (offsetInWindow != null) {                mView.getLocationInWindow(offsetInWindow);                startX = offsetInWindow[0];                startY = offsetInWindow[1];            }            //初始化consumed数组            if (consumed == null) {                if (mTempNestedScrollConsumed == null) {                    mTempNestedScrollConsumed = new int[2];                }                consumed = mTempNestedScrollConsumed;            }            consumed[0] = 0;            consumed[1] = 0;            //调用父容器中的onNestedPreScroll，让父容器预先滑动                        ViewParentCompat.onNestedPreScroll(mNestedScrollingParent, mView, dx, dy, consumed);            //重新计算子控件在屏幕上的位置，通过offsetInWindow返回给子控件            if (offsetInWindow != null) {                mView.getLocationInWindow(offsetInWindow);                offsetInWindow[0] -= startX;                offsetInWindow[1] -= startY;            }            //如果在x轴或y轴上父容器发生了消耗，那么这个方法的返回值为true，否则为false，方便子控件跳过处理            return consumed[0] != 0 || consumed[1] != 0;        } else if (offsetInWindow != null) {            offsetInWindow[0] = 0;            offsetInWindow[1] = 0;        }    }    return false;}</code></pre></li><li><p><code>dispatchNestedScroll</code>，该方法在子控件消耗滑动距离之后调用，通知父容器将剩下的滑动距离消耗掉。</p><pre><code>public boolean dispatchNestedScroll(int dxConsumed, int dyConsumed,        int dxUnconsumed, int dyUnconsumed, int[] offsetInWindow) {    //只有在可以处理的时候才处理    if (isNestedScrollingEnabled() &amp;&amp; mNestedScrollingParent != null) {        //只有在发生了距离消耗或还有距离没有消耗完时才进行下一步        if (dxConsumed != 0 || dyConsumed != 0 || dxUnconsumed != 0 || dyUnconsumed != 0) {            int startX = 0;            int startY = 0;            if (offsetInWindow != null) {                mView.getLocationInWindow(offsetInWindow);                startX = offsetInWindow[0];                startY = offsetInWindow[1];            }              //注意这里的方法没有consumed数组返回了，只会更新offsetInWindow数组                          ViewParentCompat.onNestedScroll(mNestedScrollingParent, mView,                         dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed);            if (offsetInWindow != null) {                mView.getLocationInWindow(offsetInWindow);                offsetInWindow[0] -= startX;                offsetInWindow[1] -= startY;            }            return true;        } else if (offsetInWindow != null) {            // No motion, no dispatch. Keep offsetInWindow up to date.            offsetInWindow[0] = 0;            offsetInWindow[1] = 0;        }    }    return false;}</code></pre></li></ol><p>该接口中还有一些fling相关的方法，都是大同小异就不再仔细看了。事实上以上五个方法基本就完成了和嵌套滑动相关的在子控件上的全部操作，我们可以看到，helper因为是通过该view注入进构造方法新建出来的，所以helper中是持有view的引用的，因此可以遍历该view的视图树，并以此找到目标的嵌套滑动的父容器对象建立联系。同时，该helper也帮助使用者分发滑动时间、返回滑动消耗结果，帮用户省去了很多模板代码。</p><p>至于parent，由于嵌套滑动的parent通常是作为「回调」的接收方，其接口多为用于完成实际的控件滑动，所以基本都需要用户自己手动去完成实现，需要代理给parent helper的方法很少，这里就略过不讲了。</p><p>至此我们不难得出NestedScroll系列接口的正确用法：</p><p>在子控件开始滑动时通过<code>startNestedScroll</code>通知父容器配合，然后在子容器捕获到手势滑动时调用<code>dispatchNestedPreScroll</code>让父容器有机会在子容器消耗掉滑动距离之前先滑动一段距离，然后子容器完成自己的滑动，最后通过<code>dispatchNestedScroll</code>通知父容器自己完成了滑动，让父容器有机会再根据子容器的滑动做出一些滑动处理，所有的子容器方法，都会经过helper类转接，通过遍历视图树找到最近的一个嵌套滑动父容器，并尝试调用相应的<code>on**</code>回调方法完成父容器的响应。</p><p>可以看到整个传递触摸事件的思路是与原有的触摸事件分发机制是完全不一样的，这也为我们今后自己做相关的开发提供了思路和启发。</p>]]></content>
    
    <summary type="html">
    
      源码之前没有秘密
    
    </summary>
    
      <category term="技术" scheme="http://blog.kyangc.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://blog.kyangc.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android IPC 学习笔记</title>
    <link href="http://blog.kyangc.com/2016/05/02/ipc-summary/"/>
    <id>http://blog.kyangc.com/2016/05/02/ipc-summary/</id>
    <published>2016-05-02T10:00:00.000Z</published>
    <updated>2018-03-17T06:12:00.852Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>IPC: Inter-Process Communication </p></blockquote><p>不同系统下的不同实现方式：</p><ul><li>Windows: 剪贴板/管道/油槽</li><li>Linux: 命名管道/共享内容/信号量</li><li>Android: Binder/Socket</li></ul><h1 id="Android中的多进程模式"><a href="#Android中的多进程模式" class="headerlink" title="Android中的多进程模式"></a>Android中的多进程模式</h1><p>使用场景：保活/推送/扩大内存空间/ContentProvider</p><h2 id="如何开启？"><a href="#如何开启？" class="headerlink" title="如何开启？"></a>如何开启？</h2><ul><li>在Manifest中设定四大组件的<code>android:process</code>属性<ul><li><code>:$remote_name</code>私有进程</li><li><code>$package_name.$remote_name</code>共有进程，可以通过ShareUID的方式与其他应用共享进程<ul><li>需要两个应用拥有相同的ShareUID以及应用签名一致</li></ul></li></ul></li><li>通过JNI的方式在Native层去fork一个新的进程</li></ul><h2 id="多进程模式下的运行机制"><a href="#多进程模式下的运行机制" class="headerlink" title="多进程模式下的运行机制"></a>多进程模式下的运行机制</h2><p>Android对于每个进程都分配一个独立的虚拟机，不同的虚拟机在内存分配上有不同的地址空间，通常来讲，使用多进程会造成如下几方面问题：</p><ul><li>静态成员和单例模式失效——在不同的虚拟机中访问同一个类对象会产生多份副本。</li><li>线程同步机制完全失效</li><li>SharedPreference可靠性下降——SP底层是XML实现，并发读写都有可能出现问题。</li><li>Application会多次创建——新组建运行在新的进程中时，由于系统在创建新进程的时候会同时分配独立的虚拟机，相当于也是将应用重新启动了一次。</li></ul><h1 id="IPC基础概念简介"><a href="#IPC基础概念简介" class="headerlink" title="IPC基础概念简介"></a>IPC基础概念简介</h1><h2 id="Serializable接口"><a href="#Serializable接口" class="headerlink" title="Serializable接口"></a>Serializable接口</h2><p>Java提供的序列化方法，通过<code>ObjectInputStream</code>和<code>ObjectOutputStream</code>来对对象进行序列化及反序列化。</p><p><code>Serializable</code>接口是一个空接口，只需要声明一个<code>serialVersionUID</code>即可，事实上这个字段不声明也是能够完成序列化/反序列化的。这个字段的作用在于<em>标识类的版本变化</em>，在序列化的过程中，会将这个值写入序列化的结果中，在反序列化时，会将写入值与反序列化对象的当前<code>serialVersionUID</code>值进行对比，如果相同那么能够成功反序列化，如果不一致则抛出异常。<br>如果该值不经手工指定，那么将按照该类的当前<em>成员变量</em>的构成计算Hash作为<code>serialVersionUID</code>值，在这种情况下，如果序列化/反序列化中间该类成员发生了改变，将导致无法完成序列化。因此为了保证序列化的成功率，最好手动指定<code>serialVersionUID</code>。</p><h2 id="Parcelable接口"><a href="#Parcelable接口" class="headerlink" title="Parcelable接口"></a>Parcelable接口</h2><p>Android系统中特有的序列化接口。需要实现的接口包括：</p><ul><li>一个<code>CREATOR</code>常量作为反序列化方法，在该方法中定义通过序列化数据生成对象的构造方法。</li><li>一个<code>describeContents</code>内容描述符，通常情况下都为0，当且仅当当前内容含有文件描述符返回1</li><li>一个<code>writeToParcel</code>方法作为序列化方法</li></ul><p>系统已经定义好了许多可以直接序列化的方法。如<code>Bitmap</code>，<code>Bundle</code>以及<code>Intnet</code>等。</p><blockquote><p>那么，如何选择使用何种序列化方法？</p><ul><li><code>Serializable</code>使用简单方便，但是需要大量的IO操作，开销较大，适合在进行数据本地化或数据序列化之后进行网络传输时使用。</li><li><code>Parcelable</code>定义较为复杂，但性能优秀，效率较高，是Android推荐的序列化方式，主要使用在内存序列化上。</li></ul></blockquote><h2 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h2><p>Binder既可以理解为Android中的一个实现了<code>IBinder</code>接口的类，也可以理解为一种虚拟的物理设备，他的驱动是<code>/dev/binder</code>。Binder是连接<code>ServiceManager</code>连接各个<code>ManagerService</code>之间的桥梁。最常用到的地方在Service的使用中，在<code>bindService</code>的时候会返回一个包含服务端业务调用的Binder对象，通过Binder对象来完成客户端对于服务端业务的调用。</p><p>不同进程内的Binder很简单，稍微复杂一些的Binder通常使用<code>AIDL</code>或者<code>Messenger</code>完成，而<code>Messenger</code>的底层也是由<code>AIDL</code>实现的，因此了解<code>AIDL</code>的使用方法、原理实际上对于理解Binder的上层原理是有帮助的。</p><p><img src="http://ww1.sinaimg.cn/mw690/825558b1gw1f3hfkrwaavj20m60dnwey.jpg" alt="" title="Binder扮演的角色"></p><p>定义<code>AIDL</code>文件并不难，没有太多额外的语法需要注意，只需要按照自己的业务需求，像通常定义接口一样定义<code>AIDL</code>接口即可，注意所有自有的类都必须显式声明即可。在AS中的<code>AIDL</code>文件会被统一收拢到同一个目录下，但是这里有一个不知道是bug还是怎么回事的问题……当你已经定义好一个自定义类之后，IDE不允许再次声明同样名字的<code>.aidl</code>文件。这里没发现有特别好的解决方案，暂时只能先声明一个不同名字的文件，然后再改回去。</p><p><code>AIDL</code>文件没什么好关心的，但是通过<code>AIDL</code>文件生成的<code>.class</code>文件则可以好好研究下：</p><p><code>AIDL</code>生成的实际上是一个接口文件，在这个接口类中首先是定义了<code>AIDL</code>文件中规定的方法，然后生成了一个接口内部的抽象类<code>Stub</code>，这个抽象类实现了外层的接口，并继承自Binder，这个内部抽象类就是在之后使用时在<code>Service</code>内部初始化并实现接口方法的Binder对象，听过<code>bindService</code>返回给调用者，调用者使用Binder调用远端方法。</p><p>在这里需要注意的是，与日常使用的进程内利用Binder调用远端代码不同的是，这里在获取Binder对象时调用的方法是：</p><pre><code>public void onServiceConnected(ComponentName name, IBinder service) {    mITaskConsumer = ITaskConsumer.Stub.asInterface(service);    mIsRemoteBond = true;}</code></pre><p>这里<code>asInterfase(service)</code>是完成整个跨进程调用的关键。我们继续看看这个方法里面做了什么：</p><pre><code>public static com.kyangc.ipcdemo.ITaskConsumer asInterface(android.os.IBinder obj) {    if ((obj == null)) {        return null;    }    android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);    if (((iin != null) &amp;&amp; (iin instanceof com.kyangc.ipcdemo.ITaskConsumer))) {        return ((com.kyangc.ipcdemo.ITaskConsumer) iin);    }    return new com.kyangc.ipcdemo.ITaskConsumer.Stub.Proxy(obj);}</code></pre><p>这里<code>obj</code>是通过bindService返回的Binder对象，这时会在本地按照<code>DESCRIPTOR</code>定义的特征值去查找进程内的服务，如果查到了，那么说明这个Binder是个本地服务，那么直接将这个Binder作为处理业务的对象返回给调用者；反之如果没有查到，说明这个是一个远程的服务，这个时候会用<code>Proxy</code>对这个Binder进行包装，然后返回给用户。</p><p>下面继续看这个<code>Proxy</code>做了什么事：</p><p>首先是这个<code>Proxy</code>是继承于我们定义好的接口的：</p><pre><code>private static class Proxy implements com.kyangc.ipcdemo.ITaskConsumer </code></pre><p>然后在执行接口方法时，调用的是这一段代码：</p><pre><code>@Overridepublic void consume(com.kyangc.ipcdemo.Task task) throws android.os.RemoteException {    android.os.Parcel _data = android.os.Parcel.obtain();    android.os.Parcel _reply = android.os.Parcel.obtain();    try {        _data.writeInterfaceToken(DESCRIPTOR);        if ((task != null)) {            _data.writeInt(1);            task.writeToParcel(_data, 0);        } else {            _data.writeInt(0);        }        mRemote.transact(Stub.TRANSACTION_consume, _data, _reply, 0);        _reply.readException();    } finally {        _reply.recycle();        _data.recycle();    }}</code></pre><p>这里看上去多，但实际上只是一堆模板代码。核心步骤实际上只有三步：</p><ul><li>将传入参数写入<code>_data</code></li><li>调用<code>mRemote.transact(方法序号,传入序列化数据,传出序列化数据,标志位)</code></li><li>写入返回值，处理异常，回收序列化变量</li></ul><p>而<code>transact</code>方法则是调用了<code>/dev/binder</code>提供的方法，将调用什么方法、使用什么参数、返回什么参数等内容传到了远程服务端。</p><p>那么远程服务端收到<code>/dev/binder</code>的提醒之后会做什么呢？我们继续看<code>Stub</code>中的一段代码：</p><pre><code>@Overridepublic boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply,        int flags) throws android.os.RemoteException {    switch (code) {        case INTERFACE_TRANSACTION: {            reply.writeString(DESCRIPTOR);            return true;        }        case TRANSACTION_consume: {            data.enforceInterface(DESCRIPTOR);            com.kyangc.ipcdemo.Task _arg0;            if ((0 != data.readInt())) {                _arg0 = com.kyangc.ipcdemo.Task.CREATOR.createFromParcel(data);            } else {                _arg0 = null;            }            this.consume(_arg0);            reply.writeNoException();            return true;        }    }    return super.onTransact(code, data, reply, flags);}</code></pre><p>当<code>/dev/binder</code>把信息发到远端时，会调用到<code>Stub</code>中的<code>onTransact</code>方法，这个方法会接下来继续分析客户端调用了什么方法，从<code>_data</code>中取出参数，计算后将结果放到<code>_reply</code>中。注意这里有一个返回值，如果返回为<code>false</code>，那么代表该次请求失败，反之成功，这个特性可以被利用于权限验证。</p><p>这里需要注意的一点是，客户端的线程会在请求后被挂起，之后所有的操作均发生在各自Binder的线程池中，直到请求返回才停止主线程的阻塞。因此尽量不要再主线程发起远端的业务请求，尽可能在新的线程中发起业务需求通知。</p><p>下图简单描述了一下这个过程：</p><p><img src="http://ww3.sinaimg.cn/mw690/825558b1gw1f3hfkvmvgrj20dg0daaax.jpg" alt="" title="Binder的调用过程"></p><h1 id="Android中其他IPC方式"><a href="#Android中其他IPC方式" class="headerlink" title="Android中其他IPC方式"></a>Android中其他IPC方式</h1><h2 id="Bundle"><a href="#Bundle" class="headerlink" title="Bundle"></a>Bundle</h2><p>非常常用的跨进程传输数据的方式(<code>Intent</code>)，只支持<code>Parcelable</code>数据的传输。</p><h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><p>必须手动控制并发，很容易出问题，效率较低。例如<code>Sharedpreference</code>，系统对于SP是有一定的缓存策略的，在多进程模式下会变得非常不可靠。</p><h2 id="Messenger"><a href="#Messenger" class="headerlink" title="Messenger"></a>Messenger</h2><p>一种基于<code>AIDL</code>的轻量级IPC手段。底层由<code>Handler</code>+<code>AIDL</code>实现，服务端存在一个固定宽度为1的消息队列，因此没有并发的问题。通过指定<code>Message</code>中的<code>replyTo</code>字段来完成服务端的消息转发。</p><h2 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h2><p>底层实现依然依赖于Binder。实现自定义的ContentProvider只需要实现对应的CRUD方法以及一个生命周期方法和一个返回MIME类型的getType方法即可。ContentProvider的储存方式是任意的，可以使用数据库、文件甚至是内存中的一个对象。</p><p>这里需要注意的是，ContentProvider的OnCreate方法是调用在UI线程中的，因此需要注意不要放入太多耗时操作。而其他CRUD方法则是运行在Binder线程池中，因此是存在多线程并发访问的可能性的，ContentProvider本身没有对这些方法做处理，需要用户自己管理并发。</p><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>Socket运行在TCP/UDP层上，本身支持传输任意字节流，因此也可以被用于IPC。 </p>]]></content>
    
    <summary type="html">
    
      五一劳动节就看看书吧
    
    </summary>
    
      <category term="技术" scheme="http://blog.kyangc.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://blog.kyangc.com/tags/Android/"/>
    
      <category term="IPC" scheme="http://blog.kyangc.com/tags/IPC/"/>
    
  </entry>
  
  <entry>
    <title>写在毕业前</title>
    <link href="http://blog.kyangc.com/2016/03/17/something-to-say-before-april/"/>
    <id>http://blog.kyangc.com/2016/03/17/something-to-say-before-april/</id>
    <published>2016-03-17T00:00:00.000Z</published>
    <updated>2018-03-17T06:12:00.852Z</updated>
    
    <content type="html"><![CDATA[<p>就要滚蛋了，离开学校，离开北京。<br>我想我是爱这里的，虽然在校的时候没少吐槽学校怎么怎么不好，没少跟家里人抱怨北京空气差房子贵地铁挤，但我想我还是爱这里的。<br>在这里呆了将近七年，人生中四分之一的时间。在这里遇到了很多有意思的人，知道了很多有意思的事，交了很多有意思的朋友，留下了很多有意思的回忆。我知道我没有理由不爱这里。<br>很多事情只有当失去的时候才会认真的去珍惜，比如亲情，比如爱情，比如友情，比如包皮。再也没有导员没有班长没有学习委员打电话发邮件的告诉你什么什么事情该做了，再也没有同学可以挥手告别约好下学期再见，再也没有900块一年的床位还顺便附带4个好哥们陪你一起睡了，再也没有大家一起脱光了钻澡堂子捡肥皂聊天了，再也没有北邮校医院便宜到极点的包皮手术和祖卡木颗粒了，再也没有周末了一起约好网吧开黑五连坐了，再也吃不到虽然便宜但是难吃的食堂，再也没有几个人组团去自习，再也没有考前突击，再也没有人拿着足球敲你的门，再也没有一群人脱光了只穿着内裤站在一个屏幕前对着球赛大呼小叫了，就连夏天的小风扇很快你也就用不到了。<br>突然间，你会发现你的生活中一下子就空出来了一大块，你习惯了七年的「习惯」戛然而止了，你不再受到学校的庇佑，你的朋友也各奔东西，你不再有寒暑假，你的学生证也只剩下纪念的意义。真的，就是这么戛然而止了。<br>但生活仍旧继续，那些离开的终将离开，但不会带走一切。我感谢我的母校留给我的眼界、知识、态度以及科学素养，这些将使我受益终身；我感谢我的朋友带给我的激情、善良、勇气与陪伴，这些让我无时无刻感受到温暖；我感谢我在学校中经历过的种种带给我的见识、经验、应变和果断，这些让我能够应对一切即将到来的考验。所以啊，我没有理由不感恩，没有理由不心怀感激。<br>感谢我的母校，希望北邮越来越好；感谢陪我走过这段日子的朋友们，希望你们都能实现梦想，勇敢前行；感谢这七年来经历过的一切，无论我当时做出的种种选择是对还是错，至少是你们真正的让我成为了现在的我，我无怨无悔。<br>3月31日，北京邮电大学信息与通信工程学院工学硕士程康阳毕业。<br>学生生涯至此结束。<br>一切重新开始。</p>]]></content>
    
    <summary type="html">
    
      向前走，就这么走，就算你被给过什么；向前走，就这么走，就算你被夺走什么；向前走，就这么走，就算你会错过什么。
    
    </summary>
    
      <category term="总结" scheme="http://blog.kyangc.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结" scheme="http://blog.kyangc.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>支付宝/客户端开发实习生 实习总结</title>
    <link href="http://blog.kyangc.com/2015/09/01/alipay-internship-sumary/"/>
    <id>http://blog.kyangc.com/2015/09/01/alipay-internship-sumary/</id>
    <published>2015-09-01T00:00:00.000Z</published>
    <updated>2018-03-17T06:12:00.848Z</updated>
    
    <content type="html"><![CDATA[<p>拖了蛮久的来写这篇博客，其实这里的文章似乎也只有我自己会看的样子，老是写这种流水账连自己都不愿意多看的文章真的好吗，不过既然有这个系列那么还是要坚持下去嗯。</p><p>和支付宝的缘分从曹哥的内推开始，其实也就是试一下看看能不能内推成功，结果还真的面上了，当时确实是很开心的，实际上从那个时候开始就想着妈的我就玩到7月然后去实习真是屌炸天的爽，但是后来还是被李惜劝住去他们公司做了果冻漫画，事实证明李惜是对的……</p><p>说回正题。其实在支付宝的实习现在想来还真的蛮轻松，善攻是那种给个题目让你自己去发挥很少会干预的那种主管，说实话还是满不适应的。不过后来就习惯了，把一些可能会被检查的事情做完之后倒是有充足的时间去做点别的，这点比较舒服。</p><p>一开始是做Framework的修改和编译替换还有研究diff之类的东西，说实话这种事情确实不怎么搞的来，不过还是硬着头皮玩了一个多星期，收获了一堆理论知识，现在想来还是挺开心的。</p><p>后来就被叫去做网络抓包分析啦。一开始定的要求很高哎，抓包、修改包、还要在网页上实时显示什么的，也是在这些事情上纠结了一周左右，看了好几个开源的类似于网络攻击的项目，最终得出结论老子搞不定这东西（……），就在纠结怎么继续这个东西的时候主管刚好找上我让我做一下收银台部分的网络性能分析。我说，这个好哎，有意思而且看上去并不难的样子。然后剩下的一个半月时间里面，刨开离职那一周，剩下的都在做这件事啦。抓包分析什么的还是蛮有意思，具体的可以看看之前的博客，wireshark什么的。</p><p>其实工作上就这些吧，现在想起来也觉得没做什么，怪不得简历老是被筛掉，哎。</p><p>实习中其实最好玩的还是遇到了很多有趣的人。一起租房的5匹狼，超哥居家有才华会做饭很爱家还会玩乐队，简直屌的不行，哎，好像跟他再去买个菜做做饭；小棋帅逼会画画各种晚归女朋友一大把，东北老爷们也是屌的不行，哈哈；苏妈绝逼是个有强迫症的孩子，见我面就拍我肩膀，然后就是一声阳桑，接着三声哈哈哈，醉的不行；最后是大钊，一个谜一样的清华学霸，外表正直气质阳光，然而一张嘴绝对就是生殖器，我真的服气。哎，能够租在一起真的是缘分，能够这么投缘也是不容易，希望大家天涯各处，各自安好了。</p><p>然后是曹哥，哎，到了杭州就坑了他几天，说好的一起找房子结果被我临阵放了鸽子，自己一个人住也是空虚寂寞冷……没事曹哥以后我去上海会去找你的。</p><p>最后是同组的几个实习小伙伴啦，一个是笑起来猥琐的一逼的雁荡山香蕉，其实是个伪全栈，也是屌的不行；还有个修闭口禅的虫师，不说话则矣，一说话惊人；还有一起去雁荡山的小伙伴，醉杭、钢蛋、小凯和大眼，都是超级有意思的小伙伴，真心的祝愿你们一切都好。雁荡山大屌永远记得你们。</p><p>说完了这些，那最后来说说拥抱变化吧。哎，其实走的时候主管也讲了说我们都能留下，当时还很开心的说人生中第一个Offer到手了，走的时候还互相告别说明年再见，谁知道刚刚到北京休息了没两天就发通告说今年我们不招人——我们被拥抱变化了。</p><p>一开始还是很气愤的，说好的给offer呢？但是后来想想也就释然了，经济形势不好，阿里财报堪忧，他裁员都算轻的了，何况是不给这些实习生offer？一念至此，也是释怀，先好好修炼技术，以后再走社招进去好了。</p><p>哎，说这么多，也是蛮伤感，就写到这吧。</p><p>祝大家一切都好。</p>]]></content>
    
    <summary type="html">
    
      兄弟们你们还好吗？
    
    </summary>
    
      <category term="总结" scheme="http://blog.kyangc.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结" scheme="http://blog.kyangc.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络及Wireshark学习笔记</title>
    <link href="http://blog.kyangc.com/2015/07/20/wireshark-learning-note/"/>
    <id>http://blog.kyangc.com/2015/07/20/wireshark-learning-note/</id>
    <published>2015-07-20T20:00:00.000Z</published>
    <updated>2018-03-17T06:12:00.852Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、网络通信原理"><a href="#1、网络通信原理" class="headerlink" title="1、网络通信原理"></a>1、网络通信原理</h2><p>ISO参考模型：7层协议。</p><blockquote><p>7 <strong>应用层</strong>：用户接口。常用协议：HTTP、SMTP、FTP、Telnet<br>6 <strong>表示层</strong>：数据编解码、加解密。常用协议：ASCII、MPEG、JPEG、MIDI。<br>5 <strong>会话层</strong>：负责建立、维护连接。常用协议：NetBIOS、SAP、SDP、NWLink。<br>4 <strong>传输层</strong>：提供可靠的数据传输。常用协议：TCP、UDP、SPX。<br>3 <strong>网络层</strong>：路由转发、数据包分片。常用协议：IP、IPX。（路由器工作在这里）<br>2 <strong>数据链路层</strong>：物理网络传输数据的方法，提供一个寻址方案，找到确实的设备。主要协议：Ethernet、Token Ring、FDDI、AppleTalk。（网桥、交换机工作在这里）<br>1 <strong>物理层</strong>：硬件相关。</p></blockquote><p>在传输中，会对传输的数据进行封装，封装的结果叫做协议数据单元<code>PDU（Protocol Data Unit）</code>，发送时逐级向下<code>封装</code>，接收时逐级向上<code>解封</code>。</p><p>TCP/IP模型中没有表示层和会话层，协议栈中也没有单独设计相关的协议。以HTTP连接为例，应用层产生HTTP数据包，经过传输层，通过<code>TCP</code>协议进行可靠的传输，在网络层通过<code>IP</code>对于传输设备进行定位，最终在数据链路层通过加上<code>以太网相关</code>的头部，放入物理层进行传输。</p><p>网络硬件：</p><blockquote><p><strong>集线器</strong>：工作在链路层，将受到的信号转播到每一个端口中。不对Mac进行检查，效率低、半双工模式。<br><strong>交换机</strong>：工作在链路层，将收到的信号转播到对应的MAC地址的端口上，减少了机器拒绝的时间，效率更高，双工。<br><strong>路由器</strong>：工作在网络层，负责在多个网络之间转发数据包。通常使用第三层地址（IP）来标示网络上的唯一设备。</p></blockquote><a id="more"></a><h2 id="2、网络底层协议"><a href="#2、网络底层协议" class="headerlink" title="2、网络底层协议"></a>2、网络底层协议</h2><h3 id="1、地址解析协议ARP"><a href="#1、地址解析协议ARP" class="headerlink" title="1、地址解析协议ARP"></a>1、地址解析协议<code>ARP</code></h3><p>正常网络通信中需要用到<code>逻辑地址</code>和<code>物理地址</code>。</p><blockquote><p><code>逻辑地址</code>用于不同网络、没有直接相连的设备之间进行通信。<br><code>物理地址</code>用于在单一网段中<strong>交换机直接连接的设备之间</strong>进行通信。</p></blockquote><p>在<code>TCP/IP</code>协议中，<code>IP</code>地址已经完成了到第三层的传输，进一步的为了获取到设备的真实MAC地址进而进行单一网络中的通信，<code>TCP/IP</code>协议中使用<code>ARP(Address Resolution Protocol)</code>来进行<code>IP</code>向<code>MAC</code>地址的转换。</p><p>这个协议使用两种数据包，一个<code>ARP</code>请求，一个<code>ARP</code>响应。<code>ARP</code>请求通过向全部设备广播ARP请求消息，当网段中符合要求的主机收到消息，将发送<code>ARP</code>响应告诉请求者自己的真实MAC地址。</p><h3 id="2、互联网协议IP"><a href="#2、互联网协议IP" class="headerlink" title="2、互联网协议IP"></a>2、互联网协议<code>IP</code></h3><p>在该层的通信中，主要负责跨网络的通信，在这个层面上协议不止一个，但是通行很广的还是<code>IP</code>协议，包括<code>IPv6</code>和<code>IPv4</code>。</p><p>v4条件下，<code>IP</code>地址被分为2个部分，<code>网络地址</code>和<code>主机地址</code>，网络地址用来标识局域网，主机地址则是标示这个网络中的设备本身，用于决定哪部分是主机，使用的是<code>掩码</code>，<code>掩码</code>中标示为1的位代表的是网络地址，剩下的则标示着主机地址。</p><p><code>IPv4</code>头部很复杂，包含了很多有用的信息，比较重要的有：</p><blockquote><ul><li><strong>存活时间<code>TTL</code></strong>：定义了在该数据包被丢弃之前所能经历的时间（能够经历的最大路由数目）。数据包被发出时会定义<code>TTL</code>，之后每次经历一个路由器，正常情况下都会被减1，当网络拥堵时延较长时有可能被减掉更多（但多数时候不会）。<code>TTL</code>的设计原理在于，数据包在网络中传输通常会经历数十个路由器，其中难免会有错误配置的路由，在这种情况下路由器可能做很多事，其中一件就是让这个数据包进入死循环——而这必然会占用大量资源，直至<code>DoS</code>的情况出现，<code>TTL</code>的设定就是防止这种事情的发生。</li><li><p><strong><code>IP</code>分片</strong>：数据包分片的目的是将一个数据流分为更小的片段，是<code>IP</code>为了解决跨越不同类型网络时可靠传输的特性。数据包得分片主要基于第二层协议所使用的<code>最大传输单元MTU</code>的大小以及使用这些第二层设备的配置情况。以太网的默认MTU是<code>1500</code>，所以说以太网上能传输的最大数据包大小是<code>1500</code>字节。当需要传输的<code>IP</code>数据包大于<code>MTU</code>，将对这个数据包进行分片，分片的过程如下：</p><ol><li>将传输的数据分块</li><li>将每个<code>IP</code>数据包的头部总长度设为每个分片的长度</li><li>将<code>IP</code>数据包头部中的分片标志位置1，除了最后一个数据包（最后一个数据包的Flags所有位都是0）</li><li>设置每个数据包的分片偏移量（这里注意，偏移量表征的是该<code>IP</code>数据包中的数据块对应于原有的大数据块中的偏移量。在MTU=1500情况下，第一个的offset是0，第二个的offset是1500-HeaderLength……）</li></ol></li></ul></blockquote><h3 id="3、传输控制协议TCP"><a href="#3、传输控制协议TCP" class="headerlink" title="3、传输控制协议TCP"></a>3、传输控制协议<code>TCP</code></h3><p>最终目的是提供数据<strong>可靠地端到端传递</strong>。该协议工作在第四层。能够处理数据的顺序和错误恢复，并且保证数据能够到到达其应该到达的地方。</p><p><code>TCP</code>通信使用端口进行，所有的TCP通信都会使用源端口和目的端口（像电话机一样）。</p><p><code>TCP</code>进行数据通信之前会进行著名的<code>三次握手</code>：</p><blockquote><ol><li>由发起链接请求的主机向连接对象送出一个<code>TCP</code>数据包，不含数据，只有包头，并且设置<code>Flags</code>量中的<code>SYN</code>为1，并发送一个<code>SequenceNumber</code>给对方。</li><li>目标主机收到<code>SYN</code>信号之后，回复<code>SYN/ACK</code>信号给发起主机。同时发送一个<code>AcknowledgeNumber</code>给对方，这个值等于收到的<code>SequenceNumber</code>+1；此外会发送属于目标主机的<code>SequenceNumber</code>给发起主机。</li><li>发起主机收到<code>SYN/ACK</code>信号之后，检查<code>AcknowledgeNumber</code>是否与本地的<code>SequenceNumber</code>+1相等，若想等则说明传输无误，回复<code>ACK</code>信号给目标主机，并且回复<code>AcknowledgeNumber</code>到目标主机，其值为目标主机的<code>SequenceNumber</code>+1，目标主机收到信号之后检查<code>AcknowledgeNumber</code>是否与本地的<code>SequenceNumber</code>+1相等，若想等则说明传输无误，连接建立。</li></ol></blockquote><p><code>TCP</code>停止链接同样要经历几个过程：</p><blockquote><ol><li>请求结束的主机发送<code>FIN/ACK</code>到目的主机。</li><li>目的主机回复<code>ACK</code>到请求主机。</li><li>目的主机发送<code>FIN/ACK</code>到请求主机。</li><li>请求主机回复<code>ACK</code>到目的主机，结束链接。</li></ol></blockquote><h3 id="4、用户数据报协议UDP"><a href="#4、用户数据报协议UDP" class="headerlink" title="4、用户数据报协议UDP"></a>4、用户数据报协议<code>UDP</code></h3><p><code>UDP</code>主要目的在于提高传输速率，是一种尽力服务，是一种无连接协议。一般依赖于<code>UDP</code>的服务会内建其他的可靠性措施。如<code>DNS</code>和<code>DHCP</code>这种高度依赖传输速度的服务，使用<code>UDP</code>作为传输层的协议，并自己实现差错控制的方法。</p><h3 id="5、互联网控制消息协议ICMP"><a href="#5、互联网控制消息协议ICMP" class="headerlink" title="5、互联网控制消息协议ICMP"></a>5、互联网控制消息协议<code>ICMP</code></h3><p><code>TCP/IP</code>协议栈中的一个效用协议，负责提供在<code>TCP/IP</code>网络上的设备、服务以及路由器可用性的分析。<code>ICMP</code>的类型和作用取决于其<code>Type</code>和<code>Code</code>域。<code>Ping</code>是一个工具，通过发送<code>ICMP echo</code>请求数据包来达到检测网络状况的目的。</p><h2 id="3、高层网络协议"><a href="#3、高层网络协议" class="headerlink" title="3、高层网络协议"></a>3、高层网络协议</h2><h3 id="1、DHCP"><a href="#1、DHCP" class="headerlink" title="1、DHCP"></a>1、DHCP</h3><p><code>DHCP</code>是一个应用层协议，能够让设备自动获取IP地址，DHCP最主要的任务就是在续租过程中向客户端分配IP地址。<code>DHCP</code>的续租过程被称为<code>DORA</code>过程，分为以下四步：</p><blockquote><ol><li><strong>发现（<code>Discover</code>）</strong>：在客户端启动的时候，首先会广播<code>Discover</code>报文（在这报文里面包括了客户端的<code>MAC</code>地址）。<code>Discovery</code>报文可以理解为：客户端去发现<code>DHCP Server</code>。由于是广播，可以保证DHCP server收到这个报文。</li><li><strong>提供（<code>Offer</code>）</strong>：<code>DHCP server</code>收到这个报文后他就知道某个客户端要请求一个IP地址，<code>DHCP server</code>就参照<code>Discover</code>报文里面的<code>MAC</code>地址,然后从他配置的<code>DHCP</code>地址池里面分配一个IP地址。然后把这个地址用<code>Offer</code>消息告诉客户端。这个报文里面会把<code>Discovery</code>里面客户端的MAC包含进去。客户机收到后比较下<code>MAC</code>，发现报文里面的<code>MAC</code>和自己的<code>MAC</code>一样就会认为这个报文是发给他的。</li><li><strong>请求（<code>Request</code>）</strong>：由于<code>DHCP server</code>可能有多个，所以客户端发一个<code>Discovery</code>就很有可能收到多个<code>Offer</code>。这时候客户端必须表示我用哪个<code>Offer</code>的地址。所以客户端再次发一个<code>Request</code>报文，表明我要用这个<code>Discovery</code>的报文。</li><li><strong>确认（<code>Acknowledge</code>）</strong>：最后<code>DHCP server</code>回一个<code>ACK</code>。做一个确定。</li></ol></blockquote><h3 id="2、域名系统DNS"><a href="#2、域名系统DNS" class="headerlink" title="2、域名系统DNS"></a>2、域名系统<code>DNS</code></h3><h3 id="3、超文本传输协议HTTP"><a href="#3、超文本传输协议HTTP" class="headerlink" title="3、超文本传输协议HTTP"></a>3、超文本传输协议<code>HTTP</code></h3><p><code>HTTP</code>是万维网的传输机制，允许浏览器通过连接Web服务器浏览网页。</p><p><code>HTTP GET</code>过程建立在<code>TCP</code>之上，首先是通过三次握手建立连接，而后通过TCP向服务器设定的端口（HTTP通常默认使用80端口，HTTPS默认使用443端口）传递HTTP数据包，包中包含资源标示符、操作资源的方式等等定义。服务器读取请求之后通过发送一个HTTP包返回ACK信息。之后开始传输数据，形式是TCP分片。传输结束之后，服务器传输一个带有响应码的封包结束过程。成功的响应吗是200。</p><p><code>HTTP POST</code>的过程也建立在<code>TCP</code>之上，过程与上类似，只是在结束之后的响应码通常为302，代表该资源找到。而这个响应的数据包通常也被用于重定向的手段，在其location域指明了客户端被重定向的位置。</p><h3 id="4、超文本传输安全协议HTTPS"><a href="#4、超文本传输安全协议HTTPS" class="headerlink" title="4、超文本传输安全协议HTTPS"></a>4、超文本传输安全协议<code>HTTPS</code></h3><p>HTTPS在传输数据之前需要客户端（浏览器）与服务端（网站）之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL协议不仅仅是一套加密传输的协议，更是一件经过艺术家精心设计的艺术品，TLS/SSL中使用了非对称加密，对称加密以及HASH算法。</p><p>握手过程的简单描述如下：</p><blockquote><ol><li>浏览器将自己支持的一套加密规则发送给网站。</li><li>网站从中选出一组加密算法与<code>HASH</code>算法，并将自己的身份信息以<code>证书</code>的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。</li><li>获得网站证书之后浏览器要做以下工作：<ol><li>验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。</li><li>如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。</li><li>使用约定好的HASH计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。</li></ol></li><li>网站接收浏览器发来的数据之后要做以下的操作：<ol><li>使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。</li><li>使用密码加密一段握手消息，发送给浏览器。</li></ol></li><li>浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。这里浏览器与网站互相发送加密的握手消息并验证，目的是为了保证双方都获得了一致的密码，并且可以正常的加密解密数据，为后续真正数据的传输做一次测试。</li></ol></blockquote><p>HTTPS一般使用的加密与HASH算法如下：</p><blockquote><p>非对称加密算法：RSA，DSA/DSS<br>对称加密算法：AES，RC4，3DES<br>HASH算法：MD5，SHA1，SHA256</p></blockquote><p>其中非对称加密算法用于在握手过程中加密生成的密码，对称加密算法用于对真正传输的数据进行加密，而HASH算法用于验证数据的完整性。由于浏览器生成的密码是整个数据加密的关键，因此在传输的时候使用了非对称加密算法对其加密。非对称加密算法会生成公钥和私钥，公钥只能用于加密数据，因此可以随意传输，而网站的私钥用于对数据进行解密，所以网站都会非常小心的保管自己的私钥，防止泄漏。</p><h2 id="5、监听网络线路"><a href="#5、监听网络线路" class="headerlink" title="5、监听网络线路"></a>5、监听网络线路</h2><p>首先，需要一块支持混杂模式的网卡才能嗅探数据包，混杂模式的意思是它允许网卡看到所有流经网络线路数据包的驱动模式。</p><p>在集线器环境下进行数据嗅探是最理想的情况，你可以从你的端口中听到所有连接到集线器中的设备的网络通信信息。但是集线器环境已经基本不存在了，所以这个环境下的监听很难实现。</p><p>在交换机环境下进行数据嗅探则要复杂得多，因为交换机只会与特定端口进行通信（除某些广播消息外），通常采用的方法有如下几个：</p><blockquote><p><strong>端口镜像</strong>：通过设置交换机的镜像端口来实现监听。<br><strong>集线器输出</strong>：将需要监听的端口和监听器接入同一个集线器。（类似作弊）<br><strong>使用网络分流器</strong>：在通信链路中使用分流器监听。<br><strong>使用ARP欺骗</strong>：ARP负责翻译第三层的IP地址到第二层的MAC地址，如果我们污染了ARP缓存，使得目标设备的ip对应于嗅探器的mac，那么所有的进出流量都会经由嗅探器流动，从而也达到了监听的目的。</p></blockquote><h2 id="5、Wireshark简单使用说明"><a href="#5、Wireshark简单使用说明" class="headerlink" title="5、Wireshark简单使用说明"></a>5、Wireshark简单使用说明</h2><ul><li>Wireshark的过滤器</li></ul><blockquote><p>分为捕获过滤器和显示过滤器，这两个过滤器都使用BPF语法进行过滤器的定义。BPF的语法结构为：<code>n</code>*<code>限定词</code>+<code>ID</code>=<code>原语</code> 多个<code>原语</code>通过<code>||</code>、<code>&amp;&amp;</code>、<code>!</code>连接起来成为一个限定表达式。</p></blockquote><p>限定词分为三种：</p><blockquote><p><strong>Type</strong>：数字或字母的意义 <code>host</code>(默认)，<code>net</code>，<code>port</code>……<br><strong>Dir</strong>：指明传输方向是前往还是来自 <code>src</code>，<code>dst</code><br><strong>Proto</strong>：指明匹配的协议 <code>ether</code>，<code>ip</code>，<code>tcp</code>……</p></blockquote><p>通过设定各种过滤条件，可以配置出各种符合我们需求的过滤器。</p><ul><li>Wireshark高级特性</li></ul><blockquote><p><strong>端点 endpoint</strong>：网络通信中的收发者。<br><strong>会话 conversation</strong>：端点之间的通信。</p></blockquote><p>Wireshark中针对这两者有专门的统计工具，可以看到基于端点或者会话的流量状态。同时，Wireshark中还有基于协议栈的统计工具，可以看到某种协议下的链接占了总连接数的多少部分。</p><p>Wireshark同时提供对于Mac、ip地址的解析，可以直观的将MAC转换成对应的ip地址，但是这样会带来额外的DNS开销。可能会让抓包来的数据充斥着DNS数据包。</p><p>Wireshark提供对于协议数据包的强制解码能力，可以让你将数据包拆分成多个协议区段以分析。因为Wireshark的开源特性，当需要对某种特定的协议进行解析而软件中没有内置解析方法的时候，可以根据已有的解析文件进行自己编制新的解析文件。</p><p>Wireshark可以跟踪TCP流，可以看到TCP流整个过程中的发送情况。可以看到最原始的数据交换。</p><h2 id="6、利用Wireshark解决网络问题"><a href="#6、利用Wireshark解决网络问题" class="headerlink" title="6、利用Wireshark解决网络问题"></a>6、利用Wireshark解决网络问题</h2><p>利用<code>TCP</code>数据包的错误恢复特性进行网络环境的检修是非常有用的一件事。</p><h3 id="1、TCP的错误恢复特性"><a href="#1、TCP的错误恢复特性" class="headerlink" title="1、TCP的错误恢复特性"></a>1、TCP的错误恢复特性</h3><h4 id="1、重传机制"><a href="#1、重传机制" class="headerlink" title="1、重传机制"></a>1、重传机制</h4><p>决定是否有必要重传的机制叫做重传计时器。这个计时器负责维护一个叫重传超时<code>RTO</code>的值，每当使用<code>TCP</code>传递一个数据包的时候计时器就启动，当收到这个数据包的ACK的时候计时器停止，这两个时刻之间的值叫做往返时间<code>RTT</code>，若干次<code>RTT</code>的测量之后得到的值就是<code>RTO</code>。在<code>RTT</code>值不够多的时候，依靠默认的<code>RTO</code>值。</p><p><code>RTO</code>值被用于决定发送数据包之后过多久重传数据，当在这段时间内收到ACK信号则不需要重传，否则like重传，并将RTO值翻倍，依次类推直到达到最大重传数。</p><p><code>TCP</code>在传递数据的时候，发送者会附带一个<code>SEQ</code>值，发送之后将该值自增发送数据包的大小，接受者成功接收之后会回复一个<code>ACK</code>值，其值为<code>SEQ</code>值和传递的数据包大小之和，若接收端收到的<code>SEQ</code>值不等于<code>ACK</code>那么为了保证数据的有序性，接收端会回复，该<code>ACK</code>值；发送者检查现在的<code>SEQ</code>和收到的<code>ACK</code>值是否一致，若连续三次检测到不一致，则代表数据丢失，则会按照接收端传回的<code>ACK</code>值发送数据包，完成数据重传。</p><p>当发送端认为接收端没有收到数据的时候会重传数据，这是通过<code>RTO</code>完成的，由发送端决定；当发送端收到连续三次接收端相同数据<code>ACK</code>的时候，也会临时重传数据，这是由接收端决定的。</p><h4 id="2、流控制"><a href="#2、流控制" class="headerlink" title="2、流控制"></a>2、流控制</h4><p><code>TCP</code>使用滑动窗口技术来检测何时发生了数据包丢失并调整数据传递速率以加以避免。</p><p>通常接受主机有一个缓冲区和一个接收窗口，发送主机只能发送大小小于接收窗口的数据包，接受主机在接受了一定数量的数据之后会处理缓冲区中的数据，并返回<code>ACK</code>给发送主机，在<code>ACK</code>中更新窗口大小。如果接收机认为发送机的发送速率自己能够处理得过来，那么窗口大小不变；如果认为发送速度太快，那么将减小窗口大小；如果已经完全无法接收数据，那么将回设窗口大小为0。</p><h3 id="2、定位网络延迟"><a href="#2、定位网络延迟" class="headerlink" title="2、定位网络延迟"></a>2、定位网络延迟</h3><p>通常关注六个数据包：三次握手、初始<code>HTTP GET</code>请求、对该请求的确认以及第一个数据包：</p><blockquote><ol><li>A -&gt; B:<code>SYNC</code></li><li>B -&gt; A:<code>SYNC/ACK</code></li><li>A -&gt; B:<code>ACK</code></li><li>A -&gt; B:<code>GET</code></li><li>B -&gt; A:<code>ACK</code></li><li>B -&gt; A:<code>DATA</code></li></ol></blockquote><p>通常的，我们只关心这些步骤之间的延迟。通常的，异常的高延迟通常代表了以下的内容：</p><blockquote><ol><li>在三次握手中，通常接收到信号-&gt;回发送信号的过程是很难被影响到的，基本不会是因为这个原因产生延迟，因此在这个阶段的延迟通常都来自于网络传输。</li><li>从握手完毕到发送<code>GET</code>请求这个过程可能会因为客户端的处理器忙带来延迟。</li><li>从发出<code>GET</code>信号到收到服务器的确认消息的过程基本也只会被线路延迟影响。</li><li>从服务器发送<code>ACK</code>信号之后到第一次发送数据，这段时间可能会受到服务器的负载影响。</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      好好学了下计算机网络……
    
    </summary>
    
      <category term="技术" scheme="http://blog.kyangc.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="计算机网络" scheme="http://blog.kyangc.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
