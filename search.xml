<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2017 年终总结]]></title>
    <url>%2F2017%2F12%2F18%2F2017-summary%2F</url>
    <content type="text"><![CDATA[站在 2017 年末回顾这一年…… 感慨很多，能说的不多。不想写太多流水账，而且确实这一年也没做太多事，就稍微说两句吧： 年初准备了俩月跳了个槽，算是捞了一把掉进天坑的自己，缓了一口气。 在团队里努力搬砖，拿了个最佳新人，算是对这半年的努力工作的小小鼓励。 国庆去了趟日本，算是总算圆了个出国的愿望。 前端技术层面上的进境有限，倒是在其他技术上点了好些奇奇怪怪的技能点，不过看上去用处也不多。 想要学 ML/AI，但是却一直很软弱的在推进，聊胜于无的状况。 读了几本书，培养了一些自己觉得蛮好的习惯，但是拖延症依然在线。 这一年游了不少泳，而且从年末开始重操旧业踢足球，感觉蛮好的。 点出来挺多投资相关的技能点，但都不精深，见识了币圈的疯狂，也进美股泡了泡水，终究还是没啥钱，最多也就是看看。 听到不少周围小伙伴的高收入，看看自己，还是觉得自己太弱了。 虽然刚工作一年半，但总觉得中年危机已经降临……对未来看不清，最近每天都很焦虑。 总的来讲，这一年，无论是职业层面、技术层面还是知识层面都酸算有点小收获，但是对未来却更迷茫了。 所以……就这样啊，至于新的一年……就做到一件事吧：缓解拖延症。 始终觉得自己不缺方向感，只是缺动力，惯性太强，需要更强的力量让自己动起来才行。如果真的能做到的话……我觉得很多事情都能迎刃而解了吧。 以上。 祝你们新年快乐。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Things 3 和桌面的特别姿势]]></title>
    <url>%2F2017%2F11%2F24%2Fgood-way-to-use-things-and-desktop%2F</url>
    <content type="text"><![CDATA[Things 3 是我最近一直在用的 GTD 软件，简洁、高效、交互体验好，某宝售价五元的 Things 3，可以说比我两块五买的 Omni* 系列好用不要太多。Things 可以按 Area 区分 Task，每个 Area 下可以建立对应的 Project，每个 Task 下可以建立 SubTask，三级任务分类足以覆盖我绝大多数情况下的事务记录。并且展示方式也很棒，可以按时间线展示、按未来待办展示等等……（哎打广告的先停一停啊…… 总之就是很棒就对了！ 但是使用中依然存在痛点：为了看自己的「待办清单」，我每次都会经历以下步骤： 打开 alfred 输入 things 找到不知道从主屏还是副屏中弹出来的 Things 窗口 移动鼠标到窗口上 点击对应任务组的分类 查看待办清单 这么多步骤对于我来讲实在是很容易浇灭使用 GTD 软件的心，于是就容易形成这样的恶性循环： 懒得用 GTD 软件 → 生活没有规划 → 人生走向低谷 → 越来越贫困…… 可以说后果非常严重了…… 那么该怎么做呢？来自四川的贫困的小程陷入了思索： 看 Things 内容很繁琐 → 有没有什么便捷的展示信息的方案 → 命令行 → 一行命令就可以展示所有待办任务岂不快哉？ 说干就干，Things 3 官方不提供 CLI 的话，可以看看有没有屌大的自己写，果然被我一搜就搜到了：AlexanderWillner/things.sh 原来 Things 3 的 DB 是基于 sqlite 开发的，而且没加密……所以只要你愿意你自己写个命令行程序去增删改查都行……但是考虑到我使用 Things 的痛点其实不在增删改上，而且自己乱写 SQL 操作数据库风险太大经不起折腾……所以这个脚本虽然只提供了对于各种内容的查找功能，但是已经足够甚至超出了我所需要的适用范围，加上许多格式不符合我的需求，于是直接上手改吧： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224#!/bin/bashset -o errexit# set -o nounset# default optionslimitBy="20"waitingTag="Waiting for"orderBy="creationDate"area=""project=""readonly PROGNAME=$(basename $0)readonly DEFAULT_DB=~/Library/Containers/com.culturedcode.ThingsMac/Data/Library/Application\ Support/Cultured\ Code/Things/Things.sqlite3readonly THINGSDB=$&#123;DB:-$DEFAULT_DB&#125;# table namesreadonly TASKTABLE="TMTask"readonly AREATABLE="TMArea"readonly TAGTABLE="TMTag"# is trashedreadonly ISNOTTRASHED="trashed = 0"readonly ISTRASHED="trashed = 1"# statusreadonly ISOPEN="status = 0"readonly ISCANCELLED="status = 2"readonly ISCOMPLETED="status = 3"# startreadonly ISNOTSTARTED="start = 0"readonly ISSTARTED="start = 1"readonly ISPOSTPONED="start = 2"# typereadonly ISTASK="type = 0"readonly ISPROJECT="type = 1"readonly ISHEADING="type = 2"# merged queriesreadonly IS_UNCOMPLETE_VALID_TASK="type = 0 AND status = 0 AND trashed = 0"readonly IS_UNCOMPLETE_VALID_PROJECT="type = 1 AND status = 0 AND trashed = 0"usage() &#123; cat &lt;&lt;-EOFusage: $&#123;PROGNAME&#125; &lt;OPTIONS&gt; [COMMAND]List to do items from your Things database given a focus area.COMMAND: area (show tasks in given area)OPTIONS: -a|--area &lt;area&gt; List tasks in areaEOF&#125;# utils for displaying textfunction printLineWithLevel() &#123; # set \n as separator OLD_IFS=$IFS IFS=$'\n' array=($1) level=$2 indicator=$3 for data in $&#123;array[@]&#125; do line="" for k in $( seq 1 $&#123;level&#125; ) do line="$indicator$line" done line="$line $data" echo "$line" done # fallback separator IFS=$OLD_IFS&#125;# utils for handling SQL resultfunction printSQLResult() &#123; # set \n as separator OLD_IFS=$IFS IFS=$'\n' array=($1) level=$2 if [ -n $&#123;array&#125; ]; then for item in $&#123;array[@]&#125; do # print task name printLineWithLevel "$item" $level " " done fi # fallback separator IFS=$OLD_IFS&#125;t() &#123; printSQLResult "`listAreas`" 1&#125;listAreas() &#123; sqlite3 "$THINGSDB" &lt;&lt;-SQLSELECT titleFROM $&#123;AREATABLE&#125;;SQL&#125;listProjectsInGivenArea() &#123; sqlite3 "$THINGSDB" &lt;&lt;-SQLSELECT titleFROM $&#123;TASKTABLE&#125;WHERE $&#123;IS_UNCOMPLETE_VALID_PROJECT&#125; AND area=(select uuid from $&#123;AREATABLE&#125; where title="$&#123;area&#125;");SQL&#125;listTaskInGivenArea() &#123; sqlite3 "$THINGSDB" &lt;&lt;-SQLSELECT titleFROM $&#123;TASKTABLE&#125;WHERE $&#123;IS_UNCOMPLETE_VALID_TASK&#125; AND area=(select uuid from $&#123;AREATABLE&#125; where title="$&#123;area&#125;") and project is NULL;SQL&#125;listTaskInGivenProject() &#123; sqlite3 "$THINGSDB" &lt;&lt;-SQLSELECT titleFROM $&#123;TASKTABLE&#125;WHERE $&#123;IS_UNCOMPLETE_VALID_TASK&#125; AND project=(select uuid from $&#123;TASKTABLE&#125; where title="$&#123;project&#125;") and area is NULL;SQL&#125;area() &#123; # print inbox items printLineWithLevel "Inbox" 1 " " printSQLResult "`inbox`" 5 # try to get areas list if [[ -z $&#123;area&#125; ]]; then # display all areas areas=`listAreas` else # display given areas areas=$&#123;area&#125; fi # loop to display all area tasks in given area list areaArray=($&#123;areas&#125;) for item in $&#123;areaArray[@]&#125; do # list area name printLineWithLevel "$item" 1 " " # list tasks directly belongs to this area area=$&#123;item&#125; tasks=`listTaskInGivenArea` if [[ -n $tasks ]]; then # has non-project tasks printLineWithLevel "其他" 3 " " printSQLResult "`listTaskInGivenArea`" 5 fi # get all projects in this area TMP_IFS=$IFS IFS=$'\n' projects=`listProjectsInGivenArea` projects=($&#123;projects&#125;) IFS=$TEM_IFS if [[ -n $&#123;projects&#125; ]]; then # has projects under area for sproject in $&#123;projects[@]&#125; do # print project name printLineWithLevel "$sproject" 3 " " # find all task in project project=$&#123;sproject&#125; printSQLResult "`listTaskInGivenProject`" 5 done fi done&#125;require_sqlite3() &#123; command -v sqlite3 &gt; /dev/null 2&gt;&amp;1 || &#123; echo &gt;&amp;2 "ERROR: SQLite3 is required but could not be found." exit 1 &#125;&#125;require_db() &#123; test -r "$THINGSDB" -a -f "$THINGSDB" || &#123; echo &gt;&amp;2 "ERROR: Things database not found at $THINGSDB." exit 2 &#125;&#125;require_sqlite3require_dbwhile [[ $# -gt 1 ]]; do key="$1" case $&#123;key&#125; in -a|--area) area="$2";shift ;; *) ;; esac shiftdonecommand=$&#123;1:-&#125;if [[ -n $&#123;command&#125; ]]; then case $1 in area) area ;; *) usage ;; esacelse usage;fi 使用效果就像这样： OK，事情是不是到这里就结束了呢？因为懒惰而异常贫穷的小程表示还不够： 我还是得先唤起命令行窗口 → 输入命令 → 查看结果…… 还是麻烦 有没有更方便的做法？小程看着面前的 Dell 27’ 4K 显示器，觉得这么大个显示器，好像平时也就利用了中间这么一小部分啊…… 两侧的空白能用来做什么呢？小程陷入了沉思…… 桥豆麻袋！说到这个「两侧的空白」啊，必须先提一下小程最近在使用窗口管理时的策略： 4K 27’ 显示器是主屏幕，对于绝大多数情况下，只会在屏幕内摆放一个窗口，这个窗口会占据屏幕宽度的百分之 70，占据屏幕高度的百分之 90 就像这样：（通过快捷键让所有窗口 resize 并居中） 在有些时候会采取更 focus 的策略，会通过快捷键让窗口全屏： 在需要查看当前窗口的时候会通过快捷键展示当前显示器中有哪些窗口： 唔…… 以上的窗口管理是通过 Phoenix 完成的，这款神器呢是以前公司的架构师 DDD 安利给我的（当然也安利给了很多人），这里我就再继续安利出去好了~ 具体介绍请直戳链接围观，简单来讲就是个可编程的（js）、利用键盘快捷键对窗口进行管理的软件~ 如果真的感兴趣请戳以下链接围观：windows management for hacker 收回来一下，其实上面就讲了一件事：我平时的工作窗口其实还有两侧的空白没有被利用起来。 那我能利用这两块空白做点什么呢？ 想到这里，我又想起来曾经在 Windows 7 环境下用过的「便签」小工具…… 其实这玩意在 Mac 上也有，不过被放在 Dashboard 上了，想用还得去另一块窗口，忒不方便，而且贼 jb 丑啊…… 于是想到这里，贫困的小程不禁想到：有没有办法在空白屏幕上写字啊？ 会这么想也是有原因的，以前在 Windows 时代我想很多人都折腾过 Rainmeter 之类的桌面美化软件，在桌面上画个画模拟个仪表盘还不是个分分钟的事情…… 那 Mac 上该咋整咧？ Google 了一下，很快就发现了这么个有趣的小玩意：GeekTool 他能干什么呢…… 简单来讲哦，这个小工具可以让你在桌面上定义一个区域，显示一段脚本的输出结果、一幅图、一个网页以及一个日志文件的输出，当然这些东西都是不可交互的。就像这样： 可以看到这里显示了我的一行命令「date」的执行结果…… 这…… 就很他娘的有趣了！ 结合之前的 Things CLI…… 于是空出了左边屏幕，填入脚本： Bazinga！ 可以看到屏幕左边空白显示了我 Things 里面所有待办的事项，右边则显示了我一个固定的 Note.md 里面的内容，我有时候会通过命令行快速记录一些东西，都会记录在这里。 这个脚本会每五秒执行一次，所以基本上你在 Things 里面操作了待办事项之后可以瞬间显示在这里~~ 呼……bb 这么多，至此，我使用 Things 3 的时候遇到的痛点就都解决啦~ 并且还开发出了一个新的信息展示区域~ 开心~ 这个小工具我已经使用了超过一周了，目前运行良好~ 几乎没有什么性能开销，你唯一需要做的就是：空出一块屏幕，定义一个脚本，搞定你的输出，然后 enjoy the DESKTOP！]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>折腾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用 Dayone 写日报的正确姿势]]></title>
    <url>%2F2017%2F11%2F16%2Fwrite-daily-report-with-dayone%2F</url>
    <content type="text"><![CDATA[写日报是个好习惯，管理日记的 Dayone 是个好软件，但是状态栏小工具实在不好用，而且 Dayone 不提供模板，每次写日报的时候都得自己手动写格式，实在是非常烦人。而且每天的日报光有我自己 bb，没啥别的实锤证明我自己干了些什么事， 实在是非常的不大丈夫。 就在我因为懒得开 Dayone 而中断了好多天写日报的时候，我突然发现，Dayone 居然提供 CLI 工具： CLI for Dayone2 良心啊！这可给我高兴坏了，虽然 CLI 提供功能很少（只有新增…… 没有修改查询删除啥的），但是已经够了~ 工具实现了三个功能： 可以用 Vim 直接在命令行里写日报啦 通过使用 Vim 的模板功能，终于可以通过模板新建日记惹（md 格式） 可以自动在日报结尾添加今天的 Git 提交记录作为一天工作的实锤啦 工具设置起来稍微有些麻烦，分几个步骤： 首先需要安装 Dayone2 的 CLI： 1sudo /Applications/Day\ One.app/Contents/Resources/install_cli.sh 然后需要在 .vimrc 里面设置某种文件打开时的模板，把这段话写到 .vimrc 文件的末尾： 1autocmd BufNewFile $YOUR_TMPLATE_FILE_NAME 0r $PATH_TO_YOUR_TEMPLATE_FILE | autocmd! BufNewFile 这段代码的意思是在你使用 Vim 打开符合 YOUR_TMPLATE_FILE_NAME 文件名的文件的时候会自动往里写入给定文件的内容。就是通过这个方法来完成 Vim 模板的设定的~ 你可以自己设定你自己需要的模板~~ 然后接下来是打印当天 Git 提交记录的脚本： 1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/env sh # receive param as query datequery=$1 # make date stringif [ -n "$query" ]; then date=$queryelse date=`date +%Y-%m-%d`fi # set git workspaceworkspaces=$PATH_TO_YOUR_WORKSPACEnames=$YOUR_NAME # recurrsively find git log.for workspace in $workspacesdo # get all dirs repos=`ls $workspace/` for repoPath in $repos do cd $workspace/$repoPath for name in $names do logs=`git log --after "$date 00:00" --before "$date 23:59" --oneline --no-merges --author $name` if [ -n "$logs" ]; then echo "Found logs @ $repoPath, commits list below:\n$logs\n" fi done donedone 注意你需要在这个脚本里定义你的 workspace 和你的用户名哈~ 接下来就是把上面的功能合在一起的 shell 脚本，注意这里我们把上面获取 Git log 的脚本命名为 list_git.sh 放到同一个目录下： 1234567891011121314151617181920212223242526272829#!/usr/bin/bash # ask for emotionecho "今天感觉怎么样？"read ANS # this file name will trigger vim to create a new file with given templatevim $YOUR_TMPLATE_FILE_NAME # get daily contentCONTENT=`cat $YOUR_TMPLATE_FILE_NAME` # get titleDATE=`date '+%Y/%m/%d 周%a'`TITLE="**工作日报 - $DATE**" # get daily git logsdir=`dirname $0`GITLOG=`sh $dir/list_git.sh` # save content to dayone2FINAL_CONTENT="$TITLE\n&gt; 心情：$ANS \n\n$CONTENT \n"if test -n "$GITLOG"; then FINAL_CONTENT="$FINAL_CONTENT \n**Daily Git log** \n \`\`\`\n$GITLOG\n\`\`\`\n"fiecho "$FINAL_CONTENT" | dayone2 new # clean tmp filerm $YOUR_TMPLATE_FILE_NAME 注意这里列出来的两个脚本中均需要你自己替换 $YOUR_TMPLATE_FILE_NAME 为你自己设定的模板文件名哦，不然 vim 不会加载模板的~ 然后就 OK 惹…… 来看看运行效果✧(≖ ◡ ≖✿)： dr 是我的 alias，脚本一开始会让你输入今天的心情………… 然后会进入 Vim 编辑一下……………… 保存，然后日报就进 Dayone 啦： 嗯！希望能治好我总忘写日报的病吧……………… 科科]]></content>
      <categories>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>效率</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用羊角符号￥的正确姿势]]></title>
    <url>%2F2017%2F05%2F09%2Fright-way-use-yuan%2F</url>
    <content type="text"><![CDATA[最近写 UI 的时候遇到个蛮有意思的问题，事情是这样的：我要用 TextView 展示一段标识价格的文字，如「￥23333」，这件事本来完全不会往心里去，随手就这么写了： 1mTvPrice.setText("￥23333"); 有毛病吗？没毛病，IDE 里面也显示的好好的： 但是到了手机上就成这个屌样子了： 看到没，双横线的人民币符号变成了单横线的人民币符号，喵喵喵？心态有些崩…… 不过，喵归喵，问题既然出现了那就一定得想办法解决嗯……那么现在有这么几个问题需要查一下： 单横线的人民币符号和双横线人民币符号哪个是受官方承认的？ 为什么在 App 上有的地方是双横线，有的地方又是单横线？ 我应该怎么安全的写出正确的双横线人民币符号？ 第一个问题，双横线的人民币符号是受官方承认的，wiki 里人民币的定义： 人民币在 ISO 4217 简称为 CNY（“CN” 一般用于表示中华人民共和国；“Y” 即拼音 Yuan 的首字母，是 “Chinese Yuan” 的缩写），离岸人民币简称为 CNH，不过更常用的缩写是 RMB（Ren Min Bi）；在数字前一般加上 “¥”（取 “YUAN” 的首字母 “Y”，上面加一个 “=” 号）表示人民币的金额。 所以，双横线的确是人民币官方符号，那么这是否代表着单横线的人民币符号有问题呢？非也，在翻阅一些资(zhi)料(hu)之后，笔者发现，单横线的羊角符号其实是一种「习惯性用法」，在国家对人民币符号做标准化之前，这两种符号因字体间差异而处于相当大程度的混用中，在很长一段时间内，各大电商网站在做人民币符号标识时都存在差异。而在国家进行标准化之后，双横线的羊角符号被推荐替代单横线的羊角符号使用。 OK，暂时线松了一口气，线上的单横线羊角符号暂时还不会导致华哥被开除，那么就是接下来的问题：为什么在 App 中有的时候是单横线有的时候是双横线？ 这个问题在搞懂上面的问题之后就很简单了，单横线其实是全角的双横线羊角符在不同的字体下的一个形式变体——简单地说，这就是个全角的羊角符，而这个全角羊角符在手机系统中只显示一根横线。至于使用羊角符号时，是应该使用全角羊角符还是半角羊角符，知乎里面也有比较清楚地讨论： 因为人民币符号多是与半角阿拉伯数字相邻使用而非在汉字文本流中独自出现，所以建议通常使用其半角版本，以保证货币符号与数字的空间关系及字体设计协调。 全角人民币符号「￥」只是个历史遗留字符，如今通常不会用到，它和半角人民币符号「¥」也没有语义差异。 话说到这里，必须插一句，网上有一些意见认为，单横线的羊角符号是日元符号，其实这里是个误解，wiki 里日元的定义： 日圆（日语：円〔圓〕／えん〔ゑん〕，日语罗马字：Yen1），亦简作日元，全称为日本圆，货币符号为 ¥，国际标准化组织 ISO 4217 的货币代码为 JPY，是日本的官方货币。其发行制造机构为日本银行，纸币称为日本银行券。 看到没，人民币和日元如果仅论符号，两种货币符号都是￥，他们的区分是通过羊角符之前的拉丁字母区分：CN￥/ JP￥。 所以，为了纠正 App 里面有碍观瞻的单横线羊角符号就很简单了，全局搜索全角羊角符，替换为半角羊角符即可。 OK，上面两个问题解决之后，基本整件事就很清楚了——开发者错误的使用了全角羊角符，导致在手机上某些机型的字体显示为了单横线的羊角符。那么如何去避免这件事呢？笔者大致总结了一些方案： Mac 下的搜狗输入法在中文输入环境下通过「Shift+4」会输入全角羊角符「￥」，而在英文输入场景下通过「Shift+4」会输入半角美元符「$」所以直接用快捷键输入是不会得到正确结果的。不过如果你用搜狗输入法的话，可以尝试在中文输入环境下键入「rmb」，输入法会自动提示给你正确的半角羊角符「¥」。 保存一份正确的羊角符，一个生十个，十个生百个…… 定义静态的 StringFormat，把金额当参数输入，输出正确的金额 String OK 本文到这里就差不多了，罗里吧嗦的写了不少，全当记录一件蛮有意思的事了嗯]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BitmapFactory.decodeResource 原来只能加载「图片格式」的资源啊……]]></title>
    <url>%2F2017%2F05%2F03%2Fproblem-in-decode-resource%2F</url>
    <content type="text"><![CDATA[今天在用公司提供的网络图片加载控件进行开发的时候，因为图片上有个蒙层的需求，所以很自然的调用了这个图片加载控件的 setOverlay(int resId)的方法，用来加载一个事先定义在.xml中的方形 Shape。 代码很简单，吭哧吭哧的写好之后插电运行——啪，崩崩崩。顿时懵逼了，不至于吧，写个这么简单的数据绑定逻辑都能蹦蹦蹦？赶紧拉报错堆栈来看，唔，一个NPE的错误->一个 Bitmap 为空->传入的这个 Overlay 的 Bitmap 为空->嗯……那就是这句话得到的 Bitmap 为空咯： overlay = BitmapFactory.decodeResource(getContext().getResources(), overlayResId, options) 我凭实力传入的ResId凭什么解析不出Bitmap！但是它还真的就不会返回 Bitmap，我们看看他的代码段： 12345678910111213141516171819202122232425262728293031323334353637383940/** * Synonym for opening the given resource and calling * &#123;@link #decodeResourceStream&#125;. * * @param res The resources object containing the image data * @param id The resource id of the image data * @param opts null-ok; Options that control downsampling and whether the * image should be completely decoded, or just is size returned. * @return The decoded bitmap, or null if the image data could not be * decoded, or, if opts is non-null, if opts requested only the * size be returned (in opts.outWidth and opts.outHeight) */ public static Bitmap decodeResource(Resources res, int id, Options opts) &#123; Bitmap bm = null; InputStream is = null; try &#123; final TypedValue value = new TypedValue(); is = res.openRawResource(id, value); bm = decodeResourceStream(res, value, is, null, opts); &#125; catch (Exception e) &#123; /* do nothing. If the exception happened on open, bm will be null. If it happened on close, bm is still valid. */ &#125; finally &#123; try &#123; if (is != null) is.close(); &#125; catch (IOException e) &#123; // Ignore &#125; &#125; if (bm == null &amp;&amp; opts != null &amp;&amp; opts.inBitmap != null) &#123; throw new IllegalArgumentException("Problem decoding into existing bitmap"); &#125; return bm; &#125; 确实啊，人家白纸黑字的写了，这个方法要么返回一个从原始图片文件得到的 Bitmap，否则返回 null，而且传入的 Option 参数也是对应的类似采样率这样的图片编码相关的需求——这段代码的的确确只能用来将「原始的图片文件」加载为 Bitmap，是我用错了资源类型，锅在我自己脑袋上。 但是光是找到问题还是不够的，得好好想想这个问题：为什么我会在一开始看不出这个问题——对 Bitmap 和 Drawable 概念的混淆是我没能及时定位这个问题的最大原因。Bitmap 是一个比 Drawable 更加底层的概念，它对应的是每个像素点在内存里的数据，而 Drawable 则是一个抽象的概念，他是 Bitmap 的超集，一个Drawable 对象可能来自于 xml 定义、来源于 .jpg/.png 文件、来源于 Bitmap。 但是这里最大的锅还是在平台——平台提供的setOverlay(int resId)方法显然并没有对于这些不同的 Res 作区分，默认其均为 .jpg/.png 文件的资源，并使用加载 Bitmap 的方法去加载这些资源，而调用者对于此一无所知，既没有方法名上的提醒，也没有文档的提醒，自然在使用时会出现问题。 这里还是总结一下两个经验教训吧：1. 对于 Bitmap 和 Drawable 的基础概念需要有明确的辨识；2. 对于 API 设计需要考虑调用者的使用情景，不能想当然的给出方法，如果确实如此，则需要给出详细的文档作参考。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Travis-CI 更新博客]]></title>
    <url>%2F2017%2F03%2F16%2Fupdate-blog-by-travis%2F</url>
    <content type="text"><![CDATA[这几天在了解travis-ci的时候偶然发现Hexo的作者正在用它更新Hexo的官方网站，仔细一想还真的很适合——大部分利用Hexo搭建的技术博客基本都依托于Github.io，而 Travis-CI 在面向 Github 上的开源项目时是免费的，而且 travis-ci 的机制也决定了它在更新博客push内容这一点上是有得天独厚的优势的…… 嘛，其实整个过程都很简单，本来还打算写一写，不过又觉得其实过程真的大同小异，下面给两个链接作为记录好啦。 用 Travis CI 自動部署網站到 GitHub - Hexo 作者 Blog使用Travis CI自动部署Hexo 嗯。本文就是本博客利用 Travis-CI 部署的第一篇博客啦。科科。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Travis-ci</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新安装App启动后Home键回到桌面后再次启动App时会再次启动入口页面的Bug追踪记录]]></title>
    <url>%2F2017%2F01%2F20%2Flaunch-bug-record%2F</url>
    <content type="text"><![CDATA[测试同学近日在测试中发现了这么一个Bug，复现步骤如下： 打开应用 任意开启一个页面 Home键回退到Launcher 重装应用 打开应用 任意开启一个页面 Home键回退到Launcher 点击应用图标启动应用 Bug出现了：此时应用并没有如预期般直接将Task带到前台，而是开屏页一闪而过，然后就回到了应用的主页面 我们知道，每次发起Intent导致新创建Task的时候，该Task会记录该Intent的信息；如果后续有一个新的Intent出现并与该Task的启动Intent完全一致（启动类，action、category等等全部一样，不可多项也不可缺少），那么该Intent并不会触发Activity的新建与启动，而只会将已经存在的Task移到前台。 那么为什么会出现如bug所述那样的问题呢？下面按照Bug浮现步骤来捋一捋： 首先定义一下，L为Launcher，P1为开屏页，P2为主页面，P3为任意一个其他页面。不同task用|分割，相同task的页面用/分割。 打开应用：L -> L|P1|P2 -> L|P2 任意开启一个页面：L|P2/P3 Home键回退到Launcher：P2/P3|L 重装应用：L 打开应用：L -> L|P1|P2 -> L|P2 任意开启一个页面：L|P2/P3 Home键回退到Launcher：P2/P3|L 点击应用图标启动应用，Bug复现 OK，这里我们看到的现象是，一个新的Task被创建了，并且新的页面立刻就销毁了，然后由于以singleTask启动主页面的时候发现已经存在了这个Task，于是把原来的Task立刻带到了前台，并出栈了所有栈顶的页面： 启动：P2/P3|L -> P2/P3|L|P1 以singleTask启动新的P2，退出P1，将原有的P2/P3带到前台并将P3出栈：P2/P3|L|P1 -> L|P2 回想我们之前提到过的一个很重要的一点：如果创建Task的Intent和某个期望启动应用的Intent一模一样，那么该Task会被带到前台，否则会重新创建Task。那么这里会不会是在这里出问题呢？ 我仔细回想了Bug的复现步骤，发现在「5. 打开应用」这一步中遗漏了一个非常重要的细节：我们似乎是在安装完应用之后直接点击「打开应用」启动的应用 —— 问题就出在这里，「打开应用」对应的Intent和Launcher中的Intent其实是不一致的——至少在某些方面是无法匹配的，那么通过这种方式启动的Task和点击Launcher图标启动的Task自然是无法相容了，出现Bug中的现象也就解释的通了。 为了验证想法的正确性，我再次重复了一次上述的步骤，只不过在第五步「5. 打开应用」中，并没有直接点击「打开应用」，而是退回到桌面，点击Launcher中应用的icon来启动应用。果然，这一次没有再发生之前的问题。 那么，我们该如何在应用中防止这种状况的发生呢？在网上寻求解答的时候发现了这篇文章，他也遇到了和我一样的问题，而他的解决思路则是在开屏页另外发起一个与Launcher相同的Intent请求启动应用。这个方法是否有效以及有没有副作用这里不做探讨也没有尝试过，如果有读者（哦我的文章没有读者）感兴趣的话，可以自己试一试嗯。 这是次很神奇可能也很微妙的Bug复现及追踪记录，这个问题并不算什么大问题，但是在追踪这个问题的过程中也让我对于App的启动方式有了新的理解，所以这里稍微记录一下，留以存档。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你真的会使用 Scheduler.io() 吗？]]></title>
    <url>%2F2017%2F01%2F16%2Fscheduler-io-error%2F</url>
    <content type="text"><![CDATA[最近堆糖6.7.0版本正在准备上线，在堆糖最近的灰度版本中我们观测到了许多不正常的OOM——来自于各种方面的OOM都有，非常奇怪。有很多代码都是没有改动过的，但是这次灰度版本中却发现因为OOM的关系FC了。不过由于在6.6.0到6.7.0两个版本中间被我改动了近3W行代码，所以顿时浑身冷汗，担心是不是在某个未知的角落的改动造成了问题。 光靠想不起作用，打开Fabric，老老实实一条条崩溃记录的检查吧。第一遍看下来，没什么头绪，发现的唯一的特征是多数OOM发生在RxJava的调用过程中——但是依然有少量OOM和RxJava毫无关联。回想了一下，这个版本似乎并没有升级过RxJava的依赖版本，问题应该不是出在RxJava本身。 继续追崩溃日志，有一个异常点突然引起了我的注意——在这些所有的崩溃记录中，线程数都异常的高： Android/Java虚拟机的线程资源是有限的，在这么高的线程数之下，这个程序基本也活不了太久了……这篇文章大致讲述了Java虚拟机的线程资源与堆栈大小之间的关系，有兴趣的可以看一下。 OK，OOM的根源基本定位到了——超高的线程分配数是罪魁祸首——那么这些超高的线程数是怎么来的呢？我们继续研究报错堆栈。很快，在报错栈的线程列表中，我们发现了大量名为「RxIoScheduler-xx」的线程： 看到这里，熟悉RxJava Scheduler的使用的同学一定联想到了线程调度符Schedulers.io()，在处理异步的IO动作时，我们正是通过这个将工作调度到IO线程中，在RxJava中的具体实现则是通过一个类似CachedThreadPoolExecutor的线程池来承载业务、分配线程，这个线程池的线程数会随需求的增减动态改变。 到这里不难看出，疯狂增长的线程数肯定与这个IO调度有关，但是为什么会出现这种状况？IO操作符的使用难道哪里出了问题？ StackOverflow一下，果然，有个哥们和我一样遇到了同样的问题，而他的解决方式则是：在完成异步操作之后，显式的调用subscriber.onComplete()来终结这次Subscription。经过实践，确实通过在所有耗时操作结束之后调用onComplete方法，能够有效地释放线程资源，线程数也恢复了正常。 知道怎么做是不够的，为了搞清楚这究竟是怎么一回事，我们接下来从源码部分简单的看看Scheduler究竟做了些什么： 首先我们从入口方法 subscribeOn(Scheduler scheduler) 开始： 123456public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) &#123; if (this instanceof ScalarSynchronousObservable) &#123; return ((ScalarSynchronousObservable&lt;T&gt;)this).scalarScheduleOn(scheduler); &#125; return create(new OperatorSubscribeOn&lt;T&gt;(this, scheduler));&#125; scalarScheduleOn 部分的我们忽略，这个方法实际上是利用Scheduler对象以及原本的Observable对象，重新生成了一个Observable对象，下面看看在构造OperatorSubscribeOn的时候做了些什么事： 1public final class OperatorSubscribeOn&lt;T&gt; implements OnSubscribe&lt;T&gt; OperatorSubscribeOn 实现了 OnSubscribe 接口，实际上就是另一层最初的OnSubscribe的封装，我们主要看看对应的call(Subscriber subscriber)方法中做了些什么： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public void call(final Subscriber&lt;? super T&gt; subscriber) &#123; //创建一个worker对象 final Scheduler.Worker inner = scheduler.createWorker(); //注册这个worker对象 subscriber.add(inner); //worker对象将本操作符之前的所有操作打包，放入其所在的线程池(io)中等待执行 inner.schedule(new Action0() &#123; @Override public void call() &#123; final Thread t = Thread.currentThread(); //将原本的subscriber重新组装 - 在这次封装中包含了对于worker对象的取消订阅操作 Subscriber&lt;T&gt; s = new Subscriber&lt;T&gt;(subscriber) &#123; @Override public void onNext(T t) &#123; //注意！这里只调用了onNext，并没有取消对于源的订阅！这也是为什么只调用onNext不调用onComplete或onError不会取消订阅者对于发送者的订阅的原因 subscriber.onNext(t); &#125; @Override public void onError(Throwable e) &#123; try &#123; subscriber.onError(e); &#125; finally &#123; //取消了订阅 inner.unsubscribe(); &#125; &#125; @Override public void onCompleted() &#123; try &#123; subscriber.onCompleted(); &#125; finally &#123; //取消了订阅 inner.unsubscribe(); &#125; &#125; @Override public void setProducer(final Producer p) &#123; subscriber.setProducer(new Producer() &#123; @Override public void request(final long n) &#123; if (t == Thread.currentThread()) &#123; p.request(n); &#125; else &#123; inner.schedule(new Action0() &#123; @Override public void call() &#123; p.request(n); &#125; &#125;); &#125; &#125; &#125;); &#125; &#125;; //将重新组装之后的subscriber重新用源observable订阅起来 source.unsafeSubscribe(s); &#125; &#125;);&#125; 在上面的代码我们看到，在新生成的OnSubscribe对象中，当call方法被调用时，Scheduler对象会生成一个worker对象，作用是将该操作符之前的所有动作一起打包放到该worker所在的线程池中执行任务，并且worker对象也实现了subscription接口，可以用于取消本次任务订阅。 可以看到，在向worker所在的线程池发出任务的时候，实际上是重新封装了一个Subscriber，并让该Subscriber重新订阅发射源，在onNext方法中并没有将该worker对象取消订阅，只在onComplete方法和onError方法中调用了worker对象的取消订阅相关的代码——这也是为什么在使用该操作符时如果不手动处理订阅或显式调用onComplete就无法完成自动取消订阅的原因。 其实在worker对象的生成、io线程的底层CachedThreadPool实现以及worker对象的取消订阅这些方法也有很多内容，不过不属于本篇内容，这里就不做过多叙述，有兴趣的读者（我知道这文章没啥读者- -）可以自己读读源码。讲道理，RxJava的源码算是我读过的代码里面相当恶心且绕且难懂的代码了……要读下去真的需要一些耐心…… 言归正传，最终我们得出了这么一个结论： 如果不是直接使用类似于just、from、zip等等已经封装好的操作符，而是直接新建onSubscribe对象，自己处理subscriber的onNext、onError等操作的话，最好是能做到在正确返回数据时调用onNext，在错误时调用onError，并且保证在所有动作处理结束之后能够调用onComplete动作结尾。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆糖Android首页的列表性能优化记录]]></title>
    <url>%2F2017%2F01%2F15%2Flist-opt%2F</url>
    <content type="text"><![CDATA[在堆糖6.7.0版本中，首页经过了较大的改版，从原有的单页面列表页改为由8个横向滑动的页面经由ViewPager承载，每个页面都是一个包含8种cell类型的列表页。在某些cell中还包含了占据较高面积比例的图片，而且这些图片的展示对于清晰度还有需求——毕竟堆糖图片社交出身，不同于普通的新闻客户端，堆糖对于列表项中的图片精细度还是有些追求的。 小林是这次首页改版业务的开发负责人，接到任务之后很快就基本完成了页面开发——堆糖有一套通用的List页面实现，集成了状态控制、下拉刷新、上拉加载等列表页通用功能，开发者仅需要对于每个cell的view进行开发即可，效率很高。 然而，在后端数据就绪开始联调的时候却发现列表存在较为严重的卡顿状况。首页是一个应用的门脸，是用户使用频次最高、操作最频繁的部位，这种流畅度是不可接受的。于是我开始着手review小林的代码期以提高列表页面的浏览流畅度。 追踪高开销的绑定操作列表项的创建、绑定数据操作是主要的耗时来源，review中也是从这里着手开始分析耗时操作。由于堆糖所有列表页都继承于同一个实现，因此我们可以很轻松的追踪到我们在绑定列表数据的时候究竟耗时情况是怎么样 123456789//bind datalong startTime = 0;if (BuildConfig.DEBUG) &#123; startTime = System.currentTimeMillis();&#125;setupItem(holder.itemView, ((ItemVH) holder).type, position, data);if (BuildConfig.DEBUG) &#123; P.d(String.format(Locale.getDefault(), "Bind data cost %d ms, Holder type= %d",(System.currentTimeMillis() - startTime), ((ItemVH) holder).getItemType()));&#125; 这里setupItem是一个抽象类，是所有item绑定数据的入口方法，通过这段代码，我们在Logcat中立刻就定位到了耗时非常严重的几个item类型。 工作线程提前处理数据，避免主线程重复操作数据我们首先定位到了这么一段代码： 12345if (view instanceof CommonAdItemView) &#123; CommonAdItemView commonAdItemView = (CommonAdItemView) view; commonAdItemView.setData(GsonUtil.parseJson(data.getEntity(),HomeItemModel.NormalAdModel.class));&#125; 后端在返回的数据实体里针对不同的数据类型返回了不同类型的真实数据实体entity，客户端需要本地根据数据实体提供的类型参数二次解析为特定的可用的数据实体绑定进item。 但是在这段代码中我们看到，每一次绑定操作都调用了一次Gson的反序列化操作以生成数据实体——Json的解析与对象的拼装是一件非常耗时的事情，涉及到的IO、反射都是重性能开销操作，这里不仅错误的在主线程绑定数据时进行Json解析，而且没有做任何缓存处理，同一段数据会被不断地反序列化——哪怕这段数据实体已经被反序列化过了。 正确的做法应该是在网络框架返回数据之后，在工作线程将数据实体按照对应的规则解析并保存到相应的对象中返回，在使用的过程中无需再做任何的反序列化操作了。 处理完这一点之后，发现确实列表在加载时的卡顿感减轻了不少，但是在快速滑动列表的时候依然会出现丢帧、跳页的现象，没关系，我们的优化才刚刚开始。 谨慎分配高占用对象在代码中我们发现了这么一段： 1234567for (int i = 0; i &lt; (blogModels.size() &gt;= 3 ? 3 : blogModels.size()); i++) &#123; …… AlbumImageView imageView = new AlbumImageView(getContext()); imageView.loadImageWithDp(blogModels.get(i).getPhotoUrl(), 112, 112); binding.layoutImgs.addView(imageView); ……&#125; 这段代码的原意是，在一个线性布局容器中根据返回图片数量的多少将图片控件生成并添加到线性布局中。这段代码如果不是在列表项中，是没有任何问题的，很灵活也很高效，但是在列表项中这样的做法就存在很严重的问题了——在每一次绑定数据的时候都经历了：清空线性布局中的图片控件、新建若干图片控件、部署若干图片控件、图片控件载入图片若干步步骤，其中清空布局并重新部署控件会引起控件的重新绘制，这是性能开销其一；其二，每次都新建图片控件并在其上载入图片，既付出了额外的性能时间消耗，更大大加重了内存负担——内存占用飙升、GC被频繁触发——所以，在item的数据绑定过程中，大对象的分配、布局的更新重绘等操作一定要谨慎，能够重用的一定要重用，不需要刷新布局的情况下尽可能低性能开销的数据绑定方式。 优化列表项的布局层级绑定数据部分的问题基本被排查完毕之后，似乎setData部分已经从逻辑上没什么问题了，列表的加载现在的确相对之前顺滑了一些，渲染时间直方图也没那么吓人了，但从主观使用角度上看，还是显得有些卡顿，从客观的渲染时间直方图上看来，主线程上的渲染耗时还是存在优化的空间，于是此时我们开始检查View的渲染层级问题。 果然，在自定义View的时候，代码中采用的是组合式的定义方法，继承自一些ViewGroup，将定义好的xml文件inflate进该布局。但是在布局文件的定义中并没有使用merge标签，这也导致了在所有的item上都存在一层多余的布局。 与此同时，代码中多次使用了线性布局的嵌套来完成一些复杂控件的布局，然而实际上这些布局并没有那么高的灵活度需求，直接使用相对布局完成控件平铺摆放实际上已经达到了设计要求。 针对以上两点，我们也针对性的对布局文件进行了调整，很多item缩减了至少两层视图层级，这无疑也提升了view的渲染速度。 检查错误的图片加载操作处理完这上述几点之后，列表的滑动卡顿感得到了一定程度的缓解，但是我们依然在列表加载大量图片的时候感受到了深深地卡顿感，于是我们将矛头转向了图片加载相关的处理实现上去寻求解决方案。 堆糖在加载网络图片的时候，CDN会根据请求末尾附的图片缩略/裁切规则返回最适合当前控件尺寸的图片，因此，在编写加载网络图片的代码时有一项约定，即开发者必须将待加载图片的控件实际宽高像素值传入图片加载方法作为方法参数，以此加载到最适合当前控件的图片，避免了图片过大带来的内存问题。 这里我们插一句题外话——为什么要显式的对加载图片的宽高进行设定？让图片控件自己获知其宽高难道不行吗？毕竟在每个地方都传入参数还是很烦人的，我只需要传入一条图片的原始url就能正确的加载出图片难道不是美滋滋？ 这个问题我们也曾经认真的思考过、试验过，但是最终还是放弃了，原因有以下两点： 首先，自动获取控件的大小不是做不到，有很多方法可以完成，但是要么需要通过在消息队列队尾postRunnable来实现，要么需要手动设置ViewTreeObserver监听并手动取消监听来实现——前一种方法会造成图片加载在刚开始的时候有延迟，后一种方案在某些机型上会产生无限循环调用该方法的问题，所以最终都没有采纳。 第二，即便我们能正确、快速、无性能消耗的获取到控件的大小——这种方式依然有一个最致命的缺陷摆在我们面前：我们永远只有在获取到图片控件实际大小之后才能发出load图片的请求——实际上load图片和图片控件渲染到屏幕上是两个并行的过程，我完全可以向图片框架发出加载图片的请求的同时将图片控件布局到屏幕中，并在图片控件布局到屏幕上之后将根据图片加载框架的图片返回情况将图片内容渲染上去，也就是说，如果我们采用自动获取图片控件大小的方式加载图片，我们永远只能将「获取图片控件宽高」和「加载图片」这两个步骤串行执行，这是绝对无法接受的。 事实上，开发者在完成加载图片的代码写作的时候，在绝大多数情况下对于图片控件的大小都是可知的，无论是像素值还是DP值，都可以通过简单的计算得到。在开发过程中增加这种并不会为开发者带来太大负担的约定，对于整个应用的图片加载性能的提升却是显著的。 OK，话说回正题，在检查图片是否加载正确这一点时，我首先利用mitmproxy抓取了加载这个列表时加载的图片url，在分析图片url的时候，发现某些图片url返回的图片尺寸出奇的高，这是很不正常的一件事，首页列表项中的图片大小实际上只有300*300左右的大小，但是竟然有些url返回的图片大小超过了1000*1000像素。于是我开始检查加载图片的相关代码，果然，在应该传入控件px值的地方，我们错误的调用了应该传入dp值的方法，于是加载的实际大小尺寸几乎是原本尺寸的三倍。 将这些方法修正之后，首页的卡顿得到了巨大的缓解，抖动的内存终于平复了下来。 在肉眼可接受范围内降低加载图片的精度俗话说得好，开发是很简单的，优化是无止境的，难道首页的体验优化就到此为止了吗？当然不。实际上，在完成上述多个地方的优化之后，首页的卡顿感已经减轻了许多了，只是在一些相对低端的手机上，列表的滑动体验依然有继续优化的空间。 我们相继研究了今日头条、网易新闻、腾讯新闻等等类似的客户端的列表滑动表现，其中今日头条的列表性能表现令我们深感意外——在有许多图片的情况下依然保持着相当高的顺滑度，那么他们是怎么做到的呢？在注意到头条新闻配图似乎都有那么一点点糊的这一点之后，我们对今日头条列表加载时载入的图片进行了分析。果然，头条在载入图片的时候并没有完全按照控件大小去一比一的加载对应分辨率的图片，而是选择加载相同比例，但是对于分辨率进行缩减之后的图片。什么意思呢？就是说，一个空间大小为300*300像素的图片控件，只对应的请求120*120的图片。 这样做的好处是显而易见的，首先，小图片传输速率快，能够更快的从服务器获取到本地；其次，小图片在解码效率、渲染时间、内存占用上也相对于一比一的大图更加高效；最后，适度的降尺寸加载图片实际上并不会影响到用户对于图片的观感。因此，在产品认可的情况下，适度的降低列表项图片的显示质量，既可以提升图片加载速度，又可以降低CDN的流量消耗，是个很不错的优化思路。 试试看滑动的时候不加载图片呢？在降低图片精度的同时，我们也尝试了与微博相似的做法——在列表滑动的时候不载如图片。在fresco框架中实现这一点并不难，我们只需要在 Recycler的ViewOnScrollListener中做如下控制即可： 1234567891011121314@Overridepublic void onScrollStateChanged(RecyclerView recyclerView, int newState) &#123; super.onScrollStateChanged(recyclerView, newState); if (newState == RecyclerView.SCROLL_STATE_SETTLING || newState == RecyclerView.SCROLL_STATE_DRAGGING) &#123; if (!Fresco.getImagePipeline().isPaused()) &#123; Fresco.getImagePipeline().pause(); &#125; &#125; else &#123; if (Fresco.getImagePipeline().isPaused()) &#123; Fresco.getImagePipeline().resume(); &#125; &#125;&#125; 这样做确实能够让列表如飞一般的滑动，但是有个很重要的问题也同时存在：当列表停止滑动之后需要等一小段时间图片才会慢慢地加载出来，这一点在跟产品聊过之后被很强硬的否定了——其实也可以理解，堆糖毕竟不是一个真正的「信息流」应用，用户在使用内容流列表的时候，对于内容的呈现质量的要求其实并不算低。太长时间的等待加载图片对于用户的体验其实是种损害。 总结至此，基本上首页的列表相关的优化已经结束了，从一开始的卡到飞起，到现阶段基本稳定在16ms的渲染延时基线下，堆糖的首页优化也暂时告一段落。本文中提到的若干列表优化的方法和思路是今后进行列表项开发时必须时时刻刻牢记在脑海中的principle，本文也作为一次我在列表性能优化方面的体会的总结。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>List</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用RxJava.combineLatest时犯的错误总结]]></title>
    <url>%2F2017%2F01%2F14%2Frxjava-combinelatest%2F</url>
    <content type="text"><![CDATA[最近在做页面开发的时候遇到这么个问题：我在一个页面同时请求了3条API，通过CombineLatest进行组装，返回一个合成之后的结果用于UI展示。但是在实际使用过程中，我们发现，API正常的返回了数据，但是List的数据绑定发生了两次。经过排查，发现问题出来对于CombineLatest操作符的理解错误上：我错误的认为「CombineLatest会将所有传入的Observable通过FunN组合后返回一个结果」。实际是怎样的呢？我们来看看官方文档中的描述： Combines a list of source Observables by emitting an item that aggregates the latest values of each of the source Observables each time an item is received from any of the source Observables, where this aggregation is defined by a specified function. 以及官方文档里面的流图： 所以不管是流图还是文档描述中，都强调了「每次接收都会根据前次source合并出一个结果」，所以其本质上是「把一系列的输入先后合并然后输出合并之后的结果」，而不是我最早理解的「将所有输入源的发射内容一起合并之后返回」。如果要实现我所需求的效果——将多个观测源的输出结果合并之后输出——还是应该老老实实用zip操作符。 OK，其实如果我在用之前有认真读过这些说明和流图之后应该就不会犯这个错误了，但是这个操作符接受多个Source的重载方法确实很具有迷惑性。 所以今后在使用一些新的方法、尝试一些新的内容的时候，第一点需要认真的读一下这些方法的文档，大多数成熟稳定技术的文档还是很健全的。第二点是，在使用过程中需要好好地检查输出结果是否符合预期——实际上在两个输入源的状况下，combineLatest的行为是符合我们预期的，但是在多个输入源的状况下，问题就凸显出来了。这个时候就需要我们能够准确的发现问题，然后解决这些问题。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几行伪代码解决大多数 View 触摸事件传递的问题]]></title>
    <url>%2F2017%2F01%2F13%2Fview-touch-event%2F</url>
    <content type="text"><![CDATA[看书的时候总结了一下View触摸事件的传递逻辑。这里用伪代码写写看。 Activity / Window / ViewGroup 处理触摸事件的逻辑： 123if(!dispatchTouchEvent(e))&#123; onTouchEvent();&#125; View 中 dispatchTouchEvent 的逻辑： 123public boolean dispatchTouchEvent(MotionEvent e)&#123; return onTouch(e) || onTouchEvent(e);&#125; ViewGroup 中 dispatchTouchEvent 的逻辑 1234567public boolean dispatchTouchEvent(MotionEvent e)&#123; if(onInterceptTouchEvent(e))&#123; return onTouch(e) || onTouchEvent(e); &#125; else &#123; return child.dispatchTouchEvent(e); &#125;&#125; 当然里面还有各种问题，但是把握好主干总是会让我们在学习这部分知识的时候更加有针对性。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 热修复技术学习笔记]]></title>
    <url>%2F2017%2F01%2F08%2Fandroid-hotfix-note%2F</url>
    <content type="text"><![CDATA[引言对于热修复技术的了解、认识从很久之前就开始了。但是因为没有业务上的驱动力，对于许多业内很火热的框架技术只是浅尝辄止的了解了一下，并没有更加深入去了解这些技术。下季度堆糖不出意外会引入热修复框架，这也为我提供了一次去了解、学习热修复相关技术的一次机会。 这篇文章可能更多的是倾向于「学习笔记」，只是起一个拾遗、拾忆的作用，不会太过深入代码，也不会针对一些具体实现纠结过多，所以有不详细、不确切、含糊不明的地方，还请各位看官（如果有的话- -）拿起手中的 Google 自己去探究吧科科。 文末附有本文所有参考借鉴过的文章的链接，感谢这些厉害的程序员在这一领域中做出的杰出贡献。 总览本文不对热修复的概念做过多探讨，简单来讲，不发布新版本即完成对线上应用运行的代码进行更新的操作都能被算作热修复，所以像ReactNative/Weex这些从网页技术衍生来的混合开发技术其实也是一种热修复，只不过这些技术更加倾向于「业务更新」而不是「错误修复」，因此并不在本文的讨论范畴中。 按照主流的分类方法，Android生态内的热修复方案主要分为两个「流派」，每个流派又有不同的处理问题的思路： Native Xpose/AOP - Dexposed Native method hook - AndFix Java Classloader - Qzone/Nuwa/RoocoFix.. Byte Code Injection - Robust/Instant Run-冷插拔 Dex replace - Tinker/Instant Run-热插拔 下面我们会对每个「流派」比较有代表性的技术及其背景进行介绍和比较，我们在选择热修复技术的时候主要针对以下几个方面进行比较。 Native 部分主流的Base Native 的热修复方案除了AndFix还活跃在主流的热修复框架中，其余的框架基本都处于欠维护状态。下面我们挑选两个比较有代表性的框架进行简单的介绍和比较： Dexposed基于Xposed开发的AOP框架，方法级细粒度，来自手淘团队。Xposed需要Root权限，但是对于单个应用而言并不需要Root。其利用 Xposed 框架修改Android Dalvik运行时的Zygote进程，并利用Xposed Bridge hook方法并注入自己的热修复代码，以达到非侵入的runtime修改。 应用启动时会fork zygote 进程，装载各种class 和invoke各种初始化方法，xposed框架就在这个时候替换了app_process，hook了各种入口级方法，从而实现之后的各种方法前后的拦截。Dexposed的hook并不限制于应用本身的业务代码，任何应用运行时执行的方法都可以进行hook，在绕过一些Android系统本身的Bug这种普通方式很难完成的事情上有着得天独厚的优势。 不过Dexposed框架因为无法支持ART虚拟机（Xposed不支持ART虚拟机），在ART渐渐成为Android主流虚拟机的现在显然已经不能满足需求，并且该项目目前已经停止维护了。 AndFixAndFix是来自Alibaba团队的另一个热修复框架作品，阿里百川的 Hotfix方案就是基于该方案统一工具链修改而来。该框架的原理和Xposed在大范围内对native方法进行hook不同，AndFix只对需要修复的方法进行hook。hook的原理很有意思： 开发人员对线上问题进行修改，修改完后通过工具检查新代码和问题代码之间的方法差异，并将这些差异信息写入smali文件，并在每个方法前增加注解标注，然后将所有差异信息打包生成dex文件，连同许多安全校验信息一起打包下发到问题客户端。客户端得到补丁信息之后开始在程序开始的时候载入带有修复方法的dex，然后根据dex中注解提供的参数遍历并找到原有dex中需要替换的方法，找到方法之后首先修改需要替换的方法为native方法，然后在native层对这个方法的调用进行hook，将其指向补丁包中的对应方法地址，以此完成对于方法的替换。 具体的代码这里就不贴了，有兴趣的可以点击文末的链接进去仔细阅读。这个方法最大的优点是足够动态，理论上可以不用重启替换所有的方法，修改基本是即时生效的。而缺点也很明显，该方法不能动态的增减类中的字段，对部分机型不支持，修改之后的方法参数类型也有限制，而且同一个方法不能进行多次patch。 所以AndFix最适用的场景可能还是对于线上突发问题的修复，替换部分问题方法，让用户免于崩溃，至于说新增业务，资源替换，或者是较大规模的修改，可能比较力不从心。不过AndFix的思路真的很有意思，值得学习借鉴。 Java 部分从上面的叙述中我们不难看出，Native层面上的Hotfix其主要的思路还是寻找Java调用与Native调用的结合点，在这种情况下，新增方法、修改资源等难以与Native结合的问题点相对而言就比较无能为力了。在这种状况下，一些Java世界中的热更新框架也渐渐出现在开发者面前。 前置知识在进行框架介绍之前，可能有一些前置知识需要简单的介绍一下，否则后面的内容将难以理解。 一个应用是怎样从代码变成手机上运行的程序的？分开讲吧，我们先来看看一个可以安装到手机上的.apk文件是怎样构建出来的吧： 使用aapt打包资源文件，生成 R.java 文件 清单文件、资源文件都会被编译，生成唯一ID放入R.java 处理AIDL文件，声称对应的.java文件 使用Javac编译器编译所有的源代码.java文件，生成JVM使用的.class文件 在这一步中如果配置有混淆，那么将使用ProGuard将.class文件中的字节码进行混淆处理。 使用dx将.class文件生成Dalvik虚拟机可执行的classes.dex文件 该过程可以将java字节码转换成dalvik字节码，并压缩常量池、消除冗余信息。 每个dex文件最大方法数为64k，如果应用方法数超过该限制，在应用multidex的应用中，该步骤会生成多个dex 使用apkbuilder把没有编译的资源、编译过得资源、.dex文件打包为一个.apk文件。 签名 使用zipalign进行对齐处理，提升访问速度。 OK，到这里我们就得到了一个可以运行在Android设备上的apk程序包了。众所周知，Android 系统中的应用不同于普通的Java应用运行在JVM上，Android应用程序均运行在Android系统提供的ART/Dalvik虚拟机上，我们在上一步中通过dx生成的dex文件就是dalvik虚拟机接收的字节码文件格式。 讲到这里我们稍微插入一小段知识： Dalvik/ART虚拟机和普通的Java虚拟机的差异在哪里？ 核心差异：JVM架构是Stack-Based，基于栈的架构，Dalvik虚拟机的架构为Reg-Based，基于寄存器的架构。JVM之所以采用基于栈的架构，是为了更好的适应所有的底层系统，不对处理器的reg数做假设，成为一个真正的「可移植」虚拟机；Dalvik虚拟机基于寄存器的架构执行效率更高，更加适合提前优化，加上手机处理器多为多reg的ARM系统本身也更加适合这种reg-based的虚拟机。 由于核心架构的差异，.dex文件的字节码和.class文件的字节码是不一样的，下图可以比较清晰的说明这一点。 JVM中通常会在同一个虚拟机中运行许多程序，而在Dalvik中，则采用了Zygote模式：在Android系统中，应用程序进程都是由Zygote进程孵化出来的，而Zygote进程是由Init进程启动的。Zygote进程在启动时会创建一个Dalvik虚拟机实例，每当它孵化一个新的应用程序进程时，都会将这个Dalvik虚拟机实例复制到新的应用程序进程里面去，从而使得每一个应用程序进程都有一个独立的Dalvik虚拟机实例。Zygote进程在启动的过程中，除了会创建一个Dalvik虚拟机实例之外，还会将Java运行时库加载到进程中来，以及注册一些Android核心类的JNI方法来前面创建的Dalvik虚拟机实例中去。注意，一个应用程序进程被Zygote进程孵化出来的时候，不仅会获得Zygote进程中的Dalvik虚拟机实例拷贝，还会与Zygote一起共享Java运行时库，这完全得益于Linux内核的进程创建机制（fork）。这种Zygote孵化机制的优点是不仅可以快速地启动一个应用程序进程，还可以节省整体的内存消耗，缺点是会影响开机速度，毕竟Zygote是在开机过程中启动的。 也即是说，在Android系统中，有多少个应用在运行，那么就有多少个虚拟机正在运行，而这与JVM单虚拟机多程序的架构相去甚远，但这也是移动设备为了适应小内存、低性能所采取的非常有意义的改变。 除了指令集和类文件格式不同，Dalvik虚拟机与Java虚拟机共享有差不多的特性，它们都是解释执行，并且支持即时编译（JIT）、垃圾收集（GC）、Java本地方法调用（JNI）和Java远程调试协议（JDWP）等 好，现在我们已经准备好了安装包，接下来，.apk文件是如何安装在Dalvik/ART虚拟机上的？他们又是如何运行的呢？ 首先我们来看安装：当我们安装应用的时候，Dalvik和ART会采取不同的方式去优化加载到本地的dex文件： Dalvik 环境下，安装服务PackageManagerService会通过守护进程installd调用一个工具dexopt对打包在APK里面包含有Dex字节码的classes.dex进行优化，优化得到的文件保存在/data/dalvik-cache目录中，并且以.odex为后缀名，表示这是一个优化过的Dex文件。 ART 环境下同样安装服务PackageManagerService会通过守护进程installd调用另外一个工具dex2oat对打包在APK里面包含有Dex字节码进翻译。这个翻译器实际上就是基于LLVM架构实现的一个编译器，它的前端是一个Dex语法分析器。翻译后得到的是一个ELF格式的oat文件，这个oat文件同样是以.odex后缀结束，并且也是保存在/data/dalvik-cache目录中。无论是Dalvik VM环境下的.odex文件，还是ART环境下的.odex文件，最终在运行程序时都需要将DEX文件载入进虚拟机，只不过DVM状态下，可能会通过Interpreter（解释器）或者JIT去把字节码转换成机器码最终执行，而在ART状态下，这些字节码会在安装时被AOT的转换成机器码存在同样以.odex为后缀的OAT文件中，使用时就不再在运行时去解释了。在程序运行时，程序依赖的系统代码会连同程序的代码一起生成一个OAT文件加载进虚拟机，所以一个OAT文件内部其实可能会含有多个DEX文件的。如果运行时有加载额外的dex文件，其同样会以该方式生成oat文件加载进ART虚拟机。 在AndroidN中，ART采取了一种更加「聪明」的方式去处理——混合编译，简单来讲，就是JIT、解释、AOP三种方式共存，其中的策略、优劣势、对于热修复有什么影响，请继续阅读文末给出的链接。 OK，说了这么多，似乎有点偏题，净是在说什么虚拟机啊dex啊的，这和我们讨论热修复的主题有何关系？当然有关系，让我们把目光往上挪一层，我们之前了解了在安装应用时是怎么把应用代码本地化到系统中的，DVM生成了.odex文件、ART生成了OAT文件缓存在了本地，那么，这些DEX文件又是怎么在虚拟机启动过程中被加载到JavaHeap里作为一个个Class对象供以使用的呢？这里必须要讲到Android的类加载机制了。 Android 的类加载机制首先我们花几分钟时间来简单的回顾一下Java世界中的ClassLoader机制： 双亲委托模型：源ClassLoader收到加载类或资源请求时，首先委托父ClassLoader进行加载，如果已经加载则直接返回，否则继续向上委托直到遍历到始祖类加载器。若始祖类加载器依然没有对应的类或资源，则从始祖类加载器开始，尝试从当前类加载器对应的类路径下寻找class字节码并载入，如果成功则返回class，如果失败则将加载请求委托给子加载器，一直遍历到源ClassLoader直到成功载入该class，否则抛出异常。 从前文我们知道，Android虚拟机标准和普通的JVM不一样，它们没有.class文件，而是在编译之后将所有.class文件封装成了.dex文件，在安装时又被优化成了.odex文件，那这些.odex文件的类加载又会有什么不同呢？让我们接着往下看： 在Android世界中，同样有ClassLoader类，该类为一个抽象类，其子类由以下部分组成： ClassLoader SecureClassLoader URLClassLoader - 加载 jar 文件，在Android上无法使用 BaseDexClassLoader PathClassLoader - 在应用启动时创建，从应用目录下加载 apk 文件，只能加载已经安装的 dex或apk文件。 DexClassLoader - 类似于PathClassLoader，不过它能够加载来自于其他外部路径的Dex文件 —— 这也是许多热修复的基础，在不需要安装应用的情况下，完成需要的Dex的加载。 无论是PathClassLoader还是DexClassLoader，都只是BaseDexClassLoader的封装，具体的类加载过程都在BaseClassLoader中完成的，下面我们来看它究竟做了什么事情： 在外部通过loadClass(String className)并遍历双亲得到 class 实例 12345678910111213141516171819202122232425public Class&lt;?&gt; loadClass(String className) throws ClassNotFoundException &#123; return loadClass(className, false);&#125;protected Class&lt;?&gt; loadClass(String className, boolean resolve) throws ClassNotFoundException &#123; Class&lt;?&gt; clazz = findLoadedClass(className); if (clazz == null) &#123; ClassNotFoundException suppressed = null; try &#123; clazz = parent.loadClass(className, false); &#125; catch (ClassNotFoundException e) &#123; suppressed = e; &#125; if (clazz == null) &#123; try &#123; clazz = findClass(className); &#125; catch (ClassNotFoundException e) &#123; e.addSuppressed(suppressed); throw e; &#125; &#125; &#125; return clazz;&#125; loadClass方法调用了findClass方法，BaseDexClassLoader重载了这个方法： 12345678@Overrideprotected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; Class clazz = pathList.findClass(name); if (clazz == null) &#123; throw new ClassNotFoundException(name); &#125; return clazz;&#125; 结果还是调用了 DexPathList的findClass 123456789101112public Class findClass(String name) &#123; for (Element element : dexElements) &#123; DexFile dex = element.dexFile; if (dex != null) &#123; Class clazz = dex.loadClassBinaryName(name, definingContext); if (clazz != null) &#123; return clazz; &#125; &#125; &#125; return null;&#125; DexPathList中的dexElements通过下面方法得到 123456789101112131415161718192021222324252627282930313233343536373839404142434445private static Element[] makePathElements(List&lt;File&gt; files, File optimizedDirectory, List&lt;IOException&gt; suppressedExceptions) &#123; List&lt;Element&gt; elements = new ArrayList&lt;&gt;(); // 遍历所有的包含 dex 的文件 for (File file : files) &#123; File zip = null; File dir = new File(""); DexFile dex = null; String path = file.getPath(); String name = file.getName(); // 判断是不是 zip 类型 if (path.contains(zipSeparator)) &#123; String split[] = path.split(zipSeparator, 2); zip = new File(split[0]); dir = new File(split[1]); &#125; else if (file.isDirectory()) &#123; // 如果是文件夹,则直接添加 Element,这个一般是用来处理 native 库和资源文件 elements.add(new Element(file, true, null, null)); &#125; else if (file.isFile()) &#123; // 直接是 .dex 文件,而不是 zip/jar 文件(apk 归为 zip),则直接加载 dex 文件 if (name.endsWith(DEX_SUFFIX)) &#123; try &#123; dex = loadDexFile(file, optimizedDirectory); &#125; catch (IOException ex) &#123; System.logE("Unable to load dex file: " + file, ex); &#125; &#125; else &#123; // 如果是 zip/jar 文件(apk 归为 zip),则将 file 值赋给 zip 字段,再加载 dex 文件 zip = file; try &#123; dex = loadDexFile(file, optimizedDirectory); &#125; catch (IOException suppressed) &#123; suppressedExceptions.add(suppressed); &#125; &#125; &#125; else &#123; System.logW("ClassLoader referenced unknown path: " + file); &#125; if ((zip != null) || (dex != null)) &#123; elements.add(new Element(dir, false, zip, dex)); &#125; &#125; // list 转为数组 return elements.toArray(new Element[elements.size()]);&#125; 其中loadDexFile()方法最终会调用JNI方法载入dex对象，这里我们不再深入的去涉及了。 得到dex文件后通过调用loadClassBinaryName得到最终的class对象。这里在loadClassBinaryName方法中，其实最终调用的依然是Native的defineClass方法，这与JVM中loadClass的方法名一致，不知道是故意还是巧合。 12345public Class loadClassBinaryName(String name, ClassLoader loader)&#123; return defineClass(name, loader, mCookie);&#125;private native static Class defineClass(String name, ClassLoader loader, int cookie); OK，到这里我们基本大概对Android虚拟机使用的字节码文件有了初步了解，对Android系统中的类加载机制也有了初步的认识，知道了Android虚拟机中的类对象究竟是怎么从.dex文件加载进虚拟机的。这也为我们接下来真正进入Java世界中热修复框架原理打下了基础。 基于ClassLoader的热修复原理经过以上啰啰嗦嗦杂七杂八的前置知识铺垫之后，我们终于进入了正题，趁热打铁，我们首先来看一下最经典的基于ClassLoader的热修复方案： 如前所述，我们在载入Class的时候，会调用DexPathList对象中的findClass方法，findClass方法则会遍历dexElements数组，当发现首个dex对象的时候则直接返回。若我们在此处将修复了问题之后的dex插入到这个dexElements数组的最前方，那么不就可以直接加载到打完补丁之后修复好的类了吗？那么热修复也就完成了。 原理很简单，实现也不难，但是这里面有一个很重要的问题需要解决：CLASS_ISPREVERIFIED 这是个Class内部的标示，在应用安装时，系统通过dexopt或dex2oat进行dex优化时进行设置。当该标示位为真，则表示这个类直接引用到的类与该类都在同一个dex中。那么事情就变成了这个样子：假设类A直接引用了类B，类A与类B在安装之初经过校验发现在同一个Dex中，CLASS_ISPREVERIFIED被置为真。 此时类B出错，使用类B’代替，当类A中再次调用类B(类B’)，虚拟机因为CLASS_ISPREVERIFIED标示缘故对类A与类B’的Dex来源进行校验，此时因为类B’来自下发的补丁包，校验不通过，虚拟机崩溃退出。 OK，为了解决这个问题，开发人员从CLASS_ISPREVERIFIED的置空条件入手：若类A中引用了一个在同一Dex种的类B，同时也引用了不在同一Dex中的类C，那么包括类A类B类C都不会被打上CLASS_ISPREVERIFIED标签。于是开发人员只要保证在所有类的构造函数中调用一个第三方Dex提供的类X，就可以保证所有类均不会被打上CLASS_ISPREVERIFIED标签。 但是这个方案不是没有问题，在DVM中，因为所有类都是非preverify的状态，这导致verify与optimize操作会在加载类时触发。单次的verify+optimize耗时并不长，而且这个过程只有一次，但是当应用启动时，会一次性载入数量庞大的类，这时的性能影响就不容忽视了。 而在ART中，由于ART采取了新的方式，这种处理对代码的执行效率没有太大影响，但是如果不定的类中出现修改类变量或者方法的情况，则会导致出现内存错乱的问题——因为在安装应用时，dex2oat已经将能够确定的各个地址全部写死为机器码，如果运行时补丁包的地址出现改变，原始类去调用时就会出现地址错乱。为了解决这个问题我们需要将修改了变量、方法以及接口的类的父类以及调用这个类的所有类都加入到补丁包中。这可能会带来补丁包大小的急剧增加。 总的来说，ClassLoader方案好处在于开发透明，简单，这一套方案目前的应用成功率也是最高的，但在补丁包大小与性能损耗上有一定的局限性。 Instant Run在我们继续接下来的叙述之前，我觉得需要用一个独立的章节来叙述Google官方推出的「热更新」框架——Instant Run。 它是去年AndroidStudio2.0发布的时候Google引入的一项用于提升开发效率的新的IDE特性，这项技术能够让我们在初次构建并部署应用到手机后，后续修改能够在不经过重新安装应用即可完成部署——这不就是一种热更新吗？ 虽然Instant Run由于只能运行在IDE环境下、Android系统版本要求也在5.0以上等原因无法作为一个真正的热更新框架，但是其内部的原理、思路为真正的热修复框架提供了思路： Instant Run的热更新分为三个层次，热插拔、温插拔、冷插拔。热插拔情况下的修复，应用无须作任何操作即可更新方法的实现。温插拔则是在热插拔的基础上增加了对资源的更新，开发者只需要重启Activity即可完成更新。冷插拔则是应对更加大范围的修改，如类结构变更、方法名变更等等问题，这时开发者需要重启应用以完成更新。 Instant Run的核心设计有以下几点： 编译期注入字节码 我们在通过Instant Run构建应用的时候，Instant Run通过Gradle的Trasform api处理了Javac生成的所有.class文件，为每个类都提供了一个字段change，该字段实例实现了IncrementalChange接口，并且在每个方法最前方插入了一段代码来判断是否需要调用一段插入的代码以作为修复之后的调用。话说起来可能比较抽象，看看图吧，原理其实很简单： 与此同时，在生成.class文件的时候，Instant Run同时也修改了Manifest文件，生成代码注入了一个BoostrapApplication作为原来Application类的代理，以实现修改后补丁文件的监听和ClassLoader的注入。 多ClassLoader机制 在BootstrapApplication里，Instant Run利用ClassLoader的双亲代理机制，在原有的PathClassLoader之上注入了一个IncrementalClassLoader用于生成所有修改后的补丁类，同时也由于双亲委托机制的存在，IncrementalClassLoader也成为了所有类的加载器，拦截了程序中所有的类加载请求。在IncrementalClassLoader中，每个热补丁类都是由不同的ClassLoader实例创建的，这一点是整个Instant Run的核心所在，因为修改后的类实际上和修改前的类是同一个类，如果使用同一个ClassLoader是无法完成类加载的。 全量资源替换 在Instant Run中，在替换Application的同时，也会对资源相关对象进行替换，将资源目录指向另一个位置。此时，如果发生了资源的修改，那么温插拔会被触发，Gradle会自动将所有资源重新打包并替换掉该资源目录下的资源，同时重启Activity完成资源更新。 Dex分片（Dex-Slice） 在应用构建的时候，Instant Run会通过Gradle插件对Dex文件按照包名进行分片（也可以叫分包），最多把Dex分为10片部署到手机上。在开发者做出代码上的修改之后，Instant Run会判断修改的内容，如果改动无法通过热插拔完成，那么会对修改类所在的Dex进行全量构建并下发替换原有的Dex片，在这种状况下，实际上新的Dex是通过PathClassLoader加载进来的，因此必须通过重启应用触发类加载来完成载入。 以上就是Instant Run比较核心的一些设计，我们可以看到，从注入代理Application拦截原生ClassLoader、修改资源路径完成资源替换、注入字节码实现热修复到覆写分片Dex完成全量更新，Instant Run在针对不同的状况采取了不同的措施，逻辑清晰、步步为营，非常值得我们学习。 从Instant Run热插拔的思路出发，美团团队利用相似的原理开发出了热修复框架Rubost；从Instant Run冷启动的思路出发，微信团队则开发出了热修复框架Tinker。Rubost框架原理这里不需要过多的细讲，和热插拔类似，只是针对方法数、分包等问题进行了优化。下面我们仔细看看Tinker的思路： 基于Dex全量替换的热修复框架 - TinkerTinker的思路很简单——全量替换Dex。是不是有一种暴力美学的意味在里面？但是为了实现这个目标，却不得不放下手中的加特林，拿起绣花针把里面一个一个的坑都给踩平。 全量更新包的大小问题首先就摆在了面前——我当然可以下发一整个Dex给你替换，但是全量下发动辄十几兆的Dex文件真的大丈夫？这里Tinker采取了自研DexDiff算法，通过下发差异文件，在客户端本地合成新的Dex文件作为更新后的Dex文件。这件事听起来也很直接，但是为了最大程度的压缩差量包、最快的生成更新后的Dex文件，Tinker团队必须对Dex文件格式、Dex文件生成过程了如指掌、必须对算法的性能有最高的要求，用shwenzhang自己的话来说： 这不仅要求我们需要研究透Dex的格式，也要把dex2opt与dex2oat的代码全部研究透。现在回想起来，这的确是一条跪着走完的路。与研究Dalvik与Art执行一致，这是经历一次次翻看源码，一次次编Rom查看日志，一次次dump内存结构换来的结果。 Tinker做到的事情当然不止这么多，ART/Dalvik差异化执行、AndroidN混合编译的支持等等天坑都被他们填了过去，具体的技术细节这里就不分析了，这里附一张图看看Tinker都能做到些什么吧： 总结断断续续的写了两三天，终于把这篇笔记完成了……回过头去再读了一遍全文，感慨良多。就热修复技术而言，确实是一门太需要持续投入时间的技术了，技术做出来很容易，但是做得好真的太难。就用shwenzhang的一句话为本文做结吧： 热补丁不是请客吃饭 向那些在某些领域内深耕不辍的工程师致敬，有朝一日希望我也能成为他们那样优秀的人。 参考 综述 各大热补丁方案分析和比较 - markzhai [Android热修复] 技术方案的选型与验证 Android 热修复方案对比 - itscoder 安卓App热补丁动态修复技术介绍 - QZone 虚拟机 Android运行时ART简要介绍和学习计划 - 老罗 Dalvik虚拟机简要介绍和学习计划 - 老罗 ClassLoader 热修复入门：Android 中的 ClassLoader 从源码分析 Android dexClassLoader 加载机制原理 Android动态加载基础 ClassLoader工作机制 Android类加载机制的细枝末节 Instant Run Instant Run: How Does it Work?! - Google 从Instant run谈Android替换Application和动态加载机制 - w4lle Android Studio的Instant Run(即时安装)原理分析和源码浅析 - coding-way 从Instant-Run出发，谈谈Android上的热修复 - zjutkz Tinker 微信热补丁实践演进之路 - PPT 微信Tinker的一切都在这里，包括源码.md) Android N混合编译与对热补丁影响深度解析 ART下的方法内联策略及其对Android热修复方案的影响分析 Tinker DexDiff Rubost Android热更新方案Robust Android中热修复框架Robust原理解析+并将框架代码从”闭源”变成”开源”(上篇) Android中热修复框架Robust原理解析+并将框架代码从”闭源”变成”开源”(下篇) AndFix AndFix - Github Android热补丁之AndFix原理解析 Freeline Freeline - Android平台上的秒级编译方案]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>热修复</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jekins+Bitbucket+Fir.im 自动构建部署最新测试包]]></title>
    <url>%2F2017%2F01%2F04%2Fjekins-bitbucket-auto-build%2F</url>
    <content type="text"><![CDATA[在日常开发中，我们的流程通常是： 开发->自测->提交测试->测试反馈->开发->…… 很多有着成熟流程的公司在其中很多步骤上都能做到充分的解耦和自动化，开发无需关心应用的构建，只需要向特定分支提交符合标准的代码即可，测试也不需要关心开发是否开发完成、构建是否成功等等问题，只需要关注推送通知得知「有一个最新的测试包就绪，它相对于前次版本更新了xxxx」，并且能够很便捷的获取到应用，进行测试之后也能够把出现的问题对应到对应的版本反馈给开发。 堆糖的CI一直一来使用的都Jekins，前代开发已经在上面建立了众多的Project以用于构建各种版本的堆糖应用，但是可能是因为理解的偏差，只是把Jekins当做了一个「重复性任务执行脚本列表」来使用，只是让Jekins代替执行自己手写的Shell脚本，既没有利用到Jekins对于源代码的管理功能，也没有很好的利用Jekins提供的丰富的自动化插件，开发需要不定期告诉测试我们往xx分支提交了有xx feature的代码，测试则需要不定期去内部CI网站上配置构建工程，并等待构建结果生成——这样的状况无论是对于开发还是测试都是极大的生产力浪费，很多事情其实都是不需要这么做的。 最近业务压力稍小，就花了一下午时间开发并调试了一下Jekins，利用Bitbucket的WebHook功能，当某条分支上推送了最新代码时，自动触发Jekins的构建，构建完毕自动上传到公司内部的Fir.im，并通过BearyChat推送一条通知，告知测试最新的测试包已经构建完毕，以及本次构件包含的内容。整个流程无需人为干预，无论是测试还是开发都不需要关心CI的细节，只需要关心自己职责范围内的工作即可。下面记录下都做了些什么事吧： 升级Jekins（内部服务器上的Jekins版本低的令人发指），安装BitBucket插件 在Bitbucket中配置WebHook，填入Jekins实例的地址 填入需要触发构建的分支名，这里我们随便填个 Dev看看 Bitbucket上的配置已经完成啦，这里我们回到jekins上，我们新创建一个Project好了，在源码管理部分填入项目地址、构建分支、访问凭证等等东西 在触发器上钩选 Build when a change pushed to Bitbucket 新增Execute shell 部分，在里面写好构建应用的脚本代码。这里算是整个部分最核心的地方了，清理构建环境、升级SDK、更新Build号等等事情，不过这里就不附图了，代码比较敏感。 配置Fir.im的上传插件 配置BearyChat机器人，通知事件。这里只通知构建成功，失败了的话就让他去吧…… 构建完毕，收到通知，测试现在可以看到这次构建发生了什么变化，以及能够直接访问公司固定的Fir.im链接下载最新的安装包了。 至此基本所有的流程都走通了，整个过程虽然看上去简单，但是其中总会在某些不知名的角落卡住……比如Bitbucket和Jekins无法互相访问，这个只能联系公司运维解决；比如Jekins的工作环境总是会出一些各种各样的问题……这里也不细讲了，案例都比较个例。 可能这个案例本身并没有特别厉害的技术含量在里面，但这种对于任何低效保持「不妥协」的态度却是值得记录的。程序员要成长要提高，执着于「业务」开发是永远没办法达到很高的高度的，只有保持对于「低效」「不适」的不满并且不断努力去解决这些痛点——可能是流程上的繁琐，可能是框架代码的不合理，可能是开发效率的底下，可能是不愿意写很多模板代码——发现他们，解决他们，才能真正的让程序员不断的进步下去。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016 年度总结与展望]]></title>
    <url>%2F2017%2F01%2F02%2F2016-summary%2F</url>
    <content type="text"><![CDATA[元旦三天昏昏沉沉的不知道做了些什么，莫名其妙的在家宅着断断续续的竟然写了两天代码……说是写了两天代码没错，但是总觉得回过头来看又觉得自己也没写什么东西，兴冲冲的构思了一个架构，实现的时候写写删删的也没有最终达到我期望的样子，哎，头疼，先不搞了，来把这篇总结怼出来再说。 年末好快呀……2016年就这么过去了，不过说快也不算快，今年还真的算是经历了蛮多事情的呐，用几个关键词总结一下吧。 毕业年初在家安逸的过完了最后一个寒假，然后回学校毕业去，很舒服的度过了最后一段在学校的时光，该玩玩，该睡睡，然后就这么的被小破邮扫地出门，就这么的跟同学们分道扬镳各自启程。 关于毕业其实没有太多感触，唯一的不舍可能还是来自于曾经低头不见抬头见的各位和学校从此不再能够经常从你的生命里路过，不过好在交通、信息发达，实际上也不会有太大的区别。有心的人终究会再遇见，年末之际，愿你们新的一年一切都变得更好。 工作其实从14年底开始基本就算是一直在校外全职的工作了，朝夕、漫漫、支付宝到现在的堆糖。虽然有的工作因为没有毕业，名义上算不上全职，但是从工作的实质上讲，基本都是处于全职工作的状态中。所以有时候也会想，竟然就这么默默的成为了一个职场人士，感觉略有些奇怪。 说回工作，毕业之后没有多做其他考虑的加入了堆糖，之所以没有去更大的公司，一是决定来上海的决定很匆忙，没时间去找更棒的工作了；二是个人对于小型团队存在某种偏好，小宇这个team-mate给我的感觉也蛮好的，15年合作的很愉快；三嘛，是因为是懒。确实身边也有人对我的选择表示不理解，可能我自己如果回到15年9月的时候我也不会做相同的选择，但是人嘛，都得学会向前看，把握当下、追逐未来才是正途，对吧？ 所以，16年从年末往年初回顾，我个人觉得是我职业生涯中成长收获蛮丰富的一年，也是有很多遗憾的一年。写出来并解决了很多bug，遇到了来自各个方面的很多问题也解决了很多问题，尝试了很多新的东西也对很多老东西有了新的认识，读了很多源码，重写了很多代码，和很多人打了交道，也和很多人交了朋友。遗憾的话，没能好好的学学前端，没能用上Kotlin，没能贡献几个好用的开源库，还有好几本书放在家里吃灰没时间看，还有好几个想要研究的开源框架源码没读…… 如果让我自己给今年的自己在工作、事业上打个分的话，给自己75分吧，勉强及格，还需努力。 生活16年成功的没有发福，年底猛吃了一波之后陷入了对于中国传统美食免疫的状态，每天胃肠翻腾，恨不得每天喝粥。年底也是各种账单机票集中冒出来的时候，穷的快疯了…… 16年4月的时候也终于从破的鸟不拉屎早上地铁都挤不上的鹤沙航城搬来了虹桥路，终于感受到了「上海」，对于当时的决定感到无比庆幸。不过搬来之后就再也没有自己做饭的想法了，都怪外卖太发达…… 和潇哥的生活也并不平淡的过着，吃吃喝喝也有，到处疯玩也有，穿成个绒毛熊在家宅着你写报告我写代码也有。生活必然是不平淡的，毕竟两个人都有小本本，说不定哪天就翻出旧账记你一笔然后互怼一波…… 今年有个最重要的决定就是终于在成都买了房，虽然是个小房子，但是位置还不错，最近几年肯定也不会回去住，买下来抵抗下通胀，租出去收点租子也不错呀哈哈。 总的来说，生活在16年里也是不平不淡的过着，最重要的是，有潇哥在身边。😘。 2017呐，展望一下吧。目标很少，做到就好。 工作 拓展技术栈 无论什么领域，多做尝试 生活 少宅，多运动 唔。新年快乐。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动在博客的中英文单词中间加上空格]]></title>
    <url>%2F2016%2F12%2F28%2Fauto-space%2F</url>
    <content type="text"><![CDATA[偶然间在逛Kaedea博客的时候发现了这个玩意：pangu.js，很好很强势，终于可以解放老夫的空格键了，强迫症伤不起。 嘛，Github上pangu.js介绍的这段话也很有意思： 漢學家稱這個空白字元為「盤古之白」，因為它劈開了全形字和半形字之間的混沌。另有研究顯示，打字的時候不喜歡在中文和英文之間加空格的人，感情路都走得很辛苦，有七成的比例會在 34 歲的時候跟自己不愛的人結婚，而其餘三成的人最後只能把遺產留給自己的貓。畢竟愛情跟書寫都需要適時地留白。 嗯，记录下在Next主题下是怎么实现的吧： 在这里找到模板文件： 1vim path_to_hexo/themes/next/layout/_layout.swig 在head块中声明JS： 1&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/3.3.0/pangu.min.js"&gt;&lt;/script&gt; 在body块的末尾调用一下就好辣 1&lt;script&gt;pangu.spacingPage();&lt;/script&gt;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>折腾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Nested Scrolling 学习笔记]]></title>
    <url>%2F2016%2F05%2F09%2Fnestedscrolling-summary%2F</url>
    <content type="text"><![CDATA[我们知道，在Android中，触摸事件的处理流程是通过dispatchTouchEvent分发触摸事件，通过自下而上的拦截事件(onInterceptTouchEvent)以及自上而下的处理事件(onTouchEvent/onTouch)完成事件的分发，如果想要完成子控件与父控件同时对某一事件的处理的话，需要自己额外实现较多代码，非常繁琐而且容易出错，而NestedScroll接口的出现正是为了应对这种情况。 该接口已经在Android官方控件中广泛的得到了使用，包括在Android Design包中引入的CoordinateLayout、FabIcon以及之前的RecyclerView、SwipereFreshLayout等等常用控件现在均已实现了该接口，都可以作为嵌套滑动的子容器或父容器使用。然而令人非常遗憾的是，ViewPager作为一个使用频次非常高、使用场景中非常容易出现嵌套滑动场景的控件，官方并没有提供任何相关的支持，甚至在ViewPager的源码文档开头依然宣称该控件依然停留在一个非常早期的开发阶段（This class is currently under early design and development），令人唏嘘不已。 NestedScroll系列接口包括以下四个部分： NestedScrollingChild//实现嵌套滑动的子控件需要实现的接口 NestedScrollingParent//实现嵌套滑动的父容器需要实现的接口 NestedScrollingChildHelper//在需要嵌套滑动的子控件中一个用于辅助进行嵌套滑动的Helper NestedScrollingParentHelper//在需要嵌套滑动的父容器中一个用于辅助进行嵌套滑动的Helper 为了实现父容器和子控件之间的嵌套滑动，首先我们需要选定父子容器，明确是哪个父容器需要配合子容器进行嵌套滑动，这里需要注意的是，嵌套滑动只能发生在父容器与子控件之间，并且滑动的发起者是子控件，父容器是被动的接受子控件发出的嵌套滑动请求并作出响应的一方。 当选定好我们需要进行嵌套滑动的控件双方时，我们首先需要在子控件中实现NestedScrollingChild接口，然后在子控件的构造函数中生成一个NestedScrollingChildHelper对象，并将接口中所有方法委托给helper对象。同样的，我们类似的处理父容器——实现接口、委托方法，然后准备工作就完成了。 可以看到，我们仅仅是把接口代理给了一个helper，仅仅依靠这个是怎么完成嵌套滑动呢？这些方法又应该在哪里调用呢？又有什么意义呢？我们继续往下看。 我们首先分析下主要的嵌套滑动发起者NestedScrollingChild中的方法，由于所有方法均被代理给了helper类，因此我们直接看helper中的对应方法就好了： setNestedScrollingEnabled，该方法开启/关闭嵌套滑动 public void setNestedScrollingEnabled(boolean enabled) { if (mIsNestedScrollingEnabled) { //如果正在嵌套滑动，那么通知父容器停止嵌套滑动 ViewCompat.stopNestedScroll(mView); } mIsNestedScrollingEnabled = enabled; } isNestedScrollingEnabled，该方法用于检查是不是能够嵌套滑动 public boolean isNestedScrollingEnabled() { return mIsNestedScrollingEnabled; } hasNestedScrollingParent，该方法用于检查是否关联有父容器用来接收嵌套滑动过程事件 public boolean hasNestedScrollingParent() { return mNestedScrollingParent != null; } startNestedScroll，该方法用于开启一个嵌套滑动的过程，返回true表示可以开启嵌套滑动，返回false表示无法开启嵌套滑动。 public boolean startNestedScroll(int axes) { if (hasNestedScrollingParent()) { //如果已经有了一个嵌套滑动的父容器对象，那么直接返回true return true; } //首先检查嵌套滑动是不是开启了 if (isNestedScrollingEnabled()) { ViewParent p = mView.getParent(); View child = mView; //遍历从该子控件开始往上的所有父容器，尝试去调用这些父容器的onStartNestedScroll方法， //如果成功，那么将该父容器作为嵌套滑动的对象，并调用父容器的onNestedScrollAccepted方法。 while (p != null) { if (ViewParentCompat.onStartNestedScroll(p, child, mView, axes)) { mNestedScrollingParent = p; ViewParentCompat.onNestedScrollAccepted(p, child, mView, axes); return true; } //如果父容器无法开始嵌套滑动，那么将子控件和父容器都向上遍历一级，继续这个过程，直到父容器为空。 if (p instanceof View) { child = (View) p; } p = p.getParent(); } } return false; } 我们可以看到，在这个过程中，helper类会不断的从子控件开始向上遍历可以作为嵌套滑动对象的父容器，直到找到第一个可以作为嵌套滑动对象的父容器返回。这个机制也保证了我们不用强制子控件的直接父容器必须实现该接口，只要保证目标父容器实现了这个接口即可。 dispatchNestedPreScroll，该方法用于在子控件消费滑动事件之前去向父容器分发滑动事件，并允许父容器预先消费一部分滑动距离，该被消费的距离会通过数组int[] consumed来传递，并且如果子控件的绝对位置在父容器消耗距离的过程中发生了改变，那么这个改变的值会通过数组int[] offsetInWindow回传过来: public boolean dispatchNestedPreScroll(int dx, int dy, int[] consumed, int[] offsetInWindow) { //只有在可以嵌套滑动的时候才分发事件 if (isNestedScrollingEnabled() &amp;&amp; mNestedScrollingParent != null) { //只要滑动的距离在xy轴上任意不为0，那么开始分发事件 if (dx != 0 || dy != 0) { //初始化起始位置 int startX = 0; int startY = 0; //初始化子控件在屏幕上的相对位置 if (offsetInWindow != null) { mView.getLocationInWindow(offsetInWindow); startX = offsetInWindow[0]; startY = offsetInWindow[1]; } //初始化consumed数组 if (consumed == null) { if (mTempNestedScrollConsumed == null) { mTempNestedScrollConsumed = new int[2]; } consumed = mTempNestedScrollConsumed; } consumed[0] = 0; consumed[1] = 0; //调用父容器中的onNestedPreScroll，让父容器预先滑动 ViewParentCompat.onNestedPreScroll(mNestedScrollingParent, mView, dx, dy, consumed); //重新计算子控件在屏幕上的位置，通过offsetInWindow返回给子控件 if (offsetInWindow != null) { mView.getLocationInWindow(offsetInWindow); offsetInWindow[0] -= startX; offsetInWindow[1] -= startY; } //如果在x轴或y轴上父容器发生了消耗，那么这个方法的返回值为true，否则为false，方便子控件跳过处理 return consumed[0] != 0 || consumed[1] != 0; } else if (offsetInWindow != null) { offsetInWindow[0] = 0; offsetInWindow[1] = 0; } } return false; } dispatchNestedScroll，该方法在子控件消耗滑动距离之后调用，通知父容器将剩下的滑动距离消耗掉。 public boolean dispatchNestedScroll(int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, int[] offsetInWindow) { //只有在可以处理的时候才处理 if (isNestedScrollingEnabled() &amp;&amp; mNestedScrollingParent != null) { //只有在发生了距离消耗或还有距离没有消耗完时才进行下一步 if (dxConsumed != 0 || dyConsumed != 0 || dxUnconsumed != 0 || dyUnconsumed != 0) { int startX = 0; int startY = 0; if (offsetInWindow != null) { mView.getLocationInWindow(offsetInWindow); startX = offsetInWindow[0]; startY = offsetInWindow[1]; } //注意这里的方法没有consumed数组返回了，只会更新offsetInWindow数组 ViewParentCompat.onNestedScroll(mNestedScrollingParent, mView, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed); if (offsetInWindow != null) { mView.getLocationInWindow(offsetInWindow); offsetInWindow[0] -= startX; offsetInWindow[1] -= startY; } return true; } else if (offsetInWindow != null) { // No motion, no dispatch. Keep offsetInWindow up to date. offsetInWindow[0] = 0; offsetInWindow[1] = 0; } } return false; } 该接口中还有一些fling相关的方法，都是大同小异就不再仔细看了。事实上以上五个方法基本就完成了和嵌套滑动相关的在子控件上的全部操作，我们可以看到，helper因为是通过该view注入进构造方法新建出来的，所以helper中是持有view的引用的，因此可以遍历该view的视图树，并以此找到目标的嵌套滑动的父容器对象建立联系。同时，该helper也帮助使用者分发滑动时间、返回滑动消耗结果，帮用户省去了很多模板代码。 至于parent，由于嵌套滑动的parent通常是作为「回调」的接收方，其接口多为用于完成实际的控件滑动，所以基本都需要用户自己手动去完成实现，需要代理给parent helper的方法很少，这里就略过不讲了。 至此我们不难得出NestedScroll系列接口的正确用法： 在子控件开始滑动时通过startNestedScroll通知父容器配合，然后在子容器捕获到手势滑动时调用dispatchNestedPreScroll让父容器有机会在子容器消耗掉滑动距离之前先滑动一段距离，然后子容器完成自己的滑动，最后通过dispatchNestedScroll通知父容器自己完成了滑动，让父容器有机会再根据子容器的滑动做出一些滑动处理，所有的子容器方法，都会经过helper类转接，通过遍历视图树找到最近的一个嵌套滑动父容器，并尝试调用相应的on**回调方法完成父容器的响应。 可以看到整个传递触摸事件的思路是与原有的触摸事件分发机制是完全不一样的，这也为我们今后自己做相关的开发提供了思路和启发。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android IPC 学习笔记]]></title>
    <url>%2F2016%2F05%2F02%2Fipc-summary%2F</url>
    <content type="text"><![CDATA[IPC: Inter-Process Communication 不同系统下的不同实现方式： Windows: 剪贴板/管道/油槽 Linux: 命名管道/共享内容/信号量 Android: Binder/Socket Android中的多进程模式使用场景：保活/推送/扩大内存空间/ContentProvider 如何开启？ 在Manifest中设定四大组件的android:process属性 :$remote_name私有进程 $package_name.$remote_name共有进程，可以通过ShareUID的方式与其他应用共享进程 需要两个应用拥有相同的ShareUID以及应用签名一致 通过JNI的方式在Native层去fork一个新的进程 多进程模式下的运行机制Android对于每个进程都分配一个独立的虚拟机，不同的虚拟机在内存分配上有不同的地址空间，通常来讲，使用多进程会造成如下几方面问题： 静态成员和单例模式失效——在不同的虚拟机中访问同一个类对象会产生多份副本。 线程同步机制完全失效 SharedPreference可靠性下降——SP底层是XML实现，并发读写都有可能出现问题。 Application会多次创建——新组建运行在新的进程中时，由于系统在创建新进程的时候会同时分配独立的虚拟机，相当于也是将应用重新启动了一次。 IPC基础概念简介Serializable接口Java提供的序列化方法，通过ObjectInputStream和ObjectOutputStream来对对象进行序列化及反序列化。 Serializable接口是一个空接口，只需要声明一个serialVersionUID即可，事实上这个字段不声明也是能够完成序列化/反序列化的。这个字段的作用在于标识类的版本变化，在序列化的过程中，会将这个值写入序列化的结果中，在反序列化时，会将写入值与反序列化对象的当前serialVersionUID值进行对比，如果相同那么能够成功反序列化，如果不一致则抛出异常。如果该值不经手工指定，那么将按照该类的当前成员变量的构成计算Hash作为serialVersionUID值，在这种情况下，如果序列化/反序列化中间该类成员发生了改变，将导致无法完成序列化。因此为了保证序列化的成功率，最好手动指定serialVersionUID。 Parcelable接口Android系统中特有的序列化接口。需要实现的接口包括： 一个CREATOR常量作为反序列化方法，在该方法中定义通过序列化数据生成对象的构造方法。 一个describeContents内容描述符，通常情况下都为0，当且仅当当前内容含有文件描述符返回1 一个writeToParcel方法作为序列化方法 系统已经定义好了许多可以直接序列化的方法。如Bitmap，Bundle以及Intnet等。 那么，如何选择使用何种序列化方法？ Serializable使用简单方便，但是需要大量的IO操作，开销较大，适合在进行数据本地化或数据序列化之后进行网络传输时使用。 Parcelable定义较为复杂，但性能优秀，效率较高，是Android推荐的序列化方式，主要使用在内存序列化上。 BinderBinder既可以理解为Android中的一个实现了IBinder接口的类，也可以理解为一种虚拟的物理设备，他的驱动是/dev/binder。Binder是连接ServiceManager连接各个ManagerService之间的桥梁。最常用到的地方在Service的使用中，在bindService的时候会返回一个包含服务端业务调用的Binder对象，通过Binder对象来完成客户端对于服务端业务的调用。 不同进程内的Binder很简单，稍微复杂一些的Binder通常使用AIDL或者Messenger完成，而Messenger的底层也是由AIDL实现的，因此了解AIDL的使用方法、原理实际上对于理解Binder的上层原理是有帮助的。 定义AIDL文件并不难，没有太多额外的语法需要注意，只需要按照自己的业务需求，像通常定义接口一样定义AIDL接口即可，注意所有自有的类都必须显式声明即可。在AS中的AIDL文件会被统一收拢到同一个目录下，但是这里有一个不知道是bug还是怎么回事的问题……当你已经定义好一个自定义类之后，IDE不允许再次声明同样名字的.aidl文件。这里没发现有特别好的解决方案，暂时只能先声明一个不同名字的文件，然后再改回去。 AIDL文件没什么好关心的，但是通过AIDL文件生成的.class文件则可以好好研究下： AIDL生成的实际上是一个接口文件，在这个接口类中首先是定义了AIDL文件中规定的方法，然后生成了一个接口内部的抽象类Stub，这个抽象类实现了外层的接口，并继承自Binder，这个内部抽象类就是在之后使用时在Service内部初始化并实现接口方法的Binder对象，听过bindService返回给调用者，调用者使用Binder调用远端方法。 在这里需要注意的是，与日常使用的进程内利用Binder调用远端代码不同的是，这里在获取Binder对象时调用的方法是： public void onServiceConnected(ComponentName name, IBinder service) { mITaskConsumer = ITaskConsumer.Stub.asInterface(service); mIsRemoteBond = true; } 这里asInterfase(service)是完成整个跨进程调用的关键。我们继续看看这个方法里面做了什么： public static com.kyangc.ipcdemo.ITaskConsumer asInterface(android.os.IBinder obj) { if ((obj == null)) { return null; } android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof com.kyangc.ipcdemo.ITaskConsumer))) { return ((com.kyangc.ipcdemo.ITaskConsumer) iin); } return new com.kyangc.ipcdemo.ITaskConsumer.Stub.Proxy(obj); } 这里obj是通过bindService返回的Binder对象，这时会在本地按照DESCRIPTOR定义的特征值去查找进程内的服务，如果查到了，那么说明这个Binder是个本地服务，那么直接将这个Binder作为处理业务的对象返回给调用者；反之如果没有查到，说明这个是一个远程的服务，这个时候会用Proxy对这个Binder进行包装，然后返回给用户。 下面继续看这个Proxy做了什么事： 首先是这个Proxy是继承于我们定义好的接口的： private static class Proxy implements com.kyangc.ipcdemo.ITaskConsumer 然后在执行接口方法时，调用的是这一段代码： @Override public void consume(com.kyangc.ipcdemo.Task task) throws android.os.RemoteException { android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try { _data.writeInterfaceToken(DESCRIPTOR); if ((task != null)) { _data.writeInt(1); task.writeToParcel(_data, 0); } else { _data.writeInt(0); } mRemote.transact(Stub.TRANSACTION_consume, _data, _reply, 0); _reply.readException(); } finally { _reply.recycle(); _data.recycle(); } } 这里看上去多，但实际上只是一堆模板代码。核心步骤实际上只有三步： 将传入参数写入_data 调用mRemote.transact(方法序号,传入序列化数据,传出序列化数据,标志位) 写入返回值，处理异常，回收序列化变量 而transact方法则是调用了/dev/binder提供的方法，将调用什么方法、使用什么参数、返回什么参数等内容传到了远程服务端。 那么远程服务端收到/dev/binder的提醒之后会做什么呢？我们继续看Stub中的一段代码： @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException { switch (code) { case INTERFACE_TRANSACTION: { reply.writeString(DESCRIPTOR); return true; } case TRANSACTION_consume: { data.enforceInterface(DESCRIPTOR); com.kyangc.ipcdemo.Task _arg0; if ((0 != data.readInt())) { _arg0 = com.kyangc.ipcdemo.Task.CREATOR.createFromParcel(data); } else { _arg0 = null; } this.consume(_arg0); reply.writeNoException(); return true; } } return super.onTransact(code, data, reply, flags); } 当/dev/binder把信息发到远端时，会调用到Stub中的onTransact方法，这个方法会接下来继续分析客户端调用了什么方法，从_data中取出参数，计算后将结果放到_reply中。注意这里有一个返回值，如果返回为false，那么代表该次请求失败，反之成功，这个特性可以被利用于权限验证。 这里需要注意的一点是，客户端的线程会在请求后被挂起，之后所有的操作均发生在各自Binder的线程池中，直到请求返回才停止主线程的阻塞。因此尽量不要再主线程发起远端的业务请求，尽可能在新的线程中发起业务需求通知。 下图简单描述了一下这个过程： Android中其他IPC方式Bundle非常常用的跨进程传输数据的方式(Intent)，只支持Parcelable数据的传输。 文件共享必须手动控制并发，很容易出问题，效率较低。例如Sharedpreference，系统对于SP是有一定的缓存策略的，在多进程模式下会变得非常不可靠。 Messenger一种基于AIDL的轻量级IPC手段。底层由Handler+AIDL实现，服务端存在一个固定宽度为1的消息队列，因此没有并发的问题。通过指定Message中的replyTo字段来完成服务端的消息转发。 ContentProvider底层实现依然依赖于Binder。实现自定义的ContentProvider只需要实现对应的CRUD方法以及一个生命周期方法和一个返回MIME类型的getType方法即可。ContentProvider的储存方式是任意的，可以使用数据库、文件甚至是内存中的一个对象。 这里需要注意的是，ContentProvider的OnCreate方法是调用在UI线程中的，因此需要注意不要放入太多耗时操作。而其他CRUD方法则是运行在Binder线程池中，因此是存在多线程并发访问的可能性的，ContentProvider本身没有对这些方法做处理，需要用户自己管理并发。 SocketSocket运行在TCP/UDP层上，本身支持传输任意字节流，因此也可以被用于IPC。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>IPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写在毕业前]]></title>
    <url>%2F2016%2F03%2F17%2Fsomething-to-say-before-april%2F</url>
    <content type="text"><![CDATA[就要滚蛋了，离开学校，离开北京。我想我是爱这里的，虽然在校的时候没少吐槽学校怎么怎么不好，没少跟家里人抱怨北京空气差房子贵地铁挤，但我想我还是爱这里的。在这里呆了将近七年，人生中四分之一的时间。在这里遇到了很多有意思的人，知道了很多有意思的事，交了很多有意思的朋友，留下了很多有意思的回忆。我知道我没有理由不爱这里。很多事情只有当失去的时候才会认真的去珍惜，比如亲情，比如爱情，比如友情，比如包皮。再也没有导员没有班长没有学习委员打电话发邮件的告诉你什么什么事情该做了，再也没有同学可以挥手告别约好下学期再见，再也没有900块一年的床位还顺便附带4个好哥们陪你一起睡了，再也没有大家一起脱光了钻澡堂子捡肥皂聊天了，再也没有北邮校医院便宜到极点的包皮手术和祖卡木颗粒了，再也没有周末了一起约好网吧开黑五连坐了，再也吃不到虽然便宜但是难吃的食堂，再也没有几个人组团去自习，再也没有考前突击，再也没有人拿着足球敲你的门，再也没有一群人脱光了只穿着内裤站在一个屏幕前对着球赛大呼小叫了，就连夏天的小风扇很快你也就用不到了。突然间，你会发现你的生活中一下子就空出来了一大块，你习惯了七年的「习惯」戛然而止了，你不再受到学校的庇佑，你的朋友也各奔东西，你不再有寒暑假，你的学生证也只剩下纪念的意义。真的，就是这么戛然而止了。但生活仍旧继续，那些离开的终将离开，但不会带走一切。我感谢我的母校留给我的眼界、知识、态度以及科学素养，这些将使我受益终身；我感谢我的朋友带给我的激情、善良、勇气与陪伴，这些让我无时无刻感受到温暖；我感谢我在学校中经历过的种种带给我的见识、经验、应变和果断，这些让我能够应对一切即将到来的考验。所以啊，我没有理由不感恩，没有理由不心怀感激。感谢我的母校，希望北邮越来越好；感谢陪我走过这段日子的朋友们，希望你们都能实现梦想，勇敢前行；感谢这七年来经历过的一切，无论我当时做出的种种选择是对还是错，至少是你们真正的让我成为了现在的我，我无怨无悔。3月31日，北京邮电大学信息与通信工程学院工学硕士程康阳毕业。学生生涯至此结束。一切重新开始。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[支付宝/客户端开发实习生 实习总结]]></title>
    <url>%2F2015%2F09%2F01%2Falipay-internship-sumary%2F</url>
    <content type="text"><![CDATA[拖了蛮久的来写这篇博客，其实这里的文章似乎也只有我自己会看的样子，老是写这种流水账连自己都不愿意多看的文章真的好吗，不过既然有这个系列那么还是要坚持下去嗯。 和支付宝的缘分从曹哥的内推开始，其实也就是试一下看看能不能内推成功，结果还真的面上了，当时确实是很开心的，实际上从那个时候开始就想着妈的我就玩到7月然后去实习真是屌炸天的爽，但是后来还是被李惜劝住去他们公司做了果冻漫画，事实证明李惜是对的…… 说回正题。其实在支付宝的实习现在想来还真的蛮轻松，善攻是那种给个题目让你自己去发挥很少会干预的那种主管，说实话还是满不适应的。不过后来就习惯了，把一些可能会被检查的事情做完之后倒是有充足的时间去做点别的，这点比较舒服。 一开始是做Framework的修改和编译替换还有研究diff之类的东西，说实话这种事情确实不怎么搞的来，不过还是硬着头皮玩了一个多星期，收获了一堆理论知识，现在想来还是挺开心的。 后来就被叫去做网络抓包分析啦。一开始定的要求很高哎，抓包、修改包、还要在网页上实时显示什么的，也是在这些事情上纠结了一周左右，看了好几个开源的类似于网络攻击的项目，最终得出结论老子搞不定这东西（……），就在纠结怎么继续这个东西的时候主管刚好找上我让我做一下收银台部分的网络性能分析。我说，这个好哎，有意思而且看上去并不难的样子。然后剩下的一个半月时间里面，刨开离职那一周，剩下的都在做这件事啦。抓包分析什么的还是蛮有意思，具体的可以看看之前的博客，wireshark什么的。 其实工作上就这些吧，现在想起来也觉得没做什么，怪不得简历老是被筛掉，哎。 实习中其实最好玩的还是遇到了很多有趣的人。一起租房的5匹狼，超哥居家有才华会做饭很爱家还会玩乐队，简直屌的不行，哎，好像跟他再去买个菜做做饭；小棋帅逼会画画各种晚归女朋友一大把，东北老爷们也是屌的不行，哈哈；苏妈绝逼是个有强迫症的孩子，见我面就拍我肩膀，然后就是一声阳桑，接着三声哈哈哈，醉的不行；最后是大钊，一个谜一样的清华学霸，外表正直气质阳光，然而一张嘴绝对就是生殖器，我真的服气。哎，能够租在一起真的是缘分，能够这么投缘也是不容易，希望大家天涯各处，各自安好了。 然后是曹哥，哎，到了杭州就坑了他几天，说好的一起找房子结果被我临阵放了鸽子，自己一个人住也是空虚寂寞冷……没事曹哥以后我去上海会去找你的。 最后是同组的几个实习小伙伴啦，一个是笑起来猥琐的一逼的雁荡山香蕉，其实是个伪全栈，也是屌的不行；还有个修闭口禅的虫师，不说话则矣，一说话惊人；还有一起去雁荡山的小伙伴，醉杭、钢蛋、小凯和大眼，都是超级有意思的小伙伴，真心的祝愿你们一切都好。雁荡山大屌永远记得你们。 说完了这些，那最后来说说拥抱变化吧。哎，其实走的时候主管也讲了说我们都能留下，当时还很开心的说人生中第一个Offer到手了，走的时候还互相告别说明年再见，谁知道刚刚到北京休息了没两天就发通告说今年我们不招人——我们被拥抱变化了。 一开始还是很气愤的，说好的给offer呢？但是后来想想也就释然了，经济形势不好，阿里财报堪忧，他裁员都算轻的了，何况是不给这些实习生offer？一念至此，也是释怀，先好好修炼技术，以后再走社招进去好了。 哎，说这么多，也是蛮伤感，就写到这吧。 祝大家一切都好。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络及Wireshark学习笔记]]></title>
    <url>%2F2015%2F07%2F20%2Fwireshark-learning-note%2F</url>
    <content type="text"><![CDATA[1、网络通信原理ISO参考模型：7层协议。 7 应用层：用户接口。常用协议：HTTP、SMTP、FTP、Telnet6 表示层：数据编解码、加解密。常用协议：ASCII、MPEG、JPEG、MIDI。5 会话层：负责建立、维护连接。常用协议：NetBIOS、SAP、SDP、NWLink。4 传输层：提供可靠的数据传输。常用协议：TCP、UDP、SPX。3 网络层：路由转发、数据包分片。常用协议：IP、IPX。（路由器工作在这里）2 数据链路层：物理网络传输数据的方法，提供一个寻址方案，找到确实的设备。主要协议：Ethernet、Token Ring、FDDI、AppleTalk。（网桥、交换机工作在这里）1 物理层：硬件相关。 在传输中，会对传输的数据进行封装，封装的结果叫做协议数据单元PDU（Protocol Data Unit），发送时逐级向下封装，接收时逐级向上解封。 TCP/IP模型中没有表示层和会话层，协议栈中也没有单独设计相关的协议。以HTTP连接为例，应用层产生HTTP数据包，经过传输层，通过TCP协议进行可靠的传输，在网络层通过IP对于传输设备进行定位，最终在数据链路层通过加上以太网相关的头部，放入物理层进行传输。 网络硬件： 集线器：工作在链路层，将受到的信号转播到每一个端口中。不对Mac进行检查，效率低、半双工模式。交换机：工作在链路层，将收到的信号转播到对应的MAC地址的端口上，减少了机器拒绝的时间，效率更高，双工。路由器：工作在网络层，负责在多个网络之间转发数据包。通常使用第三层地址（IP）来标示网络上的唯一设备。 2、网络底层协议1、地址解析协议ARP正常网络通信中需要用到逻辑地址和物理地址。 逻辑地址用于不同网络、没有直接相连的设备之间进行通信。物理地址用于在单一网段中交换机直接连接的设备之间进行通信。 在TCP/IP协议中，IP地址已经完成了到第三层的传输，进一步的为了获取到设备的真实MAC地址进而进行单一网络中的通信，TCP/IP协议中使用ARP(Address Resolution Protocol)来进行IP向MAC地址的转换。 这个协议使用两种数据包，一个ARP请求，一个ARP响应。ARP请求通过向全部设备广播ARP请求消息，当网段中符合要求的主机收到消息，将发送ARP响应告诉请求者自己的真实MAC地址。 2、互联网协议IP在该层的通信中，主要负责跨网络的通信，在这个层面上协议不止一个，但是通行很广的还是IP协议，包括IPv6和IPv4。 v4条件下，IP地址被分为2个部分，网络地址和主机地址，网络地址用来标识局域网，主机地址则是标示这个网络中的设备本身，用于决定哪部分是主机，使用的是掩码，掩码中标示为1的位代表的是网络地址，剩下的则标示着主机地址。 IPv4头部很复杂，包含了很多有用的信息，比较重要的有： 存活时间TTL：定义了在该数据包被丢弃之前所能经历的时间（能够经历的最大路由数目）。数据包被发出时会定义TTL，之后每次经历一个路由器，正常情况下都会被减1，当网络拥堵时延较长时有可能被减掉更多（但多数时候不会）。TTL的设计原理在于，数据包在网络中传输通常会经历数十个路由器，其中难免会有错误配置的路由，在这种情况下路由器可能做很多事，其中一件就是让这个数据包进入死循环——而这必然会占用大量资源，直至DoS的情况出现，TTL的设定就是防止这种事情的发生。 IP分片：数据包分片的目的是将一个数据流分为更小的片段，是IP为了解决跨越不同类型网络时可靠传输的特性。数据包得分片主要基于第二层协议所使用的最大传输单元MTU的大小以及使用这些第二层设备的配置情况。以太网的默认MTU是1500，所以说以太网上能传输的最大数据包大小是1500字节。当需要传输的IP数据包大于MTU，将对这个数据包进行分片，分片的过程如下： 将传输的数据分块 将每个IP数据包的头部总长度设为每个分片的长度 将IP数据包头部中的分片标志位置1，除了最后一个数据包（最后一个数据包的Flags所有位都是0） 设置每个数据包的分片偏移量（这里注意，偏移量表征的是该IP数据包中的数据块对应于原有的大数据块中的偏移量。在MTU=1500情况下，第一个的offset是0，第二个的offset是1500-HeaderLength……） 3、传输控制协议TCP最终目的是提供数据可靠地端到端传递。该协议工作在第四层。能够处理数据的顺序和错误恢复，并且保证数据能够到到达其应该到达的地方。 TCP通信使用端口进行，所有的TCP通信都会使用源端口和目的端口（像电话机一样）。 TCP进行数据通信之前会进行著名的三次握手： 由发起链接请求的主机向连接对象送出一个TCP数据包，不含数据，只有包头，并且设置Flags量中的SYN为1，并发送一个SequenceNumber给对方。 目标主机收到SYN信号之后，回复SYN/ACK信号给发起主机。同时发送一个AcknowledgeNumber给对方，这个值等于收到的SequenceNumber+1；此外会发送属于目标主机的SequenceNumber给发起主机。 发起主机收到SYN/ACK信号之后，检查AcknowledgeNumber是否与本地的SequenceNumber+1相等，若想等则说明传输无误，回复ACK信号给目标主机，并且回复AcknowledgeNumber到目标主机，其值为目标主机的SequenceNumber+1，目标主机收到信号之后检查AcknowledgeNumber是否与本地的SequenceNumber+1相等，若想等则说明传输无误，连接建立。 TCP停止链接同样要经历几个过程： 请求结束的主机发送FIN/ACK到目的主机。 目的主机回复ACK到请求主机。 目的主机发送FIN/ACK到请求主机。 请求主机回复ACK到目的主机，结束链接。 4、用户数据报协议UDPUDP主要目的在于提高传输速率，是一种尽力服务，是一种无连接协议。一般依赖于UDP的服务会内建其他的可靠性措施。如DNS和DHCP这种高度依赖传输速度的服务，使用UDP作为传输层的协议，并自己实现差错控制的方法。 5、互联网控制消息协议ICMPTCP/IP协议栈中的一个效用协议，负责提供在TCP/IP网络上的设备、服务以及路由器可用性的分析。ICMP的类型和作用取决于其Type和Code域。Ping是一个工具，通过发送ICMP echo请求数据包来达到检测网络状况的目的。 3、高层网络协议1、DHCPDHCP是一个应用层协议，能够让设备自动获取IP地址，DHCP最主要的任务就是在续租过程中向客户端分配IP地址。DHCP的续租过程被称为DORA过程，分为以下四步： 发现（Discover）：在客户端启动的时候，首先会广播Discover报文（在这报文里面包括了客户端的MAC地址）。Discovery报文可以理解为：客户端去发现DHCP Server。由于是广播，可以保证DHCP server收到这个报文。 提供（Offer）：DHCP server收到这个报文后他就知道某个客户端要请求一个IP地址，DHCP server就参照Discover报文里面的MAC地址,然后从他配置的DHCP地址池里面分配一个IP地址。然后把这个地址用Offer消息告诉客户端。这个报文里面会把Discovery里面客户端的MAC包含进去。客户机收到后比较下MAC，发现报文里面的MAC和自己的MAC一样就会认为这个报文是发给他的。 请求（Request）：由于DHCP server可能有多个，所以客户端发一个Discovery就很有可能收到多个Offer。这时候客户端必须表示我用哪个Offer的地址。所以客户端再次发一个Request报文，表明我要用这个Discovery的报文。 确认（Acknowledge）：最后DHCP server回一个ACK。做一个确定。 2、域名系统DNS3、超文本传输协议HTTPHTTP是万维网的传输机制，允许浏览器通过连接Web服务器浏览网页。 HTTP GET过程建立在TCP之上，首先是通过三次握手建立连接，而后通过TCP向服务器设定的端口（HTTP通常默认使用80端口，HTTPS默认使用443端口）传递HTTP数据包，包中包含资源标示符、操作资源的方式等等定义。服务器读取请求之后通过发送一个HTTP包返回ACK信息。之后开始传输数据，形式是TCP分片。传输结束之后，服务器传输一个带有响应码的封包结束过程。成功的响应吗是200。 HTTP POST的过程也建立在TCP之上，过程与上类似，只是在结束之后的响应码通常为302，代表该资源找到。而这个响应的数据包通常也被用于重定向的手段，在其location域指明了客户端被重定向的位置。 4、超文本传输安全协议HTTPSHTTPS在传输数据之前需要客户端（浏览器）与服务端（网站）之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL协议不仅仅是一套加密传输的协议，更是一件经过艺术家精心设计的艺术品，TLS/SSL中使用了非对称加密，对称加密以及HASH算法。 握手过程的简单描述如下： 浏览器将自己支持的一套加密规则发送给网站。 网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。 获得网站证书之后浏览器要做以下工作： 验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。 如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。 使用约定好的HASH计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。 网站接收浏览器发来的数据之后要做以下的操作： 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。 使用密码加密一段握手消息，发送给浏览器。 浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。这里浏览器与网站互相发送加密的握手消息并验证，目的是为了保证双方都获得了一致的密码，并且可以正常的加密解密数据，为后续真正数据的传输做一次测试。 HTTPS一般使用的加密与HASH算法如下： 非对称加密算法：RSA，DSA/DSS对称加密算法：AES，RC4，3DESHASH算法：MD5，SHA1，SHA256 其中非对称加密算法用于在握手过程中加密生成的密码，对称加密算法用于对真正传输的数据进行加密，而HASH算法用于验证数据的完整性。由于浏览器生成的密码是整个数据加密的关键，因此在传输的时候使用了非对称加密算法对其加密。非对称加密算法会生成公钥和私钥，公钥只能用于加密数据，因此可以随意传输，而网站的私钥用于对数据进行解密，所以网站都会非常小心的保管自己的私钥，防止泄漏。 5、监听网络线路首先，需要一块支持混杂模式的网卡才能嗅探数据包，混杂模式的意思是它允许网卡看到所有流经网络线路数据包的驱动模式。 在集线器环境下进行数据嗅探是最理想的情况，你可以从你的端口中听到所有连接到集线器中的设备的网络通信信息。但是集线器环境已经基本不存在了，所以这个环境下的监听很难实现。 在交换机环境下进行数据嗅探则要复杂得多，因为交换机只会与特定端口进行通信（除某些广播消息外），通常采用的方法有如下几个： 端口镜像：通过设置交换机的镜像端口来实现监听。集线器输出：将需要监听的端口和监听器接入同一个集线器。（类似作弊）使用网络分流器：在通信链路中使用分流器监听。使用ARP欺骗：ARP负责翻译第三层的IP地址到第二层的MAC地址，如果我们污染了ARP缓存，使得目标设备的ip对应于嗅探器的mac，那么所有的进出流量都会经由嗅探器流动，从而也达到了监听的目的。 5、Wireshark简单使用说明 Wireshark的过滤器 分为捕获过滤器和显示过滤器，这两个过滤器都使用BPF语法进行过滤器的定义。BPF的语法结构为：n*限定词+ID=原语 多个原语通过||、&amp;&amp;、!连接起来成为一个限定表达式。 限定词分为三种： Type：数字或字母的意义 host(默认)，net，port……Dir：指明传输方向是前往还是来自 src，dstProto：指明匹配的协议 ether，ip，tcp…… 通过设定各种过滤条件，可以配置出各种符合我们需求的过滤器。 Wireshark高级特性 端点 endpoint：网络通信中的收发者。会话 conversation：端点之间的通信。 Wireshark中针对这两者有专门的统计工具，可以看到基于端点或者会话的流量状态。同时，Wireshark中还有基于协议栈的统计工具，可以看到某种协议下的链接占了总连接数的多少部分。 Wireshark同时提供对于Mac、ip地址的解析，可以直观的将MAC转换成对应的ip地址，但是这样会带来额外的DNS开销。可能会让抓包来的数据充斥着DNS数据包。 Wireshark提供对于协议数据包的强制解码能力，可以让你将数据包拆分成多个协议区段以分析。因为Wireshark的开源特性，当需要对某种特定的协议进行解析而软件中没有内置解析方法的时候，可以根据已有的解析文件进行自己编制新的解析文件。 Wireshark可以跟踪TCP流，可以看到TCP流整个过程中的发送情况。可以看到最原始的数据交换。 6、利用Wireshark解决网络问题利用TCP数据包的错误恢复特性进行网络环境的检修是非常有用的一件事。 1、TCP的错误恢复特性1、重传机制决定是否有必要重传的机制叫做重传计时器。这个计时器负责维护一个叫重传超时RTO的值，每当使用TCP传递一个数据包的时候计时器就启动，当收到这个数据包的ACK的时候计时器停止，这两个时刻之间的值叫做往返时间RTT，若干次RTT的测量之后得到的值就是RTO。在RTT值不够多的时候，依靠默认的RTO值。 RTO值被用于决定发送数据包之后过多久重传数据，当在这段时间内收到ACK信号则不需要重传，否则like重传，并将RTO值翻倍，依次类推直到达到最大重传数。 TCP在传递数据的时候，发送者会附带一个SEQ值，发送之后将该值自增发送数据包的大小，接受者成功接收之后会回复一个ACK值，其值为SEQ值和传递的数据包大小之和，若接收端收到的SEQ值不等于ACK那么为了保证数据的有序性，接收端会回复，该ACK值；发送者检查现在的SEQ和收到的ACK值是否一致，若连续三次检测到不一致，则代表数据丢失，则会按照接收端传回的ACK值发送数据包，完成数据重传。 当发送端认为接收端没有收到数据的时候会重传数据，这是通过RTO完成的，由发送端决定；当发送端收到连续三次接收端相同数据ACK的时候，也会临时重传数据，这是由接收端决定的。 2、流控制TCP使用滑动窗口技术来检测何时发生了数据包丢失并调整数据传递速率以加以避免。 通常接受主机有一个缓冲区和一个接收窗口，发送主机只能发送大小小于接收窗口的数据包，接受主机在接受了一定数量的数据之后会处理缓冲区中的数据，并返回ACK给发送主机，在ACK中更新窗口大小。如果接收机认为发送机的发送速率自己能够处理得过来，那么窗口大小不变；如果认为发送速度太快，那么将减小窗口大小；如果已经完全无法接收数据，那么将回设窗口大小为0。 2、定位网络延迟通常关注六个数据包：三次握手、初始HTTP GET请求、对该请求的确认以及第一个数据包： A -&gt; B:SYNC B -&gt; A:SYNC/ACK A -&gt; B:ACK A -&gt; B:GET B -&gt; A:ACK B -&gt; A:DATA 通常的，我们只关心这些步骤之间的延迟。通常的，异常的高延迟通常代表了以下的内容： 在三次握手中，通常接收到信号-&gt;回发送信号的过程是很难被影响到的，基本不会是因为这个原因产生延迟，因此在这个阶段的延迟通常都来自于网络传输。 从握手完毕到发送GET请求这个过程可能会因为客户端的处理器忙带来延迟。 从发出GET信号到收到服务器的确认消息的过程基本也只会被线路延迟影响。 从服务器发送ACK信号之后到第一次发送数据，这段时间可能会受到服务器的负载影响。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ADB(Android Debug Bridge)学习笔记]]></title>
    <url>%2F2015%2F07%2F15%2Fadb-learning%2F</url>
    <content type="text"><![CDATA[ADB=Andorid Debug Bridge。看到过很多，平时也是在用，但是没有系统的了解过，这里稍微深入的了解下。特别是之后可能会用到ADB进行设备文件的修改，因此认真学习一下还是很有必要的。 主要内容还是在Android Debug Bridge官方文档里，这里只是个大概的记录。 ADB包含三个部分： Client，运行在电脑上，可以通过adb命令开启或使用ADT或DDMS开启。Server，运行在电脑上，处于后台，用于与手机或模拟器上的ADB客户端进行通信。Daemon，一个运行在模拟器或真机上的后台程序 当你开启ADB的时候，客户端首先将检查ADB Server是否已经运行，如果没有则将开始ADB Server，该Server会与本地的TCP端口5037进行绑定，并且监听来自于ADB Client、经过5037端口与设备进行通信的ADB命令。 Server之后开始扫描从5555~5585的奇数端口找到所有链接到的模拟器或真机，在那里可以找到设备或模拟器上的Daemon后台程序，而后Server与之建立双重连接——奇数端口建立与Daemon的链接，比该奇数端口小1的偶数端口与控制台Console链接。为了使用ADB，必须在手机上将允许USB调试打开。 ADB的命令格式如下： 1adb [-d|-e|-s &lt;serialNumber&gt;] &lt;command&gt; -d意味着直接连接到唯一链接到电脑的设备。-e意味着直接连接到唯一连接到电脑的模拟器。-s &lt;serial number&gt;意味着直接连接到指定serial number的设备。（如emulator-5556） ADB的命令有很多，下面简单的列举一下： devices列举连接设备help打印帮助信息version查看adb版本logcat [option] [filter-specs]打印logbugreport打印dumpsys、dumpstate、logcatinstall &lt;path-to-apk&gt;安装apk到设备pull &lt;remote&gt; &lt;local&gt;将特定的文件从设备复制到本地push &lt;local-path&gt; &lt;remote-path&gt;将特定的文件推送到设备中forward &lt;local-path&gt; &lt;remote-path&gt;在特定的本地、远端端口建立socket链接get-serialno获得adb客户端的serial numberget-state获得adb客户端的adb状态start-server检查本地的adb server是否开启，如果没有则开启kill-server杀掉本地的adb servershell [shell command]在远端开启shell并且执行shell命令 ADB可以通过Wifi链接设备，步骤简单记录如下： 保证设备和电脑在同一个Wifi连接中。 将设备链接电脑 保证设备以USB模式链接： 123456$ adb usbrestarting in USB mode$ adb devicesList of devices attached######## device 以tcpip模式重启adb 12$ adb tcpip 5555restarting in TCP mode port: 5555 找到设备的IP地址#.#.#.#，让adb链接到该设备 12$ adb connect #.#.#.#connected to #.#.#.#:5555 拔出数据线，检查是否连接成功 123$ adb devicesList of devices attached#.#.#.#:5555 device 如果链接丢失，那么回到第5步再次执行命令即可。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>adb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android M Design Support Library 学习笔记]]></title>
    <url>%2F2015%2F07%2F10%2Fsupport-design-library-learning%2F</url>
    <content type="text"><![CDATA[随着Android M Preview的发布，新的MD控件库Design Support Library也随之发布。新加入的几个控件方便了我们在APP中应用Material Design。学习的同时记录一下。 1 FAB(FloatingActionButton)其实就是小红按钮fab，这次终于有了官方实现。 继承于ImageView，所以无法通过setBackground改变底色，通过backgroundTint设置背景色，通过src设置logo，通过fabsize设置大小(Default/Mini)，API21之后可以通过elevation设置阴影。 可以通过设置app:layout_anchor=&quot;@id/appbar&quot;来与AppBar联动。 2 TextInputLayout效果是一个始终显示Hint的EditText，点击获取焦点会让hint动态的移到EditText上方，输入错误之后会有错误信息，是个很漂亮很实用的控件。这个是个布局控件，继承于LinearLayout，需要和EditText配合使用。 关键方法： 123setHint()//设置HintsetErrorEnabled()//设置是否显示错误setError()//设置错误信息 3 Snackbar一个介于Dialog和Toast之间的轻量级通知控件。可以提供很方便的通知和用户反馈获取。用法很像Toast： 12345678final Snackbar snackbar = Snackbar.make(VIEW,"测试弹出提示",Snackbar.LENGTH_LONG); snackbar.show(); snackbar.setAction("取消",new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; snackbar.dismiss(); &#125; &#125;); VIEW可以是当前布局中任意一个控件，字体颜色使用colorAccent，也可以通过setActionTextColor改变颜色。 4 TabLayoutTab的官方实现！呼卓拉！终于不用自己在瞎JB写了，感动的想哭。 这个布局继承于HorizontalScrollView，常用的属性和可自定义的部分很多，稍微列举一下： 123456789101112131415161718192021app:tabSelectedTextColor：Tab被选中字体的颜色app:tabTextColor：Tab未被选中字体的颜色app:tabIndicatorColor：Tab指示器下标的颜色addTab(TabLayout.Tab tab, int position, boolean setSelected) 增加选项卡到 layout 中 getTabAt(int index) 得到选项卡 getTabCount() 得到选项卡的总个数 getTabGravity() 得到 tab 的 Gravity getTabMode() 得到 tab 的模式 getTabTextColors() 得到 tab 中文本的颜色 newTab() 新建个 tab removeAllTabs() 移除所有的 tab removeTab(TabLayout.Tab tab) 移除指定的 tab removeTabAt(int position) 移除指定位置的 tab setOnTabSelectedListener(TabLayout.OnTabSelectedListener onTabSelectedListener) 为tab增加选择监听器 setScrollPosition(int position, float positionOffset, boolean updateSelectedText) 设置滚动位置 setTabGravity(int gravity) 设置 Gravity ,GRAVATY_CENTER是居中显示，GRAVITY_FILL是把TAB填充至水平位置setTabMode(int mode) 设置 Mode,有两种值：TabLayout.MODE_SCROLLABLE和TabLayout.MODE_FIXED分别表示当tab的内容超过屏幕宽度是否支持横向水平滑动，第一种支持滑动，第二种不支持，默认不支持水平滑动。 setTabTextColors(ColorStateList textColor) 设置 tab 中文本的颜色 setTabTextColors(int normalColor, int selectedColor) 设置 tab 中文本的颜色 默认 选中 setTabsFromPagerAdapter(PagerAdapter adapter) 设置 PagerAdapter setupWithViewPager(ViewPager viewPager) 和 ViewPager 联动 用法上面也很简单： 123456789101112131415161718viewPager = findView(R.id.viewPager);//viewPagertabLayout = findView(R.id.tabs);//tabLayoutList&lt;String&gt; tabList = new ArrayList&lt;&gt;();//tab title listList&lt;Fragment&gt; fragmentList = new ArrayList&lt;&gt;();//fragment listtabList.add("Tab1");//填充title listFragment f1 = new TabFragment();Bundle bundle = new Bundle();bundle.putString("content", "http://blog.csdn.net/feiduclear_up \n CSDN 废墟的树");f1.setArguments(bundle);fragmentList.add(f1);//填充fragment listTabFragmentAdapter fragmentAdapter = new TabFragmentAdapter(getSupportFragmentManager(),fragmentList, tabList);//新建适配器viewPager.setAdapter(fragmentAdapter);//给ViewPager设置适配器tabLayout.setTabMode(TabLayout.MODE_FIXED);//设置tab模式，tabLayout.addTab(tabLayout.newTab().setText(tabList.get(0)));//添加tab选项卡tabLayout.setupWithViewPager(viewPager);//将TabLayout和ViewPager关联起来。 5 AppBarLayout继承于LinearLayout，作用是把其包裹的控件作为AppBar。多与Toolbar和tabLayout同时使用。和CoordinateLayout配合使用支持手势。 6 CoordinateLayoutCoordinatorLayout是一个增强型的FrameLayout。它的作用有两个：作为一个布局的根布局、最为一个为子视图之间相互协调手势效果的一个协调布局。 1app:layout_scrollFlags="scroll|enterAlways|enterAlwaysCollapsed|exitUntilCollapsed" 通过该属性来确定哪个组件是可滑动的，设置的layout_scrollFlags有如下几种选项： 1234scroll//所有想滚动出屏幕的view都需要设置这个flag- 没有设置这个flag的view将被固定在屏幕顶部。enterAlways//这个flag让任意向下的滚动都会导致该view变为可见，启用快速“返回模式”。enterAlwaysCollapsed//当你的视图已经设置minHeight属性又使用此标志时，你的视图只能已最小高度进入，只有当滚动视图到达顶部时才扩大到完整高度。exitUntilCollapsed//滚动退出屏幕，最后折叠在顶端。 为了使得Toolbar可以滑动，我们必须还得有个条件，就是CoordinatorLayout布局下包裹一个可以滑动的布局，比如 RecyclerView，NestedScrollView(经过测试，ListView，ScrollView不支持)具有滑动效果的组件。并且给这些组件设置如下属性来告诉CoordinatorLayout，该组件是带有滑动行为的组件，然后CoordinatorLayout在接受到滑动时会通知AppBarLayout中可滑动的Toolbar可以滑出屏幕了。 1app:layout_behavior="@string/appbar_scrolling_view_behavior" 总结： 为了使得Toolbar有滑动效果，必须做到如下三点： CoordinatorLayout 必须作为整个布局的父布局容器。 给需要滑动的组件设置 app:layout_scrollFlags=&quot;scroll|enterAlways&quot;属性。 给你的可滑动的组件，也就是RecyclerView或者NestedScrollView设置如下属性：app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot; 7 CollapsingToolbarLayout一个可折叠的Toolbar，通常作为AppbarLayout的子视图使用。在该布局中放置Toolbar和CollapsingToolbarLayout 提供以下属性和方法是用： 1234567Collapsing title//ToolBar的标题，当CollapsingToolbarLayout全屏没有折叠时，title显示的是大字体，在折叠的过程中，title不断变小到一定大小的效果。你可以调用setTitle(CharSequence)方法设置title。Content scrim//ToolBar被折叠到顶部固定时候的背景，你可以调用setContentScrim(Drawable)方法改变背景或者 在属性中使用 app:contentScrim=”?attr/colorPrimary”来改变背景。Status bar scrim//状态栏的背景，调用方法setStatusBarScrim(Drawable)。还没研究明白，不过这个只能在Android5.0以上系统有效果。Parallax scrolling children//CollapsingToolbarLayout滑动时，子视图的视觉差，可以通过属性app:layout_collapseParallaxMultiplier=”0.6”改变。CollapseMode//子视图的折叠模式，有两种: pin：固定模式，在折叠的时候最后固定在顶端； parallax：视差模式，在折叠的时候会有个视差折叠的效果。我们可以在布局中使用属性app:layout_collapseMode来改变。 总结: CollapsingToolbarLayout主要是提供一个可折叠的Toolbar容器，对容器中的不同视图设置layout_collapseMode折叠模式，来达到不同的折叠效果。 Toolbar 的高度layout_height必须固定，不能wrap_content，否则Toolbar不会滑动，也没有折叠效果。 为了能让FloatingActionButton也能折叠且消失出现，我们必须给FAB设置锚点属性 app:layout_anchor=&quot;@id/appbar&quot;意思是FAB浮动按钮显示在哪个布局区域。且设置当前锚点的位置 app:layout_anchorGravity=&quot;bottom|end|right&quot;意思FAB浮动按钮在这个布局区域的具体位置。两个属性共同作用才是的FAB浮动按钮也能折叠消失，出现。 给需要有折叠效果的组件设置layout_collapseMode属性。 8 NavigationView这个其实是对于以前的DrawerLayout中的ListView的整合实现。外侧布局和以前一样是DrawerLayout，而后直接使用这个布局作为抽屉布局。 123456789101112131415161718192021222324&lt;android.support.v4.widget.DrawerLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:id="@+id/drawer_layout" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;!-- the main content view --&gt; &lt;include layout="@layout/layout_content" /&gt; &lt;!-- the navigetion view --&gt; &lt;android.support.design.widget.NavigationView android:id="@+id/navigationView" android:layout_width="wrap_content" android:layout_height="match_parent" android:layout_gravity="left" android:fitsSystemWindows="true" app:headerLayout="@layout/layout_header" app:menu="@layout/layout_menu"&gt; &lt;/android.support.design.widget.NavigationView&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 自定义的部分比较简单，这里就不详细记录了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>MaterialDesign</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer 读书笔记]]></title>
    <url>%2F2015%2F03%2F18%2Fsword-to-offer-note%2F</url>
    <content type="text"><![CDATA[老夫的读书笔记不可能这么萌 Q4：替换空格 从后向前进行，首先计算空格个数得到替换之后的String长度，使用两个指针，一个指向旧String的尾部，一个指向新String的尾部，按照前指针的内容进行替换，当两个指针相遇时停止。 Q5：反向打印链表 使用栈 使用递归（当递归层级过深可能导致函数调用栈溢出） Q10：数字中1的位数 直接统计可能会造成死循环（负数情况） 使用对于1进行移位求与，当1移位N次之后为0则停止循环。 使用结论：把一个整数减去1再与原数求与会把该整数的最后一位1置0，不断的对待考察数进行该操作，知道被操作数归零结束。该方法的复杂度会降低。 Q10.1：判断一个数是不是2的整数次方 由上面的结论，2的整数次方数其二进制中只有1个1，只需要对该数减一之后与原数求与，若结果为零则是整数次幂。 Q11：求一个数的N次幂 底数是不是0 指数的正负 double的equal方法 使用位运算来高效的进行2的幂次运算、使用递归来对幂次进行二分，考虑奇偶性。 Q12：打印1到最大的N位数 大数陷阱：当N大到无法用常用基本数据类型承载的时候，如何打印： 使用Char数组，模拟整数加法，注意结束条件（复杂），打印时不能打印出最前面的0. 使用Char数组，对每一位取10种可能，递归到结束。 Q13：在O(1)复杂度时间内删除链表节点，给定该节点的指针和链表头指针。 【狸猫换太子】 若该节点不是独立节点或尾节点，那么将该节点的下一个节点的内容复制到该节点，并将该节点的下一节点指针指向该节点的下一节点的下一节点。 若该节点是尾节点，只能遍历链表找到前序节点，将其next指针置空，释放尾节点空间。 若该节点是头结点，那么将头指针置空，释放节点空间。 虽然在尾节点的时候会需要时间去遍历，但是平均时间复杂度还是维持在O(1)上的。 Q15：链表中的倒数第K个节点 双指针，前指针距后指针K-1的距离。 考虑以下负面情况： 头指针为空 K为0 链表长度小于K Q16：链表反转 三指针，pre，cur，next，遍历一次即可。 注意以下情况： 头指针为空 单节点情况 返回值为尾指针 链表断裂 Q17：合并两个排序的链表 采用递归的方式合并，考虑头指针为空的情况。 12345678mergeLinkedList(head1,head2)Node* mergedHeadif(head1-&gt;value &lt; head2-&gt;value) mergedHead = head1; mergedHead-&gt;next = mergeLinkedList(head1-&gt;next,head2);else mergedHead = head2; mergedHead-&gt;next = mergeLinkedList(head1,head2-&gt;next); Q18：给定两个二叉树AB，输出B是否是A的子树 使用两个递归函数进行： 123456789101112131415161718192021222324252627bool HasSubTree(head1,head2)&#123; bool hasSubTree = false; if(head1!=null &amp;&amp; head2!=null)&#123; if(head1-&gt;value == head2-&gt;value)//从根节点是否包含 hasSubTree = DoesTree1HasTree2(head1,head2); if(!hasSubTree)//根节点不包含的话，左子结点是否包含 hasSubTree = DoesTree1HasTree2(head1-&gt;left,head2); if(!hasSubTree)//左子结点不包含的话，右子节点是否包含 hasSubTree = DoesTree1HasTree2(head1-&gt;right,head2); &#125; return hasSubTree;&#125; bool DoesTree1HasTree2(head1,head2)&#123;//判断是否包含的核心函数 if(head2 == null) return true;//树2为空，肯定包含 if(head1 == null) return false;//树1为空，肯定是不不含的 if(head1-&gt;value != head2-&gt;value) return false;//根节点的值不一样的话，肯定也是不包含的 return DoesTree1HasTree2(head1-&gt;left,head2-&gt;left) &amp;&amp; DoesTree1HasTree2(head1-&gt;right,head2-&gt;right)//根节点相同的情况下，每个节点都包含那么就包含。 &#125; Q19：二叉树的镜像 前序遍历二叉树，若节点有子节点，那么交换两个子节点，递归完成。 Q20：顺时针打印矩阵 将问题分解： 打印一个矩阵可以看做是对矩阵的几个环的打印，每个环的起点都是（startX，startX），当columns&gt;StartX*2&amp;&amp;rows&gt;startX*2时循环可以继续。 打印一个环可以看做在4个方向上遍历矩阵，但是不同的情况下需要遍历的边不一样： 从左向右的第一步是肯定存在的，从startX打印到Columns-1-startX 从上到下的第二步，只有在结束行号比开始行号大的时候才存在，从startY打印到Rows-1-startY 从左到右的第三部，只有在结束行号比开始行号大并且结束结束列号比开始咧号大时才有。 从下到上的第四步，只有在结束行号比开始行号大2时才会有。 Q21：包含min的栈 实现一个栈，调用min、push、pop的时间复杂度都是O(1) 使用辅助栈保存每次入栈时的最小值，每次出入栈操作都是对两个栈同时操作。这样在另一个栈中，栈顶元素总是原始栈中相同高度的最小值。 Q22：栈的压入、弹出序列 给定两个序列，判断后一个是不是前一个的弹出序列。 建立一个辅助栈，将前一个序列按照顺序依次入栈，直到遇到弹出序列的第一个元素，将这个元素入栈再出栈，若此时的栈顶元素不等于出栈序列的下一个数，那么继续按照入栈序列入栈直到遇到出栈序列的下一个数，如果最后所有入栈序列的数都入栈了还没找到下一个元素，那么该给出的出栈序列不是该入栈序列的出栈序列。 Q25：二叉树中和为某值得路径 计算和的方法很简单，利用递归，如果加上本节点之后和达不到，则以新的目标遍历两个子节点，如果达到了，并且该节点是叶子节点，那么将其输出。 本题要求输出路径，那么利用栈储存每次经历的节点，在考察完毕后pop即可。 1234567891011121314151617181920FindSum(Node* root, int expectedSum, int curSum, Vector Path)&#123; //便利到此节点时的和 curSum+=root-&gt;value; //将该节点加入路径 path.push(root-&gt;value); //打印路径 bool isLeaf = root-&gt;left==null &amp;&amp; root-&gt;right-&gt;right==null; if(curSum==expectedSum &amp;&amp; isLeaf)&#123; //print path &#125; //不是叶子节点，遍历他的两个叶子节点 if(root-&gt;left!=null) FindSum(root-&gt;left,expectedSum,curSum,path); if(root-&gt;right!=null) FindSum(root-&gt;right,expectedSum,curSum,path); //返回父节点之前先删除当前节点的路径 path.pop();&#125; Q26：复制复杂链表 首先用next完成链表的初始复制，与此同时，将每个节点的源节点和复制后的节点的对应用hashmap存起来，之后在对sibling进行赋值的时候可以找到对应的地址。【空间换时间】 将新链表复制到每个节点的后面：a-&gt;b-&gt;c =&gt; a-&gt;a’-&gt;b-&gt;b’-&gt;c-&gt;c’，将新的sibling复制为旧sibling的首尾均+1位置，最后将基数为和偶数位分别连起来就成了两个链表了。 Q28：字符串的排序 将每一位与后面的位进行交换之后对剩下的位进行递归的相同运算。 Q28.1：N皇后问题 将A[N]设置为0~N-1，对应了第N行中皇后放在那一列。对这个数组进行全排列，对每个排列只需要考察其是否满足对角线上没有皇后这一条件即可。（肯定不在同一行同一列的） 判断是否在对角线上是看是否满足i-j==A[i]-A[j]或j-i==A[i]-A[j] Q33：把数组排成最小的数 将一个数组按一定顺序拼接起来，得到的数最小 不能全排列之后找最大，太多 以某种规则将该数组排序是最好的方式: 设元素一为m，元素二为n，拼接起来为mn或nm，若mn&gt;nm，那么n应该在m前面 写一个compare函数，用qsort对数组排序，整个复杂度在O(NlogN)内 当然这个理论需要证明就是了…… Q38：二叉树的深度 采用递归的方式可以方便的得到： 12345678int treeDepth(Node* tree)&#123; if(tree == null) return 0; int leftDepth = treeDepth(tree-&gt;left); int rightDepth = treeDepth(tree-&gt;right); return (leftDepth &gt; rightDepth)?leftDepth+1:rightDepth+1;&#125; Q38.1：判断一个二叉树是不是平衡二叉树（任意节点的左右子树深度相差不超过1） 使用后序遍历的方式遍历整个二叉树，在遍历某节点的左右子节点之后可以根据其深度判断是不是平衡的并且更新当前根节点的深度。 1234567891011121314151617181920212223bool IsBalance(Node* tree, int* depth)&#123; if(tree == null) &#123; *depth = 0; return true; &#125; int left,right; if(IsBalance(tree-&gt;left,&amp;left) &amp;&amp; IsBalance(tree-&gt;right,&amp;right))&#123; int diff = left - right; if(diff &gt;= -1 &amp;&amp; diff &lt;= 1)&#123; *depth = 1+(left&gt;right?left:right); return true; &#125; &#125; return false;&#125;bool IsBalance(Node* tree)&#123; int depth = 0; return 1IsBalance(tree,depth);&#125; Q43：N个骰子的点数 N个骰子抛掷点数和为S的概率。 依据：和为S时N个骰子的情况个数等于N-1个骰子时，和为S-1、S-2、S-3、S-4、S-5、S-6的情况和。 由此，可以由两个数组很方便的得到结果。 Q44：判断五张牌是不是顺子 J=11，Q=12，K=13，A=1，大小Joker可以代表任何数，Joker=0 首先对5张牌排序，然后统计0的个数、是否有连续两个非零的数、连续两个不同得数之间差了多少，能不能和0的个数相同。 Q47：不使用加减乘除做加法 使用位运算： 第一步：按位异或，得到数A（模拟相加不进位） 第二步：按位与，左移一位，得到数B（得到进位的数） 第三部：使用AB重复前两步]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android启动模式归纳]]></title>
    <url>%2F2015%2F03%2F17%2Flauch-mode-summary%2F</url>
    <content type="text"><![CDATA[启动模式对于Android开发是很重要的，各种启动模式之间的区别必须要掌握，这里简单的归纳一下。 启动模式 Standard 标准模式，不会新建Task，会重复建立Activity。 A B C D -New B-&gt; A B C D B&#39; SingleTop 单Task，单栈顶元素模式。 当新建Activity的时候，如果该Activity在栈顶，那么将不会新建activity，直接复用原有的activity。 A B C D -New D-&gt; A B C D 如果不在栈顶，那么会重新建立这个Activity。 A B C D -New B-&gt; A B C D B SingleTask 在Task中只会有一个Activity的实例。 如果Task中没有该Activity的实例，那么在栈顶加入新建的Activity A B C D -New E-&gt; A B C D E 如果Task中有该Activity的实例，并且在栈顶，那么和SingleTop一样的策略 A B C D -New D-&gt; A B C D 如果Task中有该Activity的实例，但是不在栈顶，那么这个时候新建该Activity，会将已有的该Activity实例之前的Activity全部出栈。 A B C D -New B-&gt; A B SingleInstance 在该模式下，不论从哪个Task加载Activity，只会创建一个Activity实例，并且会使用一个全新的Task栈来装载。 要创建的Activity实例不存在，这个时候会创建一个新的Task栈，并将Activity实例化后放入该栈。 A B C D -New E-&gt; A B C D (New Task) E 要创建的Activity实例存在，这时候系统会将该Activity所在的Task转到前台。 注意此种模式下加载的Activity总是处于栈顶的，使用该模式创建的Task只包含该Activity Intent Flag Brought to front 如果该Activity的实例已经存在了但是不在栈顶，那么将会把这个Activity的实例转移到栈顶，如果没有的话当然就是在该Task的栈顶加入该Activity的实例了： 注意，这里是A通过该Flag启动B，然后D通过任意方式启动B，会实现这种效果。 A-Flag-&gt;B C D -New B-&gt; A C D B Clear top 同SingleTask的启动模式。 New task 同Standard启动模式。 No animation 启动时不使用过渡动画。 No history 从该Activity的实例跳转之后不会保留该实例在Task栈中： 注意，这里是C通过该Flag启动D，D以任意方式启动E得到的结果。 A B-Flag-&gt;C D -New E-&gt; A B C E Reorder to front 如果Task栈中已有Activity实例，那么通过该Flag启动的话，会直接将其转入栈顶。 注意这里与Brought to front的区别，前一个Flag是在第一次启动那个任务的时候设置的，这个Flag不需要第一次启动的时候设置，在下一次用得到的时候再设置，将已有的Activity转到前台。 A B C D -Flag New B-&gt; A C D B Single top 相当于SingleTop模式。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程算法艺术（July-Github版）学习笔记]]></title>
    <url>%2F2015%2F03%2F16%2Fart-in-algorithm-note%2F</url>
    <content type="text"><![CDATA[July的干货还是不少的…… 数据结构一、字符串 旋转 三步反转法，O(N)复杂度。 字符串包含 这里的问题是字符串是否包含某些字母，这里可以用bit-map实现。 字符串转数字（AtoI） 考虑问题需要全面： 开头的正负号，是否只有正负号 字符串是否为空 字符串中包含非数字字符 溢出： 如 2147483650, result &gt; MAX/10 如 2147483649, result == MAX/10 &amp;&amp; digit &gt; MAX%10 回文（palindrome） 判断：从中间往两边或者是从两边往中间，两个指针扫描一次即可。 最长回文子串（LPS）： Manacher算法，O（N）复杂度。 全排列 没有重复元素的全排列 这个情况下的全排列可以使用递归完成。每次排列都是首字母依次与包含首字母在内的元素进行交换，交换后从次字母开始递归的进行算法。 如：abc，首先a与a交换位置，求bc的全排列，b与b交换位置，求c的全排列，c的位置是最后一个，输出此时的字符串abc，退回到之前的状态栈，b与c交换位置，求b的全排列，b是最后一个，输出此时的字符串acb，退回到之前的状态栈…… 有重复元素的全排列 这个情况下的全排列依然是上面的思路，但是这里需要注意的是，在元素i与元素j进行交换的时候，要求[i,j)中没有与第j个元素相等的元素。即被交换的元素不能曾经被交换过。 如：abb，a与a交换，对bb进行递归，不满足交换条件，对b进行递归，到达底部无法交换，输出abb；a与b交换，满足条件可以交换，对ab进行递归，对a进行交换，得到ab，对b进行递归，发现到达底部无法交换，输出bab；对b进行交换，满足交换条件，得到ba，对a进行递归，发现到达底部无法交换，输出bba；a与b进行交换，发现不满足条件，略过，输出结束。 全组合 使用bit-map解决。 问题集【待补完】 第一个只出现一次的字符 在字符串中删除特定的字符 字符串匹配 字符个数统计 Hash 字符串的集合 最长重复子串（LCS） 字符串压缩 均分01 给定一个字符串，长度不超过100，其中只包含字符0和1,并且字符0和1出现得次数都是偶数。你可以把字符串任意切分，把切分后得字符串任意分给两个人，让两个人得到的0的总个数相等，得到的1的总个数也相等。 将该串字符串看做一个环，由于01均为偶数且切分后字符串可任意组合，那么必然存在一个直径将所有的1分为两个部分，同时也将0分为了两个部分，这两个部分的01个数相同。由此我们可以得到结论是，在该字符串中切至多两刀，我们就能找到一个窗，其中的01个数与其外的01个数相同。 代码实现可以以n/2的间隔建立两个窗边界，遍历一次即可知道该窗应放置在哪个位置了。 二、链表 在O(1)时间删除链表节点 用下个节点的数据覆盖前一个。注意链尾的情况。 单链表的转置 使用三个工作指针，不断的将每个节点的指向改变。 第k个节点 使用两个指针，前一个距离后一个K的距离，遍历至末尾。 中间节点 使用两个指针遍历，前一个的移动速度时候一个的两倍，遍历至末尾。 环 判断是否成环 使用两个指针，前一个的移动速度是后一个的两倍，遍历至两者相遇，则说明存在环。 寻找入口 接上，在两个指针相遇之后，后指针回到链表起点，前指针以与后指针相同的速度从相遇点开始遍历链表，两者相遇节点就是环的开始节点。 判断是否相交（无环） 若相交，则两链表从相交处往后一定是相同的，那么只需要考察两链表最终是否指向同一节点。 有环情况下（有环） 若相交，在有环情况下，其必然共有一个环，只需要遍历其中一个链表，找到一个环中元素，再在另一个链表中寻找该元素即可。 相交的第一个公共节点（无环） 由对其的思想可知，在无环情况下，其公共部分是一样的，那么，只需要找到两个链表长度的差值，长的链表从该差值开始，与短链表一起同时遍历，遇到的第一个公共节点就是两个链表的第一个公共节点。 三、数组 K-th 求一个数组中第K大的数，可以有以下集中思路： 排序，取第K个。复杂度最好是O(NlogN)。 维护一个大小为K的堆，以最大堆为例，首先以O(K)的时间用前K个数建立一个最大堆，然后遍历后n-k个数，如果比对顶的元素小，那么将堆顶元素出堆，将该数加入堆中，出堆元素回到新入堆元素的位置上。 由于堆操作的时间复杂度为O(logK)，复杂度可以简化至O(K+(N-K)logK)=O(NlogK) 使用QuickSelect算法。平均情况下O(N)复杂度。 使用快速排序思想，选取一个锚点pivot将数组分为两个部分Sa和Sb，若Sa的元素（不含pivot）个数大于等于K，那么第K大得数在Sa里，继续递归的对Sa进行考察；若Sa的元素等于K-1（即含pivot在内共有k个元素），那么该pivot即为待求的第K个值；若Sa的元素少于K个，那么说明第K大得元素在Sb中，应对这个序列应用算法。 在求pivot的时候使用median3算法，其做法是将给定序列的首中尾按照大小顺序排列，并把pivot放置在倒数第二个位置。 两个有序数列和的K-th问题 使用最小堆进行处理。其思想在于从小到大依次找到前K个组合，由于A[0]+B[0]必然是第一个元素，紧跟其后仅比这个组合小的元素是A[0]+B[1]或A[1]+B[0]，将A[0]+B[0]出堆之后，将这两个元素压入堆中，作为下一次出堆的备选。推而广之的，设每次出堆的组合为A[i]+B[j]，那么需要同时将A[i+1]+B[j]和A[i]+B[j+1]压入堆中，直到完成K次出堆。由于建堆的时间复杂度为O(K)，堆操作时间为O(logK)，共有K*O(logK)次堆操作，总的时间复杂度为O(NlogK)。 K-Sum 2Sum： 排序后二分搜索，O(NlogN)/O(1) 排序后从头尾双向扫描，O(NlogN)/O(1) 构造X-S[i]数组或Hash，O(N)/O(N) K-Sum: 3Sum可以转化为2Sum；4Sum可转化为3Sum然后转化为2Sum…… KSum的递归Sum(A,Sum,i)函数实现：（数组A，和为Sum，还有i个值） 若取第i个数，则问题转化为Sum(A,Sum-A[i],i-1) 若不取第i个数，则问题转化成Sum(A,Sum,i-1) 终止条件为Sum&lt;=0或n&lt;=0 输出结果条件为Sum==A[i] 背包问题（经典的动态规划模型）【待补完】 01背包 N件物品，V个背包，放入第i件物品的费用是C[i]，价值为W[i]，求解放入哪些物品使得背包价值最大。 解法：设f[i][v]代表了前i件商品恰好放入一个容量为v的背包中的最大价值那么可以得到这么一个等式： f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]} 其代表的意义是，f[i][v]的最大值是“不放第i件商品得到的最大价值”和“放入第i件商品得到的最大价值”的大者。 最大连续子数组和 输入一个整形数组，数组里有正数也有负数。数组中连续的一个或多个整数组成一个子数组，每个子数组都有一个和。 求所有子数组的和的最大值，要求时间复杂度为O(n)。 解法：由于最大子数组的首尾肯定不能包含和为负的子数组，由此我们可以从头开始遍历该数组，得到从上一个非负位置开始的累加和，若累加和为负则清零并重新记录起点。并且在整个过程中维护两个变量：CurSum和MaxSum。由以下的公式来维护CurSum： currSum = (a[j] &gt; currSum + a[j]) ? a[j] : currSum + a[j]; 跳台阶问题 一个台阶总共有n级，如果一次可以跳1级，也可以跳2级。是斐波那契数列的一个变体。写出通项即可。 换硬币问题 给定几个面额的硬币和一个价值和，问有多少种换法。 递归解法：设换法有F(Value,Kind)种，硬币面额数组为value[Kind]那么有: F(v,k)=F(v,k-1)+F(v-value[K-1],k) 意义为，使用K种硬币的换法等于不使用第k种硬币的换法加上使用第k种硬币的换法。 非递归解法：使用DP。【待补完】 荷兰国旗问题 现有n个红白蓝三种不同颜色的小球，乱序排列在一起，请通过两两交换任意两个球，使得从左至右，依次是一些红球、一些白球、一些蓝球。 解法：类似于快排中的partition过程，中间的白球就是锚点，设置三个指针，Begin、Current、End，以以下原则进行移动、交换： 开始时Begin和Current在起点，End在终点。 若Current指向白球，则移动至下一个（Current++）。 若Current指向红球，则与Begin交换，并且Begin指向下一个，Current指向下一个（Begin++，Current++） 若Current指向蓝秋，则与End交换，Current不动，End指向前一个（End–） 运行至End遇到Current，结束算法。 问题集 找出数组中的唯一出现过两次的元素，其余数都只出现过一次。 （1-1000放在含有1001个元素的数组中，找到重复的那一个。） 对数组求和，减去1-1000的和，就是重复的数字。这个方法可能因为相乘的结果过大而溢出。 利用异或的性质：a^b^a=a^a^b=0^b=b(0与0异或为0，1与0异或为1，相当于不会对原数造成变化)，将该1001个数组元素与0-1000进行异或，那么最终得到的结果就是重复的一个数。 Bit-map或Hash，将这1001个元素映射到每一位上，重复的那个数位置上为0。但是这种方法会带来额外的空间开销。时间复杂度都是线性的。 找出数组中唯一一个只出现一次的元素，其余元素均出现过两次。 利用异或的性质将求整个数组的异或和，结果即为唯一一个不重复的元素。 找出数组中唯一一个只出现一次的数，其余元素均出现过三次。 统计这个数组中的所有数（int）在各个位上的1出现的次数，单个的那个数如果在这个位上是1，那么肯定无法被3整除，反之可以，通过统计这个可以知道该单个的数在哪些位上是1，从而得到这个数。 找出唯一的K个数，其余的数都出现过两次，有几个数只出现过一次。 K=2 其思路在于，这两个只出现过一次的数肯定是不一样的，在某些位上肯定是不相同的，我们通过将整个数组进行异或和计算得到哪一位是不同的，根据该位是0还是1将原数组分为两个子数组，这两个子数组必然分别包含了这两个数以及其他重复的数，我们对这两个数组分别进行异或和的计算就可以分别得到这两个非重复的数了。 K=3 [待补完] 寻找数组中的逆序数 给定一整型数组，若数组中某个下标值大的元素值小于某个下标值比它小的元素值，称这是一个反序。 利用并归排序算法的过程中自然产生的对于逆序数的访问，累计逆序数的个数。在并归排序每一次的变序选择中，可以记录下所有的逆序个数。 【待补完】 四、树 二叉查找树 性质： 若任意结点的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若任意结点的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 任意结点的左、右子树也分别为二叉查找树。 没有键值相等的结点 查找、插入、删除的时间复杂度均为O(logN)，但有可能退化至O(N) 红黑树 本质上来说就是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)。 性质： 每个结点要么是红的，要么是黑的。 根结点是黑的。 每个叶结点（叶结点即指树尾端NIL指针或NULL结点）是黑的。 如果一个结点是红的，那么它的俩个儿子都是黑的。 对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点。以上的性质保证了红黑树的高度始终为logN，进而保证了各项操作的时间复杂度始终为O(logN) 【待补完】 五、算法心得 有序数组的查找 二分搜索【要会写】 杨氏矩阵的搜索 首先直接定位到最右上角的元素，配以二分查找，如果当前元素比待查数大则往左走，比待查数小则往下走。 出现次数超过一半的数字 数组中有一个数字出现的次数超过了数组长度的一半，找出这个数字。 解法： 排序，O(NlogN)/O(1) Hash，O(N)/O(N) 使用time/candidate 在遍历数组的时候保存两个值：一个candidate，用来保存数组中遍历到的某个数字；一个nTimes，表示当前数字的出现次数，其中，nTimes初始化为1。当我们遍历到数组中下一个数字的时候： 如果下一个数字与之前candidate保存的数字相同，则nTimes加1； 如果下一个数字与之前candidate保存的数字不同，则nTimes减1； 每当出现次数nTimes变为0后，用candidate保存下一个数字，并把nTimes重新设为1。 直到遍历完数组中的所有数字为止。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试中的链表问题归纳]]></title>
    <url>%2F2015%2F03%2F15%2Flink-questions%2F</url>
    <content type="text"><![CDATA[本文转载自WuChong的Blog，这里转载仅留归自用，感谢他的总结与归纳。 下面是本文所要用到链表节点的定义： 1234struct Node&#123; int data; Node* next;&#125;; 1. 在O(1)时间删除链表节点题目描述：给定链表的头指针和一个节点指针，在O(1)时间删除该节点。 分析：本题与《编程之美》上的「从无头单链表中删除节点」类似。主要思想都是「狸猫换太子」，即用下一个节点数据覆盖要删除的节点，然后删除下一个节点。但是如果节点是尾节点时，该方法就行不通了。 代码如下： 12345678910//O(1)时间删除链表节点，从无头单链表中删除节点void deleteRandomNode(Node *cur)&#123; assert(cur != NULL); assert(cur-&gt;next != NULL); //不能是尾节点 Node* pNext = cur-&gt;next; cur-&gt;data = pNext-&gt;data; cur-&gt;next = pNext-&gt;next; delete pNext;&#125; 2. 单链表的转置题目描述：输入一个单向链表，输出逆序反转后的链表 分析：链表的转置是一个很常见、很基础的数据结构题了，非递归的算法很简单，用三个临时指针 pre、head、next 在链表上循环一遍即可。递归算法也是比较简单的，但是如果思路不清晰估计一时半会儿也写不出来吧。 下面是循环版本和递归版本的链表转置代码： 12345678910111213141516171819202122232425262728293031//单链表的转置,循环方法Node* reverseByLoop(Node *head)&#123; if(head == NULL || head-&gt;next == NULL) return head; Node *pre = NULL; Node *next = NULL; while(head != NULL)//当head为空时结束 &#123; next = head-&gt;next;//暂存next head-&gt;next = pre;//反转该节点的指向 pre = head;//pre移动到下一个操作节点 head = next;//head移动到下一个操作节点 &#125; return pre;//此时head为空，pre是新的首指针&#125;//单链表的转置,递归方法Node* reverseByRecursion(Node *head)&#123; //第一个条件是判断异常，第二个条件是结束判断 if(head == NULL || head-&gt;next == NULL) return head; Node *newHead = reverseByRecursion(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = NULL; return newHead; //返回新链表的头指针&#125; 3. 求链表倒数第k个节点题目描述：输入一个单向链表，输出该链表中倒数第k个节点，链表的倒数第0个节点为链表的尾指针。 分析：设置两个指针 p1、p2，首先 p1 和 p2 都指向 head，然后 p2 向前走 k 步，这样 p1 和 p2 之间就间隔 k 个节点，最后 p1 和 p2 同时向前移动，直至 p2 走到链表末尾。 代码如下： 1234567891011121314151617181920212223//倒数第k个节点Node* theKthNode(Node *head,int k)&#123; if(k &lt; 0) return NULL; //异常判断 Node *slow,*fast; slow = fast = head; int i = k; for(;i&gt;0 &amp;&amp; fast!=NULL;i--) &#123; fast = fast-&gt;next; &#125; if(i &gt; 0) return NULL; //考虑k大于链表长度的case while(fast != NULL) &#123; slow = slow-&gt;next; fast = fast-&gt;next; &#125; return slow;&#125; 4. 求链表的中间节点题目描述：求链表的中间节点，如果链表的长度为偶数，返回中间两个节点的任意一个，若为奇数，则返回中间节点。 分析：此题的解决思路和第3题「求链表的倒数第 k 个节点」很相似。可以先求链表的长度，然后计算出中间节点所在链表顺序的位置。 但是如果要求只能扫描一遍链表，如何解决呢？最高效的解法和第3题一样，通过两个指针来完成。用两个指针从链表头节点开始，一个指针每次向后移动两步，一个每次移动一步，直到快指针移到到尾节点，那么慢指针即是所求。 代码如下： 12345678910111213141516//求链表的中间节点Node* theMiddleNode(Node *head)&#123; if(head == NULL) return NULL; Node *slow,*fast; slow = fast = head; //如果要求在链表长度为偶数的情况下，返回中间两个节点的第一个，可以用下面的循环条件 //while(fast &amp;&amp; fast-&gt;next != NULL &amp;&amp; fast-&gt;next-&gt;next != NULL) while(fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; &#125; return slow;&#125; 5. 判断单链表是否存在环题目描述：输入一个单向链表，判断链表是否有环？ 分析：通过两个指针，分别从链表的头节点出发，一个每次向后移动一步，另一个移动两步，两个指针移动速度不一样，如果存在环，那么两个指针一定会在环里相遇。 代码如下： 123456789101112131415161718//判断单链表是否存在环,参数circleNode是环内节点，后面的题目会用到bool hasCircle(Node *head,Node *&amp;circleNode)&#123; Node *slow,*fast; slow = fast = head; while(fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if(fast == slow) &#123; circleNode = fast; return true; &#125; &#125; return false;&#125; 6. 找到环的入口点题目描述：输入一个单向链表，判断链表是否有环。如果链表存在环，如何找到环的入口点？ 解题思路： 由上题可知，按照 p2 每次两步，p1 每次一步的方式走，发现 p2 和 p1 重合，确定了单向链表有环路了。接下来，让p2回到链表的头部，重新走，每次步长不是走2了，而是走1，那么当 p1 和 p2 再次相遇的时候，就是环路的入口了。 为什么？：假定起点到环入口点的距离为 a，p1 和 p2 的相交点M与环入口点的距离为b，环路的周长为L，当 p1 和 p2 第一次相遇的时候，假定 p1 走了 n 步。那么有： p1走的路径： a+b ＝ n； p2走的路径： a+b+k*L = 2*n； p2 比 p1 多走了k圈环路，总路程是p1的2倍。 根据上述公式可以得到：k*L=a+b=n 显然，如果从相遇点M开始，p1 再走 n 步的话，还可以再回到相遇点，同时p2以同样的速度从头开始走的话，经过n步，也会达到相遇点M。 显然在这个步骤当中 p1 和 p2 只有前 a 步走的路径不同，所以当 p1 和 p2 再次重合的时候，必然是在链表的环路入口点上。 代码如下： 1234567891011121314151617181920212223242526//找到环的入口点Node* findLoopPort(Node *head)&#123; Node *slow,*fast; slow = fast = head; //先判断是否存在环 while(fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if(fast == slow) break; &#125; if(fast != slow) return NULL; //不存在环 fast = head; //快指针从头开始走，步长变为1 while(fast != slow) //两者相遇即为入口点 &#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; return fast;&#125; 7. 编程判断两个链表是否相交题目描述：给出两个单向链表的头指针比如h1、h2，判断这两个链表是否相交。这里为了简化问题，我们假设两个链表均不带环。 解题思路： 直接循环判断第一个链表的每个节点是否在第二个链表中。但，这种方法的时间复杂度为O(Length(h1) * Length(h2))。显然，我们得找到一种更为有效的方法，至少不能是O（N^2）的复杂度。 针对第一个链表直接构造hash表，然后查询hash表，判断第二个链表的每个节点是否在hash表出现，如果所有的第二个链表的节点都能在hash表中找到，即说明第二个链表与第一个链表有相同的节点。时间复杂度为为线性：O(Length(h1) + Length(h2))，同时为了存储第一个链表的所有节点，空间复杂度为O(Length(h1))。是否还有更好的方法呢，既能够以线性时间复杂度解决问题，又能减少存储空间？ 转换为环的问题。把第二个链表接在第一个链表后面，如果得到的链表有环，则说明两个链表相交。如何判断有环的问题上面已经讨论过了，但这里有更简单的方法。因为如果有环，则第二个链表的表头一定也在环上，即第二个链表会构成一个循环链表，我们只需要遍历第二个链表，看是否会回到起始点就可以判断出来。这个方法的时间复杂度是线性的，空间是常数。 进一步考虑“如果两个没有环的链表相交于某一节点，那么在这个节点之后的所有节点都是两个链表共有的”这个特点，我们可以知道，如果它们相交，则最后一个节点一定是共有的。而我们很容易能得到链表的最后一个节点，所以这成了我们简化解法的一个主要突破口。那么，我们只要判断两个链表的尾指针是否相等。相等，则链表相交；否则，链表不相交。 所以，先遍历第一个链表，记住最后一个节点。然后遍历第二个链表，到最后一个节点时和第一个链表的最后一个节点做比较，如果相同，则相交，否则，不相交。这样我们就得到了一个时间复杂度，它为O((Length(h1) + Length(h2))，而且只用了一个额外的指针来存储最后一个节点。这个方法时间复杂度为线性O(N)，空间复杂度为O(1)，显然比解法三更胜一筹。 解法四的代码如下： 1234567891011121314151617//判断两个链表是否相交bool isIntersect(Node *h1,Node *h2)&#123; if(h1 == NULL || h2 == NULL) return false; //异常判断 while(h1-&gt;next != NULL) &#123; h1 = h1-&gt;next; &#125; while(h2-&gt;next != NULL) &#123; h2 = h2-&gt;next; &#125; if(h1 == h2) return true; //尾节点是否相同 else return false;&#125; 8. 扩展：链表有环，如何判断相交题目描述：上面的问题都是针对链表无环的，那么如果现在，链表是有环的呢?上面的方法还同样有效么? 分析：如果有环且两个链表相交，则两个链表都有共同一个环，即环上的任意一个节点都存在于两个链表上。因此，就可以判断一链表上俩指针相遇的那个节点，在不在另一条链表上。 代码如下： 123456789101112131415161718//判断两个带环链表是否相交bool isIntersectWithLoop(Node *h1,Node *h2)&#123; Node *circleNode1,*circleNode2; if(!hasCircle(h1,circleNode1)) //判断链表带不带环，并保存环内节点 return false; //不带环，异常退出 if(!hasCircle(h2,circleNode2)) return false; Node *temp = circleNode2-&gt;next; while(temp != circleNode2) &#123; if(temp == circleNode1) return true; temp = temp-&gt;next; &#125; return false;&#125; 9. 扩展：两链表相交的第一个公共节点题目描述：如果两个无环单链表相交，怎么求出他们相交的第一个节点呢？ 分析：采用对齐的思想。计算两个链表的长度 L1 , L2，分别用两个指针 p1 , p2 指向两个链表的头，然后将较长链表的 p1（假设为 p1）向后移动L2 - L1个节点，然后再同时向后移动p1 , p2，直到 p1 = p2。相遇的点就是相交的第一个节点。 代码如下： 1234567891011121314151617181920212223242526//求两链表相交的第一个公共节点Node* findIntersectNode(Node *h1,Node *h2)&#123; int len1 = listLength(h1); //求链表长度 int len2 = listLength(h2); //对齐两个链表 if(len1 &gt; len2) &#123; for(int i=0;i&lt;len1-len2;i++) h1=h1-&gt;next; &#125; else &#123; for(int i=0;i&lt;len2-len1;i++) h2=h2-&gt;next; &#125; while(h1 != NULL) &#123; if(h1 == h2) return h1; h1 = h1-&gt;next; h2 = h2-&gt;next; &#125; return NULL;&#125; 10. 总结可以发现，在链表的问题中，通过两个的指针来提高效率是很值得考虑的一个解决方案，所以一定要记住这种解题思路。记住几种典型的链表问题解决方案，很多类似的题目都可以转换到熟悉的问题再解决。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java核心技术（卷1）读书笔记]]></title>
    <url>%2F2015%2F02%2F28%2Fcore-java-volume-i%2F</url>
    <content type="text"><![CDATA[老夫一个寒假就干了这么点事（王老师：怪我咯…… 3 Java的基本程序设计架构 整形（int）的范围与机器无关，都是32位、4字节、-20亿~+20亿。解决了移植性的问题。 long的后缀是l，16进制前缀是0x，8进制前缀0（少用），2进制前缀0b，并且从Java7开始可以在数字中加入下划线，增强易读性。 Java没有无符号类型。 float，占4个字节，后缀F，单精度数，少用。double，占8个字节，后缀D，双精度数，常用。 在数值计算中若要不含任何误差，应该使用BigDecimal类。 strictfp关键字表征了在该方法体中所有浮点运算都将使用严格的浮点计算。 与运算在第一个表达式为假时不会继续计算后续的表达式；或运算在第一个表达式为真的时候不会继续后续的表达式。 &amp;、|运算法作用于布尔值时，同&amp;&amp;、||，只是没有短路的说法，会计算完所有的表达式。 移位运算中，若移位位数多于该数的总位数，会循环移位，因此需要在移位运算中对于移位数进行模运算。 String是不可修改其中某一位的。是不可变字符串。只能修改对于该字符串的引用，变为对于另外字符串的引用。这样的好处是可以将相同的字符串进行共享。虚拟机一般情况下只将常量字符串共享，拼接（+、substring）得到的字符串将不会共享。当然可以设置虚拟机将所有的字符串共享。 Scanner是一个标准的读取输入方法，用法为： 1Scanner in = new Scanner(System.in); Console也是一个标准的读取输入方法。用法为： 12Console con = System.console();String read = con.readLine(&quot;hint:&quot;); 在使用break、continue语句时，最好在break、continue跳出、重复的循环体之前加上标签。 12345read_data:for(int i = 0; i&lt;5; i++)&#123; if(a[i]&gt;50) break read_data;&#125;//then go to here #4 对象与类 类与类之间的关系有： 依赖（Use-a）如果一个类的方法操纵另一个类的对象，则称一个类依赖于另一个类。我们应该尽量使类之间的相互依赖减到最小，如果A与B之间没有依赖，那么意味着A、B的改变不会造成任何Bug，即让类之间的耦合度最小。 聚合（Has-a）类A的对象中包含了类B的对象。 继承（Is-a） Java中虽有的对象变量都是对堆中的对象的引用。 不要编写返回可变对象的访问器方法。如果需要返回一个可变对象的引用，应该首先对他进行clone。 一个方法可以访问所属类的所有对象的私有数据。如类A的对象a中的方法可以访问同为类A的另一个对象b的私有数据。 所有类的对象会共享同一个静态引用。 在类中添加Main方法，是一个进行单元测试的好方法。 传入方法的参数总是按值调用。即，方法得到的是所有参数值的一个拷贝，方法不能修改传递给他的任何参数变量的内容。但是方法的传入参数包括了基本数据类型和对象引用，当传入参数是对象引用的时候，虽然该引用地址不能被更改，但是该引用的对象是可以被修改的。 实际上对象引用进行的依旧是值传递，我们可以操作的是传入的对象引用指向的对象，而不能操作该对象引用。 数据域若是没有被构造器赋值，那么会被默认的将数值置0，布尔置false，对象引用值null。 当且仅当类中没有提供任何构造器时，系统才会默认的提供一个没有输入参数的构造器。若有，那么系统将不会提供0参数的构造器，若在这个时候调用0参数的构造器，将会报错。 在类中的构造器调用之前，会先对预设的值进行赋值。 Java中又三种初始化数据域的方法： 在声明中初始化 在初始化块中初始化 在构造函数中初始化 从上到下依次执行。 可以使用静态代码块对静态变量进行初始化。 静态导入可以方便的使用某个类中的静态方法。如Math类。 5 继承 Object…args等同于Object[] args，在输入任意多参数的时候会被自动装箱成Object[] args。 枚举类的toString方法可以得到该枚举对象的String，反过来，通过枚举对象的String，可以通过Enum.valueOf(枚举类.class,枚举字符串)得到对应的枚举对象。 枚举对象的ordinal()方法可以得到该枚举常量的位置。 6 接口与内部类 虽然不能new一个接口对象，但是可以用一个接口变量引用任何实现了该接口的类对象。 一样的可以同instanceof来检查某个对象是否实现了某个接口；接口依然可以被继承；接口的定义中虽然不能实现具体的方法，但是可以定义常量（static final） 抽象类与接口最大的区别在于，一个子类只能继承于一个抽象类，却可以实现数个接口。（Java是没有多继承的） 即使默认的clone已经满足要求，也应该实现Clonable接口，将clone定义为publi，并调用super.clone（）实现浅拷贝，若要进行深拷贝，则需要在浅拷贝的基础上，对于拷贝出来的对象中每一个引用对象进行深拷贝。 所有的数组类型均包含一个public的克隆方法。可以方便的进行数组对象的克隆。 内部类可以访问自身的数据域，月可以访问创建它的外围类对象的数据域。内部类中总是有一个隐式引用，指向其外部类。 11 异常、断言、日志与调试 由程序导致的是runtimeException，由IO错误导致的错误会返回ioException。 对于所有可能抛出异常、会被别人调用的方法，在声明的时候，最好都要加上throw语句以提示使用者做出反应。 子类中不能抛出比超类中更普适的异常。 throws用于方法名声明时，throw用于抛出具体错误 Java中，throw只能抛出Throwable对象，而不像在cpp中可以抛出任何值。 对于自己定义的Throwable类型，需要实现两个构造器，其中一个是默认构造器，另一个是带有描述信息的构造器，通过调用super的构造器将这些信息打印出来。 在进行错误的处理的时候，最好的策略是，对于知道如何处理的异常进行捕获；对于不知道该如何处理的异常进行传递，将该异常抛给调用这个方法的人，再上一层进行异常处理。 异常传递的时候，可以在新异常中使用initCause方法将原异常作为原因传递给新异常，那么在新异常抛出的时候就可以获取到原始愿意。 在try/finally语句块中使用return需要注意：在try中的return调用之前，会调用finally中的语句块，如果finally语句块中也有return，那么会出现一些很奇妙的错误。 建议独立使用try/finally语句块和try/catch语句块，例如在try/catch中放进try/finlly语句块，这样，外层的catch语句就可以保证捕捉到try语句和finally语句中的异常，并且finally也能被正确的执行。 使用异常的技巧： 只在异常情况下使用异常。使用异常进行测试是非常耗时间的。 不要过分细化异常。尽量使用多个catch对可能的数个异常进行捕获。 利用异常层次结构。不要只抛出runtimeException，不要只捕获throwable异常。 早抛出，晚捕获。早抛出异常可以更加明显的得到异常的类型及信息；晚捕获可以让高层的用户得知发生了错误并做出更加正确的处理动作。 断言机制允许在测试期间向代码中插入一些检查语句，当代码发布的时候，这些语句将被移除。 断言会对给定的条件进行检查，检查结果如果为false，将会抛出一个AssertionError的对象。assert语句有两种形式： assert 条件; assert 条件:表达式; 其中，表达式的作用仅仅是产生一个消息字符串，传入AssertionError构造器中，转换成一个消息字符串。 使用以下语句启用\禁用断言： java -enableassertions MyApp 断言失败是致命的，是不可回复的错误；断言一般只用于开发、检测阶段。 12 泛型程序设计 泛型程序设计意味着编写的代码可以被很多不同类型的对象所重用。 泛型类可以看做普通类的工厂，使用需要的数据类型对泛型类进行初始化，即完成了私有类的生成。 泛型方法定义如下： public static T method(T… a) 调用时，将类名放入尖括号即可。在定义泛型方法的时候，可能需要对于泛型进行限定： public static T method(T… a) 这样的限定相当于限定了该泛型必须调用哪些方法。 13 集合 Java中对于数据结构的类库是将接口与实现分离的，每一个实现都可以通过一个实现了某一个数据类型的接口类型进行标示。对其进行引用的时候，只需要使用接口作为引用变量，引用任何一种实现了该接口的数据结构类型即可。 在API中也有很多以Abstract开头的类，在自己想要实现某种类型的数据结构的时候，继承这些类比直接实现某个接口来的方便很多（虽然基本不会用到） Collection是基本的集合接口，其中有两个基本方法：add和iterator。add用于添加一个元素，成功返回true，失败返回false；iterator用于返回一个迭代器，迭代器是一个实现了Iterator接口的对象，其中包括三个方法：next，hasNext，remove。迭代器用于遍历collection，在Java SE 5.0之后可以优雅的以foreach完成。 foreach在遍历arrayList的时候是顺序访问，在遍历HashSet的时候是以一种随机的方式进行访问。 iterator中的remove是用于删除上次调用next方法时返回的元素。在调用remove之前必须调用next，否则将出错。迭代器所处的位置是两个元素之间。 Java中的链表（LinkedList）都是双向链表。 调用链表的迭代器中的remove需要注意，当先调用next的时候，将会删除左侧节点，当调用previous的时候，将删除右侧节点，即remove总是删除刚刚经历过的节点。 vector所有的方法都是同步的，而Arraylist的方法不是。因此在不需要同步的时候使用ArrayList以节省时间，只在需要同步的时候使用Vector。 Java中hashTable用链表数组实现，每个列表被称为【桶】，桶的个数为总数的75%~150%，最好将桶数设置为一个素数。在插入元素的时候，首先对该元素计算HashCode，然后使用桶数对其取余，得到的数就是插入位置，如果该位置已经有元素，则称发生了【散列冲突】，此时将比较该桶中所有元素，查看是否有重复，若无则插入在桶中最后一个元素的后面。当该散列表中，一定比例的桶已经填充完毕，则需要进行【再散列】，决定是否进行再散列的因子被称为【装填因子】，一般取75%。 TreeSet使用红黑树实现有顺序的散列表，每一次将元素添加到树中的时候，都会被放置到正确的位置上。 优先级队列使用堆完成，堆是一个可以自我调整的二叉树，可以自动的使最小的元素移动到根，而不用花时间排序。 Java中对于映射表也有两个实现：HashMap和TreeMap，均实现了Map接口。此两者均为对键值的操作，并不会按照关联的值进行操作。HashMap对于键值进行散列；TreeMap对于键值进行顺序排列，同样的，hash会比tree更快一些。 14 多线程 多线程：一个程序同时执行多个任务。每一个任务称为一个线程（Thread）。 多线程与多进程的区别在于：每个进程拥有自己的一整套变量，而线程之间则共享数据。 synchronized关键字可以防止代码块收到并发访问的干扰。 也可以使用ReentrantLock保护代码块： 1234567myLock.lock();try&#123; //code here &#125;finally&#123; myLock.unlock;//放在finally中是很重要的事，否则一旦出错，其他线程将永远被阻塞下去。 &#125; 当使用锁的时候，不能使用带资源的try语句。 从Java1.0开始，加入了synchronized关键字，起作用等同于对于整块代码进行保护的进程锁，免去了显式的对方法进行进程锁。同样的，在synchronized标示的方法中，同样可以使用条件锁，响应的语句为wait和notifyAll。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[西岭雪山非自驾攻略]]></title>
    <url>%2F2015%2F02%2F18%2Ftravel-to-xiling%2F</url>
    <content type="text"><![CDATA[老子买车之前再也不去西岭雪山了。 花水湾-西岭雪山 旅行攻略寒假怎么说也得出去玩玩对不对……细细看了一圈，远的地方懒得跑，近的地方都跑干净了，驾照还没拿到，也没办法自驾游，这个尴尬的时间点啊…… 不过好在妹子还是充满创造力的，发现了西岭雪山这么一个去处，ok，说走就走，下面是做的攻略啦。 准备 食品（高热量、轻便） 泳衣（温泉） 帽子、手套（雪山很冷） 换洗的袜子（可能会打湿） 剃须刀、剃须啫喱（刮胡子……） 现金、身份证（很难取钱，准备1500） 手机充电器（必须的） 行程 16日 7:30am 起床 洗漱准备出发 16日 8:00am 拼车出发去眉山车站 16日 9:00am 到达眉山车站，买车票去新津，可提前网上定票 16日 10:30am 到达新津车站，买票去大邑 16日 12:00am 到达大邑车站，买车票去花水湾 16日 14:00pm 到达花水湾，步行或搭车前往城市名人酒店 16日 抵达酒店后，办理入住，休息，泡温泉。结束今天行程。 17日 7:30am 起床吃早饭退房，准备前往西岭雪山。 17日 8:00am 乘包车前往西岭雪山 17日 乘索道前往滑雪场滑雪，午饭自己带干粮解决。 17日 午后返程，从西岭雪山乘车至大邑，原路返程。 总结交通实际上从洪雅去西岭雪山坐公交的话，建议走洪雅-雅安-大邑-西岭雪山的这条线，洪雅-眉山-新津-大邑-西岭雪山太麻烦了，速度慢不说，中间的站都在网上买不到票，非常蛋疼。 到了大邑在车站就需要买好第二天返程的票，否则很容易第二天回不来。 在大邑车站附近没什么吃的，有个路边摊可以随意解决一下问题。 大邑到花水湾和西岭镇其实是一趟车，相当于是乡镇公交，几块钱就OK，大概40分钟左右到花水湾，再花20分钟左右到西岭镇，到了西岭镇然后才能坐黑车去西岭后山坐索道。 第一天花了不少时间才到花水湾小镇，那里很多酒店啊温泉啊什么的，看上去挺衰败的，公交车下车的地方到城市名人度假酒店还有蛮长的距离，要走好久……蛋都碎了。 第二天从城市名人度假酒店出来的很早，路上什么车都没有，正在绝望的时候遇到一个跑西岭的黑车师傅，包车90，送到西岭后山，一开始犹豫了一下，后来还是考虑到要赶时间就认宰了，毕竟只有两个人。幸好师傅还不错，开的快且稳，大概花了30分钟到后山。 下山的时候也是找的黑车，每人25包车到了西岭镇，在那里等了20分钟公交车回了大邑，路上用了1个小时左右。 到大邑客运站的时候是一点半，我们回雅安的车是2点半，于是默默地等了一个小时。 大邑回雅安的车走的是全高速，大概只用了70分钟就到了……这让我定了4点半回洪雅的车的人情何以堪。。。 所以在雅安又大眼瞪小眼的等了将近半个小时…… 雅安道洪雅大概也就需要40分钟，现在想来，如果当时我们去自驾的话，那就真的方便好多，大概从家里出发去西岭雪山，最多也就花个4个小时就OK乐，那还是开得很稳的情况下。。。 心塞。。。 住宿住的就是城市名人啦。。五星级标准，但是只能勉强算是五星，要我说基本也就相当于正常的准四星。。东西蛮旧了，看得出来这边真是比较衰败了，公款吃喝给砍了不少，这边感觉生意都做不下去了。。。 玩耍温泉很赞，也算是我觉得勉强能值回票价的一部分吧。 雪山很垃圾……上面都没雪了。。都是那种融化了又冻住的冰，简直没办法愉快的玩耍。。。]]></content>
      <categories>
        <category>瞎扯</category>
      </categories>
      <tags>
        <tag>旅行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10# Regular Expression Matching]]></title>
    <url>%2F2015%2F01%2F11%2Fleetcode-10%2F</url>
    <content type="text"><![CDATA[弱鸡进城纪实。 今天遇到的一道正则表达式匹配问题的题，题目大意是这样的： 给定两个字符串s和p，其中s是匹配串，p是模式串，p中定义了两个匹配符： ‘.’：通配符，可以指代任何字符（不含’*’）。 ‘*‘：该字符前的一个字符可能出现任意次，该字符包括’.’，出现次数可能为零。 问题当然就是判定给定的s与p是否匹配了。 OK，说实话，我一开始连这个问题都没看明白，后来翻别人的解法之后才明白过来……英文不好真是……哎…… 这个问题的最难点就在于‘*’的处理。’*’前面的字符可能在匹配串中出现0次1次2次……这么多情况该怎么去处理？这些情况都有可能成功匹配，该怎么去简洁的处理这个问题？ 递归。 递归最适合的就是处理这种需要退回栈的问题，从几个基本问题出发，在递归中不断地对分支进行处理。那么具体到这道题，有些什么基本情况呢？ 模式串p的第二个字符不是’*‘，那么只需要考察模式串和匹配串第一个字符是否相同，若相同，则递归的处理从下一个字符开始的s和p。 模式串p的第二个字符是’*‘，那么对于’*‘前的字符i，对于每个可能的匹配次数进行匹配后再依次进行递归。 整个思路很清晰，也很有效率。下面附上代码： 12345678910111213141516171819202122232425262728public boolean isMatch(String s, String p) &#123; //模式串p是空字符串时，只需要考察匹配串s是不是也为空。 if (p.length() == 0) return s.length() == 0; //模式串p的长度为1，或者第二个字符不是&apos;*&apos;时，只需要考察模式串的第一个字符和匹配串的第一个字符是否相同。 if (p.length() == 1 || p.charAt(1) != &apos;*&apos;) &#123; //如果此时匹配串已为空或者p和s的第一个字符不相同，则返回错误。 if (s.length() &lt; 1 || (p.charAt(0) != &apos;.&apos; &amp;&amp; s.charAt(0) != p.charAt(0))) return false; //否则考察从下一个字符开始的s和p是否匹配。 return isMatch(s.substring(1), p.substring(1)); &#125; else &#123; //此时模式串的第二个字符是&apos;*&apos;，这种情况下，我们假定&apos;*&apos;前的字符为i，并且匹配串s中，前k个字符是i（k可能为零，模式串中的i可能是通配符） //按照规则，i可能会匹配匹配串s中从第一个字符起的0到k个i，那么，对于这k种情况，我们应该分别递归的调用这个函数进行考察。 int len = s.length(); int i = -1; while (i &lt; len &amp;&amp; (i &lt; 0 || p.charAt(0) == &apos;.&apos; || p.charAt(0) == s.charAt(i))) &#123; if (isMatch(s.substring(i + 1), p.substring(2))) return true; i++; &#125; //当所有过程被执行完毕还是没有返回true时，两个字符串不匹配。 return false; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>String</tag>
        <tag>Recursion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[老夫终于吃上棒棒糖了哼]]></title>
    <url>%2F2015%2F01%2F10%2Fget-google-now-on-lolipop%2F</url>
    <content type="text"><![CDATA[三流安卓开发者走在装逼道路上的的心路历程。 觊觎萝莉炮很久了，新Material Design、新的交互动画、新的编译系统，对于用户或者是像我这种三流安卓开发狗而言，真的是吸引力满载！奈何万普拉斯公司实在是效率低下，很长一段时间都只能靠Android 4.4 + Google Now启动器勉力支撑着自己的装逼大业……只能徒有其形的苦楚真的是无处言表…… 就在昨天，随手翻了一下万普拉斯论坛，发现CM12竟然已经有Nightly版了，而且最新的一版已经支持OTA更新，真是天空飘来五个字，哈哈哈哈哈，于是趁着周末，一觉睡到11点，起床刷机去~ 虽然万普拉斯公司效率奇低，但是不得不说，毕竟销量大，机型单一，开发者还是不少的，必须为万能工具包此等神器怒点一赞，有了它真的省了不少事，忍痛走流量下载了刷机包和工具包还有精简下来的Google服务包，安装，刷机，一气呵成，再点一赞~ 只是把鸡鸡刷好只是折腾的开始，开启google now服务才是成功的全部，原本的手机是已经搞定了的，新刷系统之后system分区被格式化，因此需要再一次激活一下google now。 网上有很多所谓的激活教程，其实都没个屌用，下面这个经亲测绝逼好使，为了以后不再在我那天量收藏夹里寻找这个，这里记录如下： 保证科学上网环境；英文语言环境；Root环境；GMS环境（暂时不要登录）。 依次安装ES文件管理器、BusyBox、Init.d Toggler、Shell。 下载模拟Sim文件：点我下载。 打开BusyBox，点击Install，安装BusyBox。 打开Init.d Toggler，点击enable Init.d，注意一下提示看是否成功，未成功需要回到上一步重新来一次。 用获取Root权限的ES文件管理器，将下载好的Sim文件放到/sysem/etc/init.d目录下，更改Sim文件的权限为755。 重启手机，运行Shell，执行getprop命令，检查gsm.sim.operator.iso-country是cn还是us。如果是us则可以打开位置报告。 转到google Setting处，在科学上网环境下登陆即可。如果先前已登录，那么请先退出账号，对google服务进行双清，然后再登陆。此时已经可以打开位置报告和Google Now了。 本方法的原理是，利用init.d在开机的时候执行更改Sim卡类型的脚本，将Sim卡类型更改为verison，位置设定在美国，这样就可以绕过中国地Sim卡无法开启位置服务了。]]></content>
      <categories>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>折腾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5# Longest Palindromic Substring]]></title>
    <url>%2F2015%2F01%2F05%2Fleetcode-5%2F</url>
    <content type="text"><![CDATA[弱鸡进城纪实。 弱🐔就是这样，总是觉得什么都很牛逼想记录下来，总是觉得自己low弱，对，我就是个弱🐔，今天又来把大神屌炸天的东西写一写，免得忘了，嗯。 题呢，很简单，#5 Longest Palindromic Substring，简单讲就是求一个字符串的最长回文子字符串。 我的思路是搜索，对于字符串中的每一个字符，考察其作为回文子串中心时对应的回文子串长度，遍历结束，得到最长的回文子串。在考察回文子串的时候，需要对于其回文子串是偶数长度还是奇数长度进行区别考察。 思路很简单，实现起来也不复杂，整个复杂度是O(N^2)，确实也AC了，但是我在后来上网找解法的时候，发现了一种O(N)的方法，当时就惊呆了，赶紧好好地看了一下，这篇博客的主要目的也就是记录这个算法： Manacher’s ALGORITHM: O(n)时间求字符串的最长回文子串 该算法的核心思想有两点，一是其对待求字符串进行的预处理，使处理过程无需对奇偶性做出考量；二是其利用一个很巧妙的结论，不断地重用已有的结果，达到简化运算量的作用。 下面就具体来说下这个算法是怎么做到的（大部分来自这里）： 首先对字符串进行预处理，用特殊字符将其填充至偶数个字符数，例如“123”填充至“$#1#2#3#*”，首尾选择特殊字符以标示开始结束（或者别的方法也行）。 然后用一个数组P[i]来记录以字符S[i]为中心的最长回文子串向左/右扩张的长度（包括S[i]，也就是把该回文串“对折”以后的长度）。如： 12S #1#2#2#1#2#3#2#1#P 12125214121612121 显见的，P[i]-1的最大值就是我们要求的最长回文子串的长度。 那么，如何计算P[i]？ 首先我们需要先说明一个关键的不等式： 1P[i] &gt;= MIN(P[2*id-i], mx-i) id是当前最长回文子串的中心 mx是当前最长回文子串的扩张大小 i是当前考察的字符位置 j=2*id-i是i相对于id对称的点 那么这个不等式的含义就是，P[i]或者等于P[j]，或者大于或等于mx-i。 为了加深理解，画个图出来就很直观了： 当前最长子串内，关于中点对称的两点(j,id,i)，如果已经经过的点j上，P[j]小于mx-i，那么P[i]=P[j]。 当前最长子串内，关于中点id对称的两点(j,id,i)，如果已经经过的点j上，P[j]大于mx-i，那么P[i]至少等于mx-i。 而对于mx小于等于i(j)的情况，我们没有办法做出任何假设，只能认为这个时候P[i]=1了。 OK，到这里，最重要的三点已经解释清楚了，那么接下来我们就可以写出如下的计算P[i]的代码了： 1234567891011121314151617//输入，并处理得到字符串sint p[1000], mx = 0, id = 0;//初始化P数组memset(p, 0, sizeof(p));//遍历S字符数组for (i = 1; s[i] != &apos;\0&apos;; i++) &#123; //核心点，p[i]的值通过历史值进行初始化。 p[i] = mx &gt; i ? min(p[2*id-i], mx-i) : 1; //对p[i]进行更新 while (s[i + p[i]] == s[i - p[i]]) p[i]++; //如果p[i]+i的范围比mx更大，那么后续的点就需要在这个新的范围内进行考察了。 if (i + p[i] &gt; mx) &#123; mx = i + p[i]; id = i; &#125;&#125;//找出p[i]中最大的 OK，到此为止这个算法就记录的差不多了，其实主要的思想还是复用之前算出来的结果，达到简化运算的目的，这个算法在while循环上省了很多功夫。 整个复杂度不太好算，既然他说是O(N)那就是O(N)吧。哈哈。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>String</tag>
        <tag>回文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4# Median of Two Sorted Arrays]]></title>
    <url>%2F2015%2F01%2F04%2Fleetcode-4%2F</url>
    <content type="text"><![CDATA[弱鸡进城纪实。 昨晚睡前开搞的一道LeetCode，#4 Median of Two Sorted Arrays，大意是，给定两个有序数组，找出这两个数组的中位数，时间复杂度在O(logN)内。 OK，拿到这道题的第一思路是并归排序之后取中值。但是因为复杂度为O(M+N)，并不符合题意，于是另作他想。 昨晚因为太晚没有细想，就是模模糊糊觉得对数时间复杂度这个应该和二分搜索有关，具体的又没什么头绪。 今天继续攻略这道题，未果，死马当活马医的写了一个并归算法提交上去没想到居然AC，囧rz…… 但是怎么想怎么不爽，这明显他喵的不对也能过？得过且过明显不是我的忍道，于是上网找了些资料，才知道这道题应该做如是处理： 求两个有序数组的中位数，其实可以作为“求两个有序数组的第K个最小值”的特殊情况来看待。 而我们可以轻易得到这样三个结论： 有序数组A的第K/2个值如果比有序数组B的第K/2个值小，那么有序数组A的前K/2个值中不可能会有有序数组A+B的第K个值。 有序数组B的第K/2个值如果比有序数组A的第K/2个值小，那么有序数组B* 的前K/2个值中不可能会有有序数组A+B的第K个值。 有序数组A的第K/2个值如果与有序数组B的第K/2个值相等，那么该值即为A+B的第K个值 进一步的，我们可以得出一个这样的结论：如果A数组中第Ka个数比B数组中得第K-Ka个数小，那么A+B的第K个数肯定不在A数组的前Ka个数中。 由此我们可以写出一个递归的函数，其作用为返回有序数列A和B组合之后的第K个数： 1234567891011121314151617181920212223double findKth(int A[], int m, int B[], int n, int k)&#123; //默认人为A的长度比B小 if(m&gt;n) return findKth(B,n,A,m,k); //如果A的长度为0，那么返回B[K-1] if(m == 0) return B[k-1]; //如果K=1（求第一个数），那么可以直接得到 if(k == 1) return min(A[0],B[0]); //将K分为前两个K/2，如果A int ka = min(k/2,m); int kb = k - ka; //开始递归 if(A[ka -1]&gt;B[kb-1]) //如果A数列中第Ka个数比较大，那么可以舍弃B数列中的前Kb个数 return findKth(A,m,B+kb,n-kb,k-kb); else if(A[ka -1]&lt;B[kb-1]) //如果B数列中第Kb个数比较大，那么可以舍弃A数列中的前Ka个数 return findKth(A+ka,m-ka,B,n,k-ka); else //如果A数列中的第Ka个数和B数列中的第Kb个数相同，那么这就是A+B的第K个数 return A[ka-]; &#125; OK，到这里基本就结束了，不过这道题在处理两个数列个数之和为偶数的时候是取中间两个中位数的均值作为最终的中位数的，所以这里在外边需要对于奇偶性进行分开讨论： 12345678double findMedianSortedArrays(int A[], int m, int B[], int n) &#123; int length = m+n; if(length %2==1)&#123; return findKth(A,m,B,n,length/2+1); &#125;else&#123; return (findKth(A,m,B,n,length/2)+findKth(A,m,B,n,length/2+1))/2; &#125; &#125; OK，到这里这道题就结束了，整个复杂度是O(log(M+N))，最后运行的结果也很漂亮，108ms，基本是最靠前的了。 这里必须吐槽一句，同样的写法，我用Java提交，用时将近一秒，用CPP提交，用时108ms，不得不感叹一下，Java真的很不适合做这种数组类型的题…… （不，主要是我LOW）]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二分</tag>
        <tag>Kth</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Digital Ocean + Shadowsocks + Ipv6，免流量科学上网]]></title>
    <url>%2F2015%2F01%2F01%2Fmy-first-vps%2F</url>
    <content type="text"><![CDATA[校园网收费，真的断我等屌丝的活路，不过好在ipv6足够坚挺，Github的教育网大礼包足够屌，那么这里就简单介绍个利用Shadowsocks和Digital Ocean自建SS服务器免流量上(fan)网(qiang)的方法。 准备工作准备无线ipv6环境OK，既然是打算免流量，那么当然包括我所有的设备都必须要免流量，对吧？有线连接的设备和无线连接的设备都得保证能够免流量，那么原有的路由器工作模式就不适用了，这里我们可以将无线路由器改成交换机模式，让无线设备也可以使用ipv6，具体步骤如下： 1.进入路由器的管理页面，关闭DHCP功能。 2.将入口网线从WAN端口转移到交换机端口上。 3.重启一下路由器，这个时候也是用原有的用户名密码登陆路由器，只不过这个时候就相当于连接到了一台交换机上，而且你也没办法再通过192.168.1.1进入管理界面了。但是这个时候你会发现可以直接连上BT了，这就说明ipv6在无线网络环境中启用了。 准备VPSVPS有很多家了……Linode、ramnode、DigitalOcean之类的，很多，blabla，这里只需要保证VPS有ipv6链接即可，并且最好是服务器架设在美国，因为某些众所周知的原因，出口的ipv6流量现在基本都会从那边绕回来，所以就不要选台湾香港日本的服务器了~ 这里推荐一下前文提到的也是现在在用的Digital Ocean，做的真的很不错，而且用github的教育礼包真的优惠力度十足，特别适合我等穷学生，而且就算花钱，DO的VPS也是性价比相当高。 如何申请VPS这里略过，但是有一点需要注意，最好有一张Visa的信用卡，不然可能会比较麻烦，在选取VPS之后有的时候需要手动开启ipv6功能~ 搭建Shadowsocks Shadowsocks的作者Clowwindy于2015年8月20日成功被TG约谈，因此Shadowsocks版本最终锁定在了2.8.2。不知道将来Shadowsocks会不会由后来人继续更新，无论如何，向Clowwindy致敬，向开源致敬，向自由致敬。 本文最早介绍安装Shadowsocks的时候还很复杂，随着作者不断地迭代更新，也是在不断地将安装简化，在一些特定的系统中，我们只需要很简单的几个步骤就可以完成Shadowsocks服务器的搭建和优化，向这些充满理想的程序员致敬。 官方推荐 Ubuntu 14.04 LTS 作为服务器以便使用 TCP Fast Open。服务器端的安装非常简单。 Debian / Ubuntu: 12apt-get install python-pippip install shadowsocks CentOS 12yum install python-setuptools &amp;&amp; easy_install pippip install shadowsocks 运行的时候也很简单，首先建议建立一个独立的文件夹存放config.json文件： 123456789&#123; "server":"::",//双栈 "server_port":7777, "local_address": "127.0.0.1",//设置该参数和下面的参数将指定客户端的本地代理地址和端口 "local_port":1080, "password":"password", "timeout":300, "method":"rc4-md5"//该加密方法安全性、性能较为均衡&#125; 然后建立两个sh文件作为启动脚本： Start 1ssserver -c path-to-config.json --fast-open -d start #以config.json为配置文件、开启fast-open、静默后台启动 Stop 1ssserver -d stop #停止服务 至此Shadowsocks服务就已经跑起来了，是不是很方便？ 优化性能网上关于性能调优的文章蛮多，但是经测试都没什么屌用（汗），这里主要推荐使用锐速，效果拔群。 锐速是一款非常不错的TCP底层加速软件，可以非常方便快速地完成服务器网络的优化，配合 Shadowsocks效果奇佳。目前锐速官方也出了永久免费版本，适用带宽20M、3000加速连接，个人使用是足够了。 使用时，首先需要在锐速官网注册账户，然后确定自己的内核是否在锐速的支持列表里，如果不在，请先更换内核，如果确定自己的内核版本在支持列表里，就可以使用以下命令快速安装了： 123wget http://my.serverspeeder.com/d/ls/serverSpeederInstaller.tar.gztar xzvf serverSpeederInstaller.tar.gzbash serverSpeederInstaller.sh 输入在官网注册的账号密码进行安装，参数设置直接回车默认即可，到这里还没结束，我们还要修改锐速的3个参数： 1vi /serverspeeder/etc/config 修改以下几个参数： 1234567rsc="1" #RSC网卡驱动模式 advinacc="1" #流量方向加速 maxmode="1" #最大传输模式#DO的网卡支持rsc和gso高级算法:rsc="1"gso="1" 然后重启下就好啦： 1service serverSpeeder restart 使用Shadowsocks使用的话，就是各个平台上的软件啦，这方面的事情不需要多说，自己翻Github，小白的一逼。 自定义代理域名ipv6好是好，但是地址确实太长了，别说告诉别人了，你自己都记不住，那可如何是好？ok，你需要一个你自己的域名。 买域名的话，狗爹godaddy.com和name.com都是很好的选择，但是有一点，他们都是美元支付，而且都需要绑定信用卡或者paypal，如果没有的话会稍微蛋疼一点，但也不至于没办法，这个就靠大家的智慧啦~ 买到域名之后，DO的做法是需要将域名的nameserver替换为DO自己的nameserver作为域名解析，估计别的vps站也是大同小异，就不具体叙述啦。我定义了两个服务器，分别接受ipv4访问和ipv6访问。 ss4.kyangcis.me ss6.kyangcis.me 也有人说可以怎么怎么样一个网址双栈访问，的确是可以，但是为了在学校的时候不误走v4流量，我还是分开来了。我现在的服务器虽然只有我和我的几个朋友在用，但是为了安全就不对外开放啦。 使用情况就上张Speedtest的图好了： 实际使用中，一般的国外网址打开都没什么压力，有的国内的网站可能是因为DNS的原因，第一次打开还是会有点慢，不过问题不大。]]></content>
      <categories>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>Shadowsocks</tag>
        <tag>VPS</tag>
        <tag>DigitalOcean</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发微信登陆中遇到的问题记录]]></title>
    <url>%2F2014%2F12%2F02%2Fproblems-inwechat-login%2F</url>
    <content type="text"><![CDATA[微信的文档烂到一种境界应该是业界常识了。 OK，让我们从头开始review一下微信登陆第三方应用我们应该做些什么： 在微信开放平台上注册应用，拿到AppID和AppSecret。 在开放平台上注册你的Android应用，填写好包名和使用鹅厂提供的签名生成app生成出来的MD5值。注意：需要事先给项目中添加好签名文件，如果使用的是Android Studio，那么需要在Project Structure里面设置好编译用的签名文件，否则一直run出来的都是默认的签名，使用该签名似乎无法通过校验。 开放平台设置完了之后开始搞本地的事情： 注册你的应用到微信。最好在在Application全局类中完成，方法在SDK中写得很清楚，这里就不赘述了。 从你需要调用微信认证的地方发出SendAuth请求，呼起微信，方法也在SDK写得很清楚，这里也不再重复了。不过这里需要注意一点：应用签名、AppID必须和远端一致，否则无法唤起确认登陆界面。 经过以上两步，没有问题的话，你已经可以唤起微信登陆界面并且能够确认登陆了，接下来，在你的包名目录下建立一个wxapi包，然后在包下建立一个名为WXEntryActivity的activity，在manifest里面注册这个activity，并设置exported = true，之后在Activity中实现IWXAPIEventHandler这个接口，并实现里面的onResp，onCreate，onNewIntent方法，这些方法是用来在微信返回认证信息之后，我们接收intent，获取数据的时候用的。OK，准备工作做到这里，有一个坑，当你运行这段代码的时候，你会发现，onNewIntent方法并没有被调用，这就奇怪了，狗日的SDK文档中对这个只字未提，从正常人的思维角度上讲，既然文档中对onNewIntent的调用有需求，那么微信通过intent启动该activity的时候就应该通过在intent中addFlag的方式，主动的设置启动方式为singleTaks，这样就可以保证onCreate不被二次调用，onNewIntent可以被正常的调用了。 OK，事实证明是我想多了，他压根儿没有这么做的意思。在经历了一系列可能故障的排查并且浪费了我整整一下午之后，我终于意识到我一开始最不可能的事情发生了。对，整个过程在我在Manifest里面找到WXEntryActivity并在其属性中设置LaunchMode为singleTask之后结束了。 OK，接下来你已经可以从onResp里面获得认证code，接下来的事情就是与服务器交互拿到用户数据了，这些就不在本文的记录范围中咯。 总的来讲微信登陆还是做得比较平滑和易用的，速度也很快，给鹅厂点个赞。但是在用户手册中这样的语焉不详真的好吗？Google的时候发现大家对于鹅厂SDK文档的怨念简直遍布全网……接下来还会做微信分享等等一系列的开放平台接入，让我们看看我究竟还要写多少篇被坑文吧……]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>微信</tag>
      </tags>
  </entry>
</search>
